<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>AIS Metrics Dashboard</title>
  <script src="message_types.js"></script>
  <style>
    :root {
      --bg: #f5f7fa;
      --card-bg: #fff;
      --card-shadow: rgba(0, 0, 0, 0.1);
      --primary: #2f80ed;
      --text: #333;
      --muted: #666;
    }
    body {
      margin: 0;
      padding: 1rem;
      font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, sans-serif;
      background: var(--bg);
      color: var(--text);
    }
    h1 {
      text-align: center;
      color: var(--primary);
      margin-bottom: 1rem;
    }
    .grid {
      display: grid;
      gap: 1rem;
      grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
    }
    .card {
      background: var(--card-bg);
      border-radius: 8px;
      box-shadow: 0 2px 8px var(--card-shadow);
      padding: 1rem;
      text-align: center;
    }
    .card h2 {
      margin: 0;
      font-size: 1.25rem;
      color: var(--muted);
    }
    .card p {
      margin: .5rem 0 0;
      font-size: 2rem;
      font-weight: bold;
      color: var(--primary);
    }
    section {
      margin-top: 2rem;
    }
    section h3 {
      margin-bottom: .5rem;
      color: var(--primary);
    }
    table {
      width: 100%;
      border-collapse: collapse;
      background: var(--card-bg);
      box-shadow: 0 1px 4px var(--card-shadow);
      border-radius: 4px;
      overflow: hidden;
    }
    th, td {
      padding: .5rem;
      text-align: left;
    }
    th {
      background: var(--primary);
      color: #fff;
      font-weight: normal;
    }
    tr:nth-child(even) {
      background: #f0f4ff;
    }
    @media (max-width: 600px) {
      .card p {
        font-size: 1.5rem;
      }
    }
    .small {
      font-size: .85rem;
      color: var(--muted);
    }
  </style>

  <script defer>
    document.addEventListener('DOMContentLoaded', () => {
      const overviewKeys = [
        { id: 'total_bytes_forwarded', label: 'Bytes Per Destination' },
        { id: 'bytes_forwarded_window', label: 'Bytes Per Destination (window)' },
        { id: 'total_messages', label: 'Total Messages' },
        { id: 'window_messages', label: 'Messages (window)' },
        { id: 'total_failures', label: 'Total Failures' },
        { id: 'window_failures', label: 'Failures (window)' },
        { id: 'total_downsampled', label: 'Total Downsampled' },
        { id: 'window_downsampled', label: 'Downsampled (window)' },
        { id: 'total_deduplicated', label: 'Total Deduplicated' },
        { id: 'window_deduplicated', label: 'Deduplicated (window)' },
        { id: 'total_bytes_received', label: 'Total Bytes Received' },
        { id: 'total_messages_forwarded', label: 'Total Messages Forwarded' },
        { id: 'window_messages_forwarded', label: 'Messages Forwarded (window)' },
        { id: 'bytes_received_window', label: 'Bytes Received (window)' },
        { id: 'total_clients', label: 'Total Clients' }
      ];

      function formatNumber(value) {
        if (value >= 1_000_000) {
          return (value / 1_000_000).toFixed(2) + 'M';
        } else if (value >= 1_000) {
          return (value / 1_000).toFixed(2) + 'K';
        } else {
          return value.toString();
        }
      }

      function formatPercentage(value) {
        return (value * 100).toFixed(1) + '%';
      }

      function renderOverview(data) {
        const container = document.getElementById('overview');
        container.innerHTML = '';

        // Build dynamic "per X seconds" label
        const windowSize = data.metric_window_size_sec;
        const windowLabel = `per ${windowSize} seconds`;

        // Update all table-header spans
        document.querySelectorAll('.window-size').forEach(el => {
          el.textContent = windowSize;
        });

        // Render the overview cards, replacing "(window)" with "per X seconds"
        overviewKeys.forEach(({ id, label }) => {
          let displayLabel = label;
          if (label.includes('(window)')) {
            displayLabel = label.replace('(window)', windowLabel);
          }
          const card = document.createElement('div');
          card.className = 'card';
          const title = document.createElement('h2');
          title.textContent = displayLabel;
          const value = document.createElement('p');
          value.textContent = formatNumber(data[id] ?? 0);
          card.append(title, value);
          container.appendChild(card);
        });

        // Add logic for "All Shards Covered" card
        const allShardsCovered = (data.shards_missing && data.shards_missing.length === 0) ? 'Yes' : 'No';
        const allShardsCard = document.createElement('div');
        allShardsCard.className = 'card';
        const allShardsTitle = document.createElement('h2');
        allShardsTitle.textContent = 'All Shards Connected';
        const allShardsValue = document.createElement('p');
        allShardsValue.textContent = allShardsCovered;
        allShardsCard.append(allShardsTitle, allShardsValue);
        container.appendChild(allShardsCard);

	const ratioTotal = data.ratio_forwarded_to_received ?? 0;
	const ratioWindow = data.window_ratio_forwarded_to_received ?? 0;

	// Create the Total Ratio card
	const ratioCardTotal = document.createElement('div');
	ratioCardTotal.className = 'card';
		const ratioTitleTotal = document.createElement('h2');
	ratioTitleTotal.textContent = 'Total Forwarding Ratio';
	const ratioValueTotal = document.createElement('p');
	ratioValueTotal.textContent = formatPercentage(ratioTotal); // Display as percentage
	ratioCardTotal.append(ratioTitleTotal, ratioValueTotal);
	container.appendChild(ratioCardTotal);

	// Create the Ratio per X Seconds card (replacing window ratio)
	const ratioCardWindow = document.createElement('div');
	ratioCardWindow.className = 'card';
	const ratioTitleWindow = document.createElement('h2');
	ratioTitleWindow.textContent = `Forwarding Ratio ${windowLabel}`;  // Label updated
	const ratioValueWindow = document.createElement('p');
	ratioValueWindow.textContent = formatPercentage(ratioWindow); // Display as percentage
	ratioCardWindow.append(ratioTitleWindow, ratioValueWindow);
	container.appendChild(ratioCardWindow);

      }

function renderMap(tableId, mapObj) {
  const tbody = document.getElementById(tableId).querySelector('tbody');
  tbody.innerHTML = '';

  // Only translate message IDs if it's a "per_message_id" table
  const isMessageIdTable = tableId === "per_message_id" || tableId === "down_msg";

  Object.entries(mapObj || {})
    .sort(([, a], [, b]) => b - a)
    .slice(0, 25)
    .forEach(([key, val]) => {
      const tr = document.createElement('tr');
      
      // If we're rendering a message ID table, use aisMessageMapping
      const displayKey = isMessageIdTable && aisMessageMapping[key]
        ? aisMessageMapping[key]
        : key; // For non-message-id tables, just use the raw key value

      tr.innerHTML = `<td>${displayKey}</td><td>${formatNumber(val)}</td>`;
      tbody.appendChild(tr);
    });
}



      function renderArray(tableId, arr, keyField, valField) {
        const tbody = document.getElementById(tableId).querySelector('tbody');
        tbody.innerHTML = '';
        (arr || [])
          .sort((a, b) => b[valField] - a[valField])
          .slice(0, 25)
          .forEach(item => {
            const tr = document.createElement('tr');
            tr.innerHTML = `<td>${item[keyField]}</td><td>${formatNumber(item[valField])}</td>`;
            tbody.appendChild(tr);
          });
      }

      function renderTopUsers(tableId, list) {
        const tbody = document.getElementById(tableId).querySelector('tbody');
        tbody.innerHTML = '';
        (list || []).slice(0, 25).forEach(u => {
          const perMsg = Object.entries(u.per_message_id || {})
                            .map(([mid, c]) => `${mid}:${c}`).join(', ');
          const tr = document.createElement('tr');
          tr.innerHTML = `
            <td>${u.user_id}</td>
            <td>${u.count}</td>
            <td>${perMsg}</td>`;
          tbody.appendChild(tr);
        });
      }

      function renderConnectedClients(tableId, connectedClients) {
        const tbody = document.getElementById(tableId).querySelector('tbody');
        tbody.innerHTML = '';
        (connectedClients || []).forEach(client => {
          const tr = document.createElement('tr');
          tr.innerHTML = `
            <td>${client.ip}</td>
            <td>${(client.shards || []).join(', ')}</td>
            <td>${client.version}</td>
            <td>${formatNumber(client.bytes_sent)}</td>
            <td>${formatNumber(client.messages_sent)}</td>
            <td>${formatNumber(client.messages_per_window)}</td>
            <td>${formatNumber(client.bytes_per_window)}</td>`;
          tbody.appendChild(tr);
        });
      }

      function renderShardsWithoutClients(shards_missing) {
        const container = document.getElementById('shards_without_clients');
        const tbody = container.querySelector('tbody');
        tbody.innerHTML = '';

        // Loop through shards_missing to display all shards without clients
        shards_missing.forEach(shard => {
          const tr = document.createElement('tr');
          tr.innerHTML = `<td>${shard}</td>`;
          tbody.appendChild(tr);
        });
      }

      function renderOverlappingClients(shards_multiple) {
        const container = document.getElementById('overlapping_clients');
        const tbody = container.querySelector('tbody');
        tbody.innerHTML = '';

        // Loop through shards_multiple to display shards with multiple clients
        Object.entries(shards_multiple).forEach(([shard, clients]) => {
          if (clients.length > 1) {
            const tr = document.createElement('tr');
            tr.innerHTML = `<td>${shard}</td><td>${clients.join(', ')}</td>`;
            tbody.appendChild(tr);
          }
        });
      }

      async function fetchAndRender() {
        try {
          const res = await fetch('/metrics');
          if (!res.ok) throw new Error(res.statusText);
          const data = await res.json();

          renderOverview(data);
          renderMap('per_message_id', data.per_message_id);
          renderTopUsers('top_users', data.top25_per_user_id);
          renderArray('failures_by_source', data.failures_by_source, 'source_ip', 'count');
          renderArray('totals_by_source', data.totals_by_source, 'source_ip', 'count');
          renderArray('bytes_received_by_source', data.bytes_received_by_source, 'source_ip', 'count');
          renderMap('down_msg', data.per_downsampled_message_id);
          renderTopUsers('down_user', data.top25_downsampled_per_user_id);
          renderTopUsers('dedup_users', data.top25_deduplicated_per_user_id);
          renderArray('dedup_sources', data.top25_deduplicated_per_source, 'source_ip', 'count');
          renderMap('messages_per_shard', data.messages_per_shard);
          renderMap('user_ids_per_shard', data.user_ids_per_shard);
          renderConnectedClients('connected_clients', data.connected_clients);

          // New Tables and Cards
          renderShardsWithoutClients(data.shards_missing);
          renderOverlappingClients(data.shards_multiple);
          
        } catch (err) {
          console.error('Error loading metrics:', err);
        }
      }

      fetchAndRender();
      setInterval(fetchAndRender, 1000);
    });
  </script>
</head>

<body>
  <h1>AIS Metrics Dashboard</h1>
  <div class="grid" id="overview"></div>

  <section>
    <h3>Per Message Type</h3>
    <table id="per_message_id">
      <thead>
        <tr><th>Message Type</th><th>Total</th></tr>
      </thead>
      <tbody></tbody>
    </table>
  </section>

  <section>
    <h3>Top 25 MMSI</h3>
    <table id="top_users">
      <thead>
        <tr>
          <th>MMSI</th>
          <th>Total</th>
          <th>Per Message Type</th>
        </tr>
      </thead>
      <tbody></tbody>
    </table>
  </section>

  <section>
    <h3>Failures by Source IP (Top 25)</h3>
    <table id="failures_by_source">
      <thead>
        <tr><th>Source IP</th><th>Failures</th></tr>
      </thead>
      <tbody></tbody>
    </table>
  </section>

  <section>
    <h3>Messages by Source IP (Top 25)</h3>
    <table id="totals_by_source">
      <thead>
        <tr><th>Source IP</th><th>Total Msgs</th></tr>
      </thead>
      <tbody></tbody>
    </table>
  </section>

  <section>
    <h3>Bytes Received by Source IP (Top 25)</h3>
    <table id="bytes_received_by_source">
      <thead>
        <tr><th>Source IP</th><th>Bytes Received</th></tr>
      </thead>
      <tbody></tbody>
    </table>
  </section>

  <section>
    <h3>Downsampled per Message Type</h3>
    <table id="down_msg">
      <thead>
        <tr><th>Message Type</th><th>Total</th></tr>
      </thead>
      <tbody></tbody>
    </table>
  </section>

  <section>
    <h3>Top 25 Downsampled MMSI</h3>
    <table id="down_user">
      <thead>
        <tr>
          <th>MMSI</th>
          <th>Total</th>
          <th>Per Message Type</th>
        </tr>
      </thead>
      <tbody></tbody>
    </table>
  </section>

  <section>
    <h3>Top 25 Deduplicated MMSI</h3>
    <table id="dedup_users">
      <thead>
        <tr>
          <th>MMSI</th>
          <th>Duplicates Dropped</th>
          <th>Per Message Type</th>
        </tr>
      </thead>
      <tbody></tbody>
    </table>
  </section>

  <section>
    <h3>Top 25 Deduplicated Source IPs</h3>
    <table id="dedup_sources">
      <thead>
        <tr><th>Source IP</th><th>Duplicates Dropped</th></tr>
      </thead>
      <tbody></tbody>
    </table>
  </section>

  <section>
    <h3>Messages per Shard</h3>
    <table id="messages_per_shard">
      <thead>
        <tr><th>Shard</th><th>Messages</th></tr>
      </thead>
      <tbody></tbody>
    </table>
  </section>

  <section>
    <h3>MMSIs per Shard</h3>
    <table id="user_ids_per_shard">
      <thead>
        <tr><th>Shard</th><th>Unique MMSI</th></tr>
      </thead>
      <tbody></tbody>
    </table>
  </section>

  <section>
    <h3>Connected Clients</h3>
    <table id="connected_clients">
      <thead>
        <tr>
          <th>IP</th>
          <th>Shards</th>
          <th>Version</th>
          <th>Bytes Sent</th>
          <th>Msgs Sent</th>
          <th>Messages per <span class="window-size"></span> seconds</th>
          <th>Bytes per <span class="window-size"></span> seconds</th>
        </tr>
      </thead>
      <tbody></tbody>
    </table>
  </section>

  <section>
    <h3>Shards Without Clients</h3>
    <table id="shards_without_clients">
      <thead>
        <tr><th>Shard</th></tr>
      </thead>
      <tbody></tbody>
    </table>
  </section>

  <section>
    <h3>Overlapping Shard Clients</h3>
    <table id="overlapping_clients">
      <thead>
        <tr><th>Shard</th><th>Clients</th></tr>
      </thead>
      <tbody></tbody>
    </table>
  </section>

</body>
</html>
