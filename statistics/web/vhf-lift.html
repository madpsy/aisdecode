<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>VHF Lift Analysis</title>
  
  <!-- Bootstrap 5 CSS -->
  <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/css/bootstrap.min.css" rel="stylesheet">
  <!-- Leaflet CSS -->
  <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" integrity="sha256-p4NxAoJBhIIN+hmNHrzRCf9tD/miZyoHS5obTRR9BMY=" crossorigin=""/>
  <!-- Leaflet Heat plugin -->
  <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js" integrity="sha256-20nQCchB9co0qIjJZRGuk2/Z9VM+kNiyxNV1lvTlZBo=" crossorigin=""></script>
  <!-- Chart.js for visualizations -->
  <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
  
  <style>
    body {
      background-color: #f8f9fa;
      padding: 2rem;
      font-family: sans-serif;
    }
    h1 {
      color: #343a40;
      margin-bottom: 1.5rem;
    }
    .card {
      box-shadow: 0 2px 6px rgba(0,0,0,0.1);
      margin-bottom: 2rem;
    }
    #anomaly-map {
      height: 500px;
      width: 100%;
      border-radius: 5px;
    }
    #anomalies-container {
      height: 500px;
      display: flex;
      flex-direction: column;
    }
    #anomalies-list {
      flex-grow: 1;
      overflow-y: auto;
      max-height: 450px; /* Allow space for header */
    }
    .controls {
      margin-bottom: 1rem;
    }
    .anomaly-card {
      transition: all 0.3s ease;
      cursor: pointer;
    }
    .anomaly-card:hover {
      transform: translateY(-5px);
      box-shadow: 0 4px 8px rgba(0,0,0,0.2);
    }
    .anomaly-card.selected {
      border: 2px solid #0d6efd;
    }
    .direction-arrow {
      font-size: 1.5rem;
      font-weight: bold;
    }
    .loading-overlay, .no-data-overlay {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background-color: rgba(255, 255, 255, 0.8);
      display: flex;
      justify-content: center;
      align-items: center;
      z-index: 2000;
      font-size: 1.2rem;
      font-weight: bold;
      color: #666;
      display: none;
    }
    .loading-spinner {
      border: 4px solid #f3f3f3;
      border-top: 4px solid #3498db;
      border-radius: 50%;
      width: 30px;
      height: 30px;
      animation: spin 1s linear infinite;
      margin-right: 10px;
    }
    @keyframes spin {
      0% { transform: rotate(0deg); }
      100% { transform: rotate(360deg); }
    }
    .info-box {
      background-color: #e9f5ff;
      border-left: 4px solid #0d6efd;
      padding: 1rem;
      margin-bottom: 1.5rem;
    }
    .chart-container {
      position: relative;
      height: 300px;
      width: 100%;
    }
  </style>
</head>
<body>
  <div class="container-fluid">
    <div class="d-flex justify-content-between align-items-center mb-3">
      <h1>VHF Lift Analysis</h1>
      <div>
        <a href="coverage.html" id="coverage-link" class="btn btn-outline-secondary me-2">Coverage Map</a>
        <button id="copy-link-btn" class="btn btn-outline-secondary">
          <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" class="bi bi-link-45deg" viewBox="0 0 16 16">
            <path d="M4.715 6.542 3.343 7.914a3 3 0 1 0 4.243 4.243l1.828-1.829A3 3 0 0 0 8.586 5.5L8 6.086a1.002 1.002 0 0 0-.154.199 2 2 0 0 1 .861 3.337L6.88 11.45a2 2 0 1 1-2.83-2.83l.793-.792a4.018 4.018 0 0 1-.128-1.287z"/>
            <path d="M6.586 4.672A3 3 0 0 0 7.414 9.5l.775-.776a2 2 0 0 1-.896-3.346L9.12 3.55a2 2 0 1 1 2.83 2.83l-.793.792c.112.42.155.855.128 1.287l1.372-1.372a3 3 0 1 0-4.243-4.243L6.586 4.672z"/>
          </svg>
          Copy Link
        </button>
      </div>
    </div>
    
    <div class="info-box">
      <h5>About VHF Lift Detection</h5>
      <p>
        VHF lift (tropospheric ducting) occurs when atmospheric conditions allow VHF signals to propagate much further than normal line-of-sight distances. 
        This tool analyzes AIS reception data to detect potential VHF lift conditions by identifying:
      </p>
      <ul>
        <li><strong>Range Anomalies:</strong> Unusual increases in reception distance (20%+ over baseline)</li>
        <li><strong>Directional Anomalies:</strong> Unusual increases in reception from specific directions (50%+ over baseline)</li>
      </ul>
      <p>
        These anomalies often correlate with atmospheric conditions like temperature inversions that can create tropospheric ducts.
      </p>
    </div>
<div class="card">
      <div class="card-body">
        <div class="controls row">
          <div class="col-md-4">
            <label for="receiver-select" class="form-label">Receiver:</label>
            <select id="receiver-select" class="form-select">
              <option value="" selected>All</option>
              <!-- Receivers will be loaded dynamically -->
            </select>
          </div>
          <div class="col-md-4">
            <div class="mb-2">
              <label class="form-label">Select time range:</label>
              <div class="form-check">
                <input class="form-check-input" type="radio" name="timeRangeType" id="fixedWindowRadio" value="fixed" checked>
                <label class="form-check-label" for="fixedWindowRadio">
                  Fixed time window
                </label>
              </div>
              <div class="form-check">
                <input class="form-check-input" type="radio" name="timeRangeType" id="dateRangeRadio" value="dateRange">
                <label class="form-check-label" for="dateRangeRadio">
                  Custom date range
                </label>
              </div>
            </div>
            
            <!-- Fixed time window -->
            <div id="fixedWindowContainer">
              <label for="days-select" class="form-label">Time window:</label>
              <select id="days-select" class="form-select">
                <option value="1">1 day</option>
                <option value="2">2 days</option>
                <option value="7" selected>7 days</option>
                <option value="14">14 days</option>
                <option value="30">30 days</option>
              </select>
            </div>
            
            <!-- Date range -->
            <div id="dateRangeContainer" style="display: none;">
              <!-- From date -->
              <div class="mb-2">
                <label for="from-date" class="form-label">From:</label>
                <input type="datetime-local" id="from-date" class="form-control">
              </div>
              
              <!-- To date -->
              <div class="mb-2">
                <label for="to-date" class="form-label">To:</label>
                <input type="datetime-local" id="to-date" class="form-control">
              </div>
              
              <div class="mt-2">
                <button id="date-range-go" class="btn btn-primary">Go</button>
                <div id="date-range-error" class="text-danger mt-2" style="display: none;"></div>
              </div>
            </div>
          </div>
          <div class="col-md-4">
            <label for="anomaly-type" class="form-label">Anomaly Type:</label>
            <select id="anomaly-type" class="form-select">
              <option value="range" selected>Range Anomalies</option>
              <option value="direction">Directional Anomalies</option>
            </select>
          </div>
        </div>
        
        <div class="row mt-4">
          <div class="col-md-8">
            <div id="anomaly-map" style="position: relative;">
              <!-- Loading overlay for map -->
              <div class="loading-overlay" id="mapLoadingOverlay">
                <div class="loading-spinner"></div>
                <span>Loading...</span>
              </div>
              <!-- No data overlay for map -->
              <div class="no-data-overlay" id="noDataOverlay">
                <span>No Datapoints Found</span>
              </div>
            </div>
          </div>
          <div class="col-md-4">
            <div class="card" id="anomalies-container">
              <div class="card-header d-flex justify-content-between align-items-center">
                <h5 class="mb-0">Detected Anomalies</h5>
                <button id="show-all-btn" class="btn btn-sm btn-outline-primary">Show All</button>
              </div>
              <div class="d-flex justify-content-center p-2 bg-light border-bottom">
                <div class="btn-group btn-group-sm" role="group" aria-label="Sort options">
                  <button id="sort-time-btn" class="btn btn-outline-secondary" data-sort-dir="desc">Sort by Time</button>
                  <button id="sort-percent-btn" class="btn btn-outline-secondary active" data-sort-dir="desc">Sort by % Increase</button>
                  <button id="sort-duration-btn" class="btn btn-outline-secondary" data-sort-dir="desc">Sort by Duration</button>
                </div>
              </div>
              <div class="card-body p-0">
                <div id="anomalies-list" class="list-group list-group-flush">
                  <!-- Anomalies will be loaded dynamically -->
                  <div class="list-group-item text-center py-4 text-muted" id="no-anomalies-message">
                    No anomalies detected in the selected time period
                  </div>
                </div>
              </div>
            </div>
          </div>
        </div>
        
        <!-- Anomaly Details Section -->
        <div id="anomaly-details" class="mt-4" style="display: none;">
          <h4>Anomaly Details</h4>
          <div class="row">
            <div class="col-md-6">
              <div class="card">
                <div class="card-header">
                  <h5 class="mb-0" id="anomaly-title">Range Anomaly</h5>
                </div>
                <div class="card-body">
                  <table class="table">
                    <tbody id="anomaly-details-table">
                      <!-- Details will be loaded dynamically -->
                    </tbody>
                  </table>
                </div>
              </div>
            </div>
            <div class="col-md-6">
              <div class="card">
                <div class="card-header">
                  <h5 class="mb-0">Time Series</h5>
                </div>
                <div class="card-body">
                  <div class="chart-container">
                    <canvas id="anomaly-chart"></canvas>
                  </div>
                </div>
              </div>
            </div>
          </div>
        </div>
      </div>
    </div>
  </div>
<script>
    // Initialize map
    const map = L.map('anomaly-map').setView([51.505, -0.09], 6);
    
    // Add base map layer
    L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
      attribution: '&copy; <a href="https://www.openstreetmap.org/copyright">OpenStreetMap</a> contributors'
    }).addTo(map);
    
    // Global variables
    let currentAnomalies = [];
    let selectedAnomaly = null;
    let anomalyChart = null;
    let receiversData = []; // Store receivers data globally
    
    // Show map loading overlay
    function showMapLoading() {
      document.getElementById('mapLoadingOverlay').style.display = 'flex';
    }
    
    // Hide map loading overlay
    function hideMapLoading() {
      document.getElementById('mapLoadingOverlay').style.display = 'none';
    }
    
    // Show no data overlay
    function showNoDataOverlay() {
      document.getElementById('noDataOverlay').style.display = 'flex';
    }
    
    // Hide no data overlay
    function hideNoDataOverlay() {
      document.getElementById('noDataOverlay').style.display = 'none';
    }
    
    // Load receivers
    async function loadReceivers() {
      try {
        // Fetch receivers data once and store it globally
        receiversData = await fetch('/receivers').then(r => r.json());
        const select = document.getElementById('receiver-select');
        
        // Sort receivers by name
        receiversData.sort((a, b) => a.name.localeCompare(b.name));
        
        // Add receivers to dropdown (excluding receiver ID 0)
        receiversData.forEach(receiver => {
          // Skip receiver ID 0
          if (receiver.id === 0) return;
          
          const option = document.createElement('option');
          option.value = receiver.id;
          option.textContent = receiver.name;
          select.appendChild(option);
        });
      } catch (e) {
        console.error('Failed to load receivers:', e);
        alert('Failed to load receivers. Please try again later.');
      }
    }
    
    // Format date for API
    function formatDateForAPI(date) {
      return date.toISOString();
    }
    
    // Load range anomalies
    async function loadRangeAnomalies() {
      showMapLoading();
      
      const receiverId = document.getElementById('receiver-select').value;
      const isDateRange = document.getElementById('dateRangeRadio').checked;
      
      try {
        // Build URL
        let url = `/statistics/stats/vhf-range-anomalies`;
        
        if (isDateRange) {
          const fromDate = document.getElementById('from-date').value;
          const toDate = document.getElementById('to-date').value;
          
          if (!fromDate || !toDate) {
            hideMapLoading();
            document.getElementById('date-range-error').textContent = 'Please select both from and to dates';
            document.getElementById('date-range-error').style.display = 'block';
            return;
          }
          
          try {
            const fromDateObj = new Date(fromDate);
            const toDateObj = new Date(toDate);
            
            if (fromDateObj >= toDateObj) {
              hideMapLoading();
              document.getElementById('date-range-error').textContent = 'From date must be before to date';
              document.getElementById('date-range-error').style.display = 'block';
              return;
            }
            
            // Check if range exceeds 30 days
            const maxDuration = 30 * 24 * 60 * 60 * 1000; // 30 days in milliseconds
            if (toDateObj - fromDateObj > maxDuration) {
              hideMapLoading();
              document.getElementById('date-range-error').textContent = 'Date range cannot exceed 30 days';
              document.getElementById('date-range-error').style.display = 'block';
              return;
            }
            
            url += `?from=${formatDateForAPI(fromDateObj)}&to=${formatDateForAPI(toDateObj)}`;
            document.getElementById('date-range-error').style.display = 'none';
          } catch (e) {
            hideMapLoading();
            document.getElementById('date-range-error').textContent = 'Invalid date format';
            document.getElementById('date-range-error').style.display = 'block';
            return;
          }
        } else {
          const days = document.getElementById('days-select').value;
          url += `?days=${days}`;
        }
        
        if (receiverId) {
          url += `&receiver_id=${receiverId}`;
        }
        
        // Fetch data
        const anomalies = await fetch(url).then(r => r.json());
        
        // Use the globally stored receivers data
        // Add receiver names to anomalies
        anomalies.forEach(anomaly => {
          const receiver = receiversData.find(r => r.id === anomaly.receiver_id);
          if (receiver) {
            anomaly.receiver_name = receiver.name;
          }
        });
        
        // Sort anomalies by percent_increase in descending order (highest first)
        anomalies.sort((a, b) => b.percent_increase - a.percent_increase);
        
        currentAnomalies = anomalies;
        
        // Clear map
        clearMap();
        
        // Hide no data overlay initially
        hideNoDataOverlay();
        
        // Update anomalies list - this will auto-select the first anomaly and focus the map on it
        updateAnomaliesList(anomalies, 'range');
        
        // Show no data overlay if no anomalies
        if (anomalies.length === 0) {
          showNoDataOverlay();
        }
      } catch (e) {
        console.error('Failed to load range anomalies:', e);
        alert('Failed to load range anomalies. Please try again later.');
      } finally {
        hideMapLoading();
      }
    }
    
    // Load direction anomalies
    async function loadDirectionAnomalies() {
      showMapLoading();
      
      const receiverId = document.getElementById('receiver-select').value;
      const isDateRange = document.getElementById('dateRangeRadio').checked;
      
      try {
        // Build URL
        let url = `/statistics/stats/vhf-direction-anomalies`;
        
        if (isDateRange) {
          const fromDate = document.getElementById('from-date').value;
          const toDate = document.getElementById('to-date').value;
          
          if (!fromDate || !toDate) {
            hideMapLoading();
            document.getElementById('date-range-error').textContent = 'Please select both from and to dates';
            document.getElementById('date-range-error').style.display = 'block';
            return;
          }
          
          try {
            const fromDateObj = new Date(fromDate);
            const toDateObj = new Date(toDate);
            
            if (fromDateObj >= toDateObj) {
              hideMapLoading();
              document.getElementById('date-range-error').textContent = 'From date must be before to date';
              document.getElementById('date-range-error').style.display = 'block';
              return;
            }
            
            // Check if range exceeds 30 days
            const maxDuration = 30 * 24 * 60 * 60 * 1000; // 30 days in milliseconds
            if (toDateObj - fromDateObj > maxDuration) {
              hideMapLoading();
              document.getElementById('date-range-error').textContent = 'Date range cannot exceed 30 days';
              document.getElementById('date-range-error').style.display = 'block';
              return;
            }
            
            url += `?from=${formatDateForAPI(fromDateObj)}&to=${formatDateForAPI(toDateObj)}`;
            document.getElementById('date-range-error').style.display = 'none';
          } catch (e) {
            hideMapLoading();
            document.getElementById('date-range-error').textContent = 'Invalid date format';
            document.getElementById('date-range-error').style.display = 'block';
            return;
          }
        } else {
          const days = document.getElementById('days-select').value;
          url += `?days=${days}`;
        }
        
        if (receiverId) {
          url += `&receiver_id=${receiverId}`;
        }
        
        // Fetch data
        const anomalies = await fetch(url).then(r => r.json());
        
        // Use the globally stored receivers data
        // Add receiver names to anomalies
        anomalies.forEach(anomaly => {
          const receiver = receiversData.find(r => r.id === anomaly.receiver_id);
          if (receiver) {
            anomaly.receiver_name = receiver.name;
          }
        });
        
        // Sort anomalies by percent_increase in descending order (highest first)
        anomalies.sort((a, b) => b.percent_increase - a.percent_increase);
        
        currentAnomalies = anomalies;
        
        // Clear map
        clearMap();
        
        // Hide no data overlay initially
        hideNoDataOverlay();
        
        // Update anomalies list - this will auto-select the first anomaly and focus the map on it
        updateAnomaliesList(anomalies, 'direction');
        
        // Show no data overlay if no anomalies
        if (anomalies.length === 0) {
          showNoDataOverlay();
        }
      } catch (e) {
        console.error('Failed to load direction anomalies:', e);
        alert('Failed to load direction anomalies. Please try again later.');
      } finally {
        hideMapLoading();
      }
    }
    
    // Clear map layers
    function clearMap() {
      map.eachLayer(layer => {
        if (layer instanceof L.Marker || layer instanceof L.Circle || layer instanceof L.Polyline) {
          map.removeLayer(layer);
        }
      });
      // Hide no data overlay when clearing the map
      hideNoDataOverlay();
    }
    
    // Update anomalies list
    function updateAnomaliesList(anomalies, type) {
      const listElement = document.getElementById('anomalies-list');
      
      // Clear list
      listElement.innerHTML = '';
      
      if (anomalies.length === 0) {
        // Create a new "no anomalies" message element instead of reusing the existing one
        const noAnomaliesMessage = document.createElement('div');
        noAnomaliesMessage.className = 'list-group-item text-center py-4 text-muted';
        noAnomaliesMessage.id = 'no-anomalies-message';
        noAnomaliesMessage.textContent = 'No anomalies detected in the selected time period';
        
        listElement.appendChild(noAnomaliesMessage);
        
        // Hide details section
        document.getElementById('anomaly-details').style.display = 'none';
        return;
      }
      
      // Track the first item to auto-select it
      let firstItem = null;
      
      // Add anomalies to list
      anomalies.forEach((anomaly, index) => {
        const item = document.createElement('div');
        item.className = 'list-group-item anomaly-card';
        item.dataset.index = index;
        
        let content = '';
        if (type === 'range') {
          const receiverName = anomaly.receiver_name || `Receiver #${anomaly.receiver_id}`;
          const startTime = new Date(anomaly.start_time).toLocaleString();
          const endTime = new Date(anomaly.end_time).toLocaleString();
          const percentIncrease = anomaly.percent_increase.toFixed(1);
          
          content = `
            <h6>${receiverName}</h6>
            <div class="small text-muted">${startTime} - ${endTime}</div>
            <div class="mt-2">
              <span class="badge bg-primary">${anomaly.normal_range_km.toFixed(1)} km → ${anomaly.anomaly_range_km.toFixed(1)} km</span>
              <span class="badge bg-success">+${percentIncrease}%</span>
            </div>
          `;
        } else {
          const receiverName = anomaly.receiver_name || `Receiver #${anomaly.receiver_id}`;
          const startTime = new Date(anomaly.start_time).toLocaleString();
          const endTime = new Date(anomaly.end_time).toLocaleString();
          const percentIncrease = anomaly.percent_increase.toFixed(1);
          
          content = `
            <h6>${receiverName}</h6>
            <div class="small text-muted">${startTime} - ${endTime}</div>
            <div class="mt-2">
              <span class="badge bg-primary">Direction: ${anomaly.direction}</span>
              <span class="badge bg-success">+${percentIncrease}%</span>
            </div>
          `;
        }
        
        item.innerHTML = content;
        
        // Add click event
        item.addEventListener('click', () => {
          // Remove selected class from all items
          document.querySelectorAll('.anomaly-card').forEach(card => {
            card.classList.remove('selected');
          });
          
          // Add selected class to clicked item
          item.classList.add('selected');
          
          // Show details
          showAnomalyDetails(anomaly, type);
          
          // Focus map on this anomaly
          focusMapOnAnomaly(anomaly, type);
        });
        
        listElement.appendChild(item);
        
        // Store the first item for auto-selection
        if (firstItem === null) {
          firstItem = item;
        }
      });
      
      // Auto-select the first item if any anomalies exist
      if (firstItem !== null) {
        firstItem.classList.add('selected');
        const anomaly = anomalies[parseInt(firstItem.dataset.index)];
        showAnomalyDetails(anomaly, type);
        // Also focus the map on the first anomaly
        focusMapOnAnomaly(anomaly, type);
      }
    }
    
    // Add range anomalies to map
    function addRangeAnomaliesToMap(anomalies) {
      // Fetch receivers to get locations
      fetch('/receivers').then(r => r.json()).then(receivers => {
        anomalies.forEach(anomaly => {
          const receiver = receivers.find(r => r.id === anomaly.receiver_id);
          if (!receiver || !receiver.latitude || !receiver.longitude) return;
          
          // Add receiver marker
          const receiverMarker = L.marker([receiver.latitude, receiver.longitude], {
            icon: L.divIcon({
              html: '<div style="background-color: #ff4136; width: 12px; height: 12px; border-radius: 50%; border: 2px solid white;"></div>',
              className: 'receiver-marker',
              iconSize: [12, 12]
            })
          }).addTo(map);
          
          receiverMarker.bindPopup(`<b>Receiver:</b> ${receiver.name || `#${receiver.id}`}`);
          
          // Add normal range circle
          const normalRangeCircle = L.circle([receiver.latitude, receiver.longitude], {
            radius: anomaly.normal_range_km * 1000,
            color: '#3388ff',
            fillColor: '#3388ff',
            fillOpacity: 0.1,
            weight: 1,
            dashArray: '5, 5'
          }).addTo(map);
          
          // Add anomaly range circle
          const anomalyRangeCircle = L.circle([receiver.latitude, receiver.longitude], {
            radius: anomaly.anomaly_range_km * 1000,
            color: '#ff4136',
            fillColor: '#ff4136',
            fillOpacity: 0.1,
            weight: 2
          }).addTo(map);
          
          // Add line to max point
          if (anomaly.max_lat && anomaly.max_lon) {
            const line = L.polyline([
              [receiver.latitude, receiver.longitude],
              [anomaly.max_lat, anomaly.max_lon]
            ], {
              color: '#ff4136',
              weight: 2,
              dashArray: '5, 5'
            }).addTo(map);
            
            // Add max point marker
            const maxMarker = L.marker([anomaly.max_lat, anomaly.max_lon], {
              icon: L.divIcon({
                html: '<div style="background-color: #ff4136; width: 8px; height: 8px; border-radius: 50%; border: 2px solid white;"></div>',
                className: 'max-point-marker',
                iconSize: [8, 8]
              })
            }).addTo(map);
            
            if (anomaly.max_vessel_name) {
              // Create a link to vesselhistory.html with relevant parameters
              const vesselLink = `<a href="/vesselhistory.html?UserID=${anomaly.max_user_id || ''}&start=${anomaly.start_time}&end=${anomaly.end_time}&ReceiverID=${anomaly.receiver_id}" target="_blank">${anomaly.max_vessel_name}</a>`;
              maxMarker.bindPopup(`<b>Vessel:</b> ${vesselLink}`);
            }
          }
        });
      });
    }
    
    // Add direction anomalies to map
    function addDirectionAnomaliesToMap(anomalies) {
      // Fetch receivers to get locations
      fetch('/receivers').then(r => r.json()).then(receivers => {
        anomalies.forEach(anomaly => {
          const receiver = receivers.find(r => r.id === anomaly.receiver_id);
          if (!receiver || !receiver.latitude || !receiver.longitude) return;
          
          // Add receiver marker
          const receiverMarker = L.marker([receiver.latitude, receiver.longitude], {
            icon: L.divIcon({
              html: '<div style="background-color: #ff4136; width: 12px; height: 12px; border-radius: 50%; border: 2px solid white;"></div>',
              className: 'receiver-marker',
              iconSize: [12, 12]
            })
          }).addTo(map);
          
          receiverMarker.bindPopup(`<b>Receiver:</b> ${receiver.name || `#${receiver.id}`}`);
          
          // Add direction arrow
          const directionDegrees = getDirectionDegrees(anomaly.direction);
          const arrowLength = anomaly.max_distance_meters / 1000; // km
          
          // Calculate end point
          const endPoint = getPointInDirection(
            receiver.latitude, 
            receiver.longitude, 
            directionDegrees, 
            arrowLength
          );
          
          // Draw arrow
          const arrow = L.polyline([
            [receiver.latitude, receiver.longitude],
            endPoint
          ], {
            color: '#ff4136',
            weight: 3
          }).addTo(map);
          
          // Add arrowhead
          const arrowHead = L.polyline([
            getPointInDirection(endPoint[0], endPoint[1], directionDegrees - 150, arrowLength * 0.05),
            endPoint,
            getPointInDirection(endPoint[0], endPoint[1], directionDegrees + 150, arrowLength * 0.05)
          ], {
            color: '#ff4136',
            weight: 3
          }).addTo(map);
        });
      });
    }
    
    // Get bounds from anomalies
    function getBoundsFromAnomalies(anomalies) {
      const bounds = L.latLngBounds();
      
      // Fetch receivers to get locations
      return fetch('/receivers').then(r => r.json()).then(receivers => {
        anomalies.forEach(anomaly => {
          const receiver = receivers.find(r => r.id === anomaly.receiver_id);
          if (receiver && receiver.latitude && receiver.longitude) {
            bounds.extend([receiver.latitude, receiver.longitude]);
            
            // If it's a range anomaly with max point
            if (anomaly.max_lat && anomaly.max_lon) {
              bounds.extend([anomaly.max_lat, anomaly.max_lon]);
            }
            
            // Add buffer for anomaly range
            if (anomaly.anomaly_range_km) {
              // Extend bounds in all directions
              const directions = [0, 90, 180, 270];
              directions.forEach(dir => {
                const point = getPointInDirection(
                  receiver.latitude, 
                  receiver.longitude, 
                  dir, 
                  anomaly.anomaly_range_km
                );
                bounds.extend(point);
              });
            }
          }
        });
        
        return bounds;
      });
    }
    
    // Focus map on a specific anomaly
    function focusMapOnAnomaly(anomaly, type) {
      // Clear the map first
      clearMap();
      
      // Show only this anomaly on the map
      if (type === 'range') {
        // Fetch receivers to get location
        fetch('/receivers').then(r => r.json()).then(receivers => {
          const receiver = receivers.find(r => r.id === anomaly.receiver_id);
          if (!receiver || !receiver.latitude || !receiver.longitude) return;
          
          // Add receiver marker
          const receiverMarker = L.marker([receiver.latitude, receiver.longitude], {
            icon: L.divIcon({
              html: '<div style="background-color: #ff4136; width: 12px; height: 12px; border-radius: 50%; border: 2px solid white;"></div>',
              className: 'receiver-marker',
              iconSize: [12, 12]
            })
          }).addTo(map);
          
          receiverMarker.bindPopup(`<b>Receiver:</b> ${receiver.name || `#${receiver.id}`}`);
          
          // Add normal range circle
          const normalRangeCircle = L.circle([receiver.latitude, receiver.longitude], {
            radius: anomaly.normal_range_km * 1000,
            color: '#3388ff',
            fillColor: '#3388ff',
            fillOpacity: 0.1,
            weight: 1,
            dashArray: '5, 5'
          }).addTo(map);
          
          // Add anomaly range circle
          const anomalyRangeCircle = L.circle([receiver.latitude, receiver.longitude], {
            radius: anomaly.anomaly_range_km * 1000,
            color: '#ff4136',
            fillColor: '#ff4136',
            fillOpacity: 0.1,
            weight: 2
          }).addTo(map);
          
          // Add line to max point
          if (anomaly.max_lat && anomaly.max_lon) {
            const line = L.polyline([
              [receiver.latitude, receiver.longitude],
              [anomaly.max_lat, anomaly.max_lon]
            ], {
              color: '#ff4136',
              weight: 2,
              dashArray: '5, 5'
            }).addTo(map);
            
            // Add max point marker
            const maxMarker = L.marker([anomaly.max_lat, anomaly.max_lon], {
              icon: L.divIcon({
                html: '<div style="background-color: #ff4136; width: 8px; height: 8px; border-radius: 50%; border: 2px solid white;"></div>',
                className: 'max-point-marker',
                iconSize: [8, 8]
              })
            }).addTo(map);
            
            if (anomaly.max_vessel_name) {
              maxMarker.bindPopup(`<b>Vessel:</b> ${anomaly.max_vessel_name}`);
            }
          }
          
          // Fit map to this anomaly
          const bounds = L.latLngBounds();
          bounds.extend([receiver.latitude, receiver.longitude]);
          
          if (anomaly.max_lat && anomaly.max_lon) {
            bounds.extend([anomaly.max_lat, anomaly.max_lon]);
          } else {
            // If no max point, extend bounds based on anomaly range
            const directions = [0, 90, 180, 270];
            directions.forEach(dir => {
              const point = getPointInDirection(
                receiver.latitude,
                receiver.longitude,
                dir,
                anomaly.anomaly_range_km
              );
              bounds.extend(point);
            });
          }
          
          if (bounds.isValid()) {
            map.fitBounds(bounds, { padding: [50, 50] });
          }
        });
      } else {
        // Direction anomaly
        fetch('/receivers').then(r => r.json()).then(receivers => {
          const receiver = receivers.find(r => r.id === anomaly.receiver_id);
          if (!receiver || !receiver.latitude || !receiver.longitude) return;
          
          // Add receiver marker
          const receiverMarker = L.marker([receiver.latitude, receiver.longitude], {
            icon: L.divIcon({
              html: '<div style="background-color: #ff4136; width: 12px; height: 12px; border-radius: 50%; border: 2px solid white;"></div>',
              className: 'receiver-marker',
              iconSize: [12, 12]
            })
          }).addTo(map);
          
          receiverMarker.bindPopup(`<b>Receiver:</b> ${receiver.name || `#${receiver.id}`}`);
          
          // Add direction arrow
          const directionDegrees = getDirectionDegrees(anomaly.direction);
          const arrowLength = anomaly.max_distance_meters / 1000; // km
          
          // Calculate end point
          const endPoint = getPointInDirection(
            receiver.latitude,
            receiver.longitude,
            directionDegrees,
            arrowLength
          );
          
          // Draw arrow
          const arrow = L.polyline([
            [receiver.latitude, receiver.longitude],
            endPoint
          ], {
            color: '#ff4136',
            weight: 3
          }).addTo(map);
          
          // Add arrowhead
          const arrowHead = L.polyline([
            getPointInDirection(endPoint[0], endPoint[1], directionDegrees - 150, arrowLength * 0.05),
            endPoint,
            getPointInDirection(endPoint[0], endPoint[1], directionDegrees + 150, arrowLength * 0.05)
          ], {
            color: '#ff4136',
            weight: 3
          }).addTo(map);
          
          // Fit map to this anomaly
          const bounds = L.latLngBounds();
          bounds.extend([receiver.latitude, receiver.longitude]);
          bounds.extend(endPoint);
          
          if (bounds.isValid()) {
            map.fitBounds(bounds, { padding: [50, 50] });
          }
        });
      }
    }
    
    // Show anomaly details
    function showAnomalyDetails(anomaly, type) {
      const detailsSection = document.getElementById('anomaly-details');
      const detailsTable = document.getElementById('anomaly-details-table');
      const title = document.getElementById('anomaly-title');
      
      // Show details section
      detailsSection.style.display = 'block';
      
      // Set title
      if (type === 'range') {
        title.textContent = 'Range Anomaly Details';
      } else {
        title.textContent = 'Directional Anomaly Details';
      }
      
      // Clear table
      detailsTable.innerHTML = '';
      
      // Fetch receivers to get coordinates for the timemachine link
      fetch('/receivers').then(r => r.json()).then(receivers => {
        const receiver = receivers.find(r => r.id === anomaly.receiver_id);
        
        // Add details to table
        if (type === 'range') {
          const receiverName = anomaly.receiver_name || `Receiver #${anomaly.receiver_id}`;
          const startTime = new Date(anomaly.start_time).toLocaleString();
          const endTime = new Date(anomaly.end_time).toLocaleString();
          const duration = getTimeDuration(anomaly.start_time, anomaly.end_time);
          
          // Create timemachine link with appropriate parameters
          let timemachineLink = receiverName;
          if (receiver && receiver.latitude && receiver.longitude) {
            // Format dates for URL parameters (ISO format)
            const fromDate = new Date(anomaly.start_time).toISOString().slice(0, 16);
            const toDate = new Date(anomaly.end_time).toISOString().slice(0, 16);
            
            timemachineLink = `<a href="/timemachine.html?minSpeed=0&lat=${receiver.latitude}&lng=${receiver.longitude}&zoom=9&from=${fromDate}&to=${toDate}&receiver=${anomaly.receiver_id}" target="_blank">${receiverName}</a>`;
          }
          
          detailsTable.innerHTML = `
            <tr>
              <th>Receiver</th>
              <td>${timemachineLink}</td>
            </tr>
            <tr>
              <th>Start Time</th>
              <td>${startTime}</td>
            </tr>
            <tr>
              <th>End Time</th>
              <td>${endTime}</td>
            </tr>
            <tr>
              <th>Duration</th>
              <td>${duration}</td>
            </tr>
            <tr>
              <th>Normal Range</th>
              <td>${anomaly.normal_range_km.toFixed(1)} km</td>
            </tr>
            <tr>
              <th>Anomaly Range</th>
              <td>${anomaly.anomaly_range_km.toFixed(1)} km</td>
            </tr>
            <tr>
              <th>Increase</th>
              <td>${anomaly.percent_increase.toFixed(1)}%</td>
            </tr>
          `;
        
        // The max vessel section is now handled in the main HTML generation below
        if (anomaly.max_vessel_name) {
          // Create a link to vesselhistory.html with relevant parameters
          const vesselLink = `<a href="/vesselhistory.html?UserID=${anomaly.max_user_id || ''}&start=${anomaly.start_time}&end=${anomaly.end_time}&ReceiverID=${anomaly.receiver_id}" target="_blank">${anomaly.max_vessel_name}</a>`;
          detailsTable.innerHTML += `
            <tr>
              <th>Max Vessel</th>
              <td>${vesselLink}</td>
            </tr>
          `;
        }
      } else {
        const receiverName = anomaly.receiver_name || `Receiver #${anomaly.receiver_id}`;
        const startTime = new Date(anomaly.start_time).toLocaleString();
        const endTime = new Date(anomaly.end_time).toLocaleString();
        const duration = getTimeDuration(anomaly.start_time, anomaly.end_time);
        
        // Create timemachine link with appropriate parameters
        let timemachineLink = receiverName;
        if (receiver && receiver.latitude && receiver.longitude) {
          // Format dates for URL parameters (ISO format)
          const fromDate = new Date(anomaly.start_time).toISOString().slice(0, 16);
          const toDate = new Date(anomaly.end_time).toISOString().slice(0, 16);
          
          timemachineLink = `<a href="/timemachine.html?minSpeed=0&lat=${receiver.latitude}&lng=${receiver.longitude}&zoom=9&from=${fromDate}&to=${toDate}&receiver=${anomaly.receiver_id}" target="_blank">${receiverName}</a>`;
        }
        
        detailsTable.innerHTML = `
          <tr>
            <th>Receiver</th>
            <td>${timemachineLink}</td>
          </tr>
          <tr>
            <th>Direction</th>
            <td>${anomaly.direction}</td>
          </tr>
          <tr>
            <th>Start Time</th>
            <td>${startTime}</td>
          </tr>
          <tr>
            <th>End Time</th>
            <td>${endTime}</td>
          </tr>
          <tr>
            <th>Duration</th>
            <td>${duration}</td>
          </tr>
          <tr>
            <th>Normal Count</th>
            <td>${anomaly.normal_count}</td>
          </tr>
          <tr>
            <th>Anomaly Count</th>
            <td>${anomaly.anomaly_count}</td>
          </tr>
          <tr>
            <th>Increase</th>
            <td>${anomaly.percent_increase.toFixed(1)}%</td>
          </tr>
          <tr>
            <th>Max Distance</th>
            <td>${(anomaly.max_distance_meters / 1000).toFixed(1)} km</td>
          </tr>
        `;
      }
      
      // Create chart
      createAnomalyChart(anomaly, type);
      });
    }
    
    // Create anomaly chart
    function createAnomalyChart(anomaly, type) {
      const ctx = document.getElementById('anomaly-chart').getContext('2d');
      
      // Destroy existing chart if it exists
      if (anomalyChart) {
        anomalyChart.destroy();
      }
      
      // Create dummy data for now (in a real implementation, we would fetch time series data)
      const startTime = new Date(anomaly.start_time);
      const endTime = new Date(anomaly.end_time);
      const hours = Math.ceil((endTime - startTime) / (1000 * 60 * 60));
      
      const labels = [];
      const data = [];
      const threshold = [];
      
      // Generate data points for each hour
      for (let i = 0; i <= hours; i++) {
        const time = new Date(startTime);
        time.setHours(time.getHours() + i);
        labels.push(time.toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' }));
        
        if (type === 'range') {
          // For range anomalies, show a curve that peaks at the anomaly range
          const normalRange = anomaly.normal_range_km;
          const anomalyRange = anomaly.anomaly_range_km;
          const diff = anomalyRange - normalRange;
          
          // Create a bell curve
          const position = i / hours;
          const bellValue = Math.exp(-Math.pow((position - 0.5) * 4, 2));
          const value = normalRange + diff * bellValue;
          
          data.push(value);
          threshold.push(normalRange * 1.2); // 20% threshold
        } else {
          // For direction anomalies, show a curve that peaks at the anomaly count
          const normalCount = anomaly.normal_count;
          const anomalyCount = anomaly.anomaly_count;
          const diff = anomalyCount - normalCount;
          
          // Create a bell curve
          const position = i / hours;
          const bellValue = Math.exp(-Math.pow((position - 0.5) * 4, 2));
          const value = normalCount + diff * bellValue;
          
          data.push(value);
          threshold.push(normalCount * 1.5); // 50% threshold
        }
      }
      
      // Create chart
      anomalyChart = new Chart(ctx, {
        type: 'line',
        data: {
          labels: labels,
          datasets: [
            {
              label: type === 'range' ? 'Range (km)' : 'Message Count',
              data: data,
              borderColor: '#ff4136',
              backgroundColor: 'rgba(255, 65, 54, 0.1)',
              fill: true,
              tension: 0.4
            },
            {
              label: 'Threshold',
              data: threshold,
              borderColor: '#0074d9',
              borderDash: [5, 5],
              fill: false,
              pointRadius: 0
            }
          ]
        },
        options: {
          responsive: true,
          maintainAspectRatio: false,
          plugins: {
            legend: {
              position: 'top',
            },
            tooltip: {
              mode: 'index',
              intersect: false
            }
          },
          scales: {
            y: {
              beginAtZero: true,
              title: {
                display: true,
                text: type === 'range' ? 'Range (km)' : 'Message Count'
              }
            },
            x: {
              title: {
                display: true,
                text: 'Time'
              }
            }
          }
        }
      });
    }
    
    // Get time duration in human-readable format
    function getTimeDuration(startTime, endTime) {
      const start = new Date(startTime);
      const end = new Date(endTime);
      const diffMs = end - start;
      
      const hours = Math.floor(diffMs / (1000 * 60 * 60));
      const minutes = Math.floor((diffMs % (1000 * 60 * 60)) / (1000 * 60));
      
      if (hours === 0) {
        return `${minutes} minutes`;
      } else if (minutes === 0) {
        return `${hours} hours`;
      } else {
        return `${hours} hours, ${minutes} minutes`;
      }
    }
    
    // Get direction in degrees from cardinal direction
    function getDirectionDegrees(direction) {
      const directionMap = {
        'N': 0,
        'NE': 45,
        'E': 90,
        'SE': 135,
        'S': 180,
        'SW': 225,
        'W': 270,
        'NW': 315
      };
      
      return directionMap[direction] || 0;
    }
    
    // Get point in direction at distance
    function getPointInDirection(lat, lon, bearing, distanceKm) {
      // Earth's radius in km
      const R = 6371;
      
      // Convert to radians
      const lat1 = lat * Math.PI / 180;
      const lon1 = lon * Math.PI / 180;
      const brng = bearing * Math.PI / 180;
      
      // Calculate new point
      const lat2 = Math.asin(
        Math.sin(lat1) * Math.cos(distanceKm / R) +
        Math.cos(lat1) * Math.sin(distanceKm / R) * Math.cos(brng)
      );
      
      const lon2 = lon1 + Math.atan2(
        Math.sin(brng) * Math.sin(distanceKm / R) * Math.cos(lat1),
        Math.cos(distanceKm / R) - Math.sin(lat1) * Math.sin(lat2)
      );
      
      // Convert back to degrees
      return [lat2 * 180 / Math.PI, lon2 * 180 / Math.PI];
    }
    
    // Copy current URL to clipboard
    function copyLinkToClipboard() {
      const url = window.location.href;
      navigator.clipboard.writeText(url).then(() => {
        const btn = document.getElementById('copy-link-btn');
        const originalText = btn.innerHTML;
        btn.innerHTML = 'Copied!';
        setTimeout(() => {
          btn.innerHTML = originalText;
        }, 2000);
      }).catch(err => {
        console.error('Failed to copy URL: ', err);
        alert('Failed to copy URL to clipboard');
      });
    }
    
    // Update the coverage link with the current receiver ID and time range
    function updateCoverageLink() {
      const receiverId = document.getElementById('receiver-select').value;
      const isDateRange = document.getElementById('dateRangeRadio').checked;
      const coverageLink = document.getElementById('coverage-link');
      
      if (coverageLink) {
        const coverageUrl = new URL(coverageLink.href);
        
        // Set receiver ID if selected
        if (receiverId) {
          coverageUrl.searchParams.set('receiver_id', receiverId);
        } else {
          coverageUrl.searchParams.delete('receiver_id');
        }
        
        if (isDateRange) {
          const fromDate = document.getElementById('from-date').value;
          const toDate = document.getElementById('to-date').value;
          
          if (fromDate && toDate) {
            try {
              const fromDateObj = new Date(fromDate);
              const toDateObj = new Date(toDate);
              
              coverageUrl.searchParams.set('from', formatDateForAPI(fromDateObj));
              coverageUrl.searchParams.set('to', formatDateForAPI(toDateObj));
              coverageUrl.searchParams.delete('days');
            } catch (e) {
              console.error('Error formatting dates for coverage URL:', e);
            }
          }
        } else {
          const days = document.getElementById('days-select').value;
          
          if (days) {
            coverageUrl.searchParams.set('days', days);
          } else {
            coverageUrl.searchParams.delete('days');
          }
          
          coverageUrl.searchParams.delete('from');
          coverageUrl.searchParams.delete('to');
        }
        
        coverageLink.href = coverageUrl.toString();
      }
    }
    
    // Update URL with current parameters
    function updateUrlParameters() {
      const receiverId = document.getElementById('receiver-select').value;
      const isDateRange = document.getElementById('dateRangeRadio').checked;
      const anomalyType = document.getElementById('anomaly-type').value;
      
      // Create URL object from current URL
      const url = new URL(window.location.href);
      
      // Update or add parameters
      if (receiverId) {
        url.searchParams.set('receiver_id', receiverId);
      } else {
        url.searchParams.delete('receiver_id');
      }
      
      if (isDateRange) {
        const fromDate = document.getElementById('from-date').value;
        const toDate = document.getElementById('to-date').value;
        
        if (fromDate && toDate) {
          try {
            const fromDateObj = new Date(fromDate);
            const toDateObj = new Date(toDate);
            
            url.searchParams.set('from', formatDateForAPI(fromDateObj));
            url.searchParams.set('to', formatDateForAPI(toDateObj));
            url.searchParams.delete('days');
          } catch (e) {
            console.error('Error formatting dates for URL:', e);
          }
        }
      } else {
        const days = document.getElementById('days-select').value;
        
        if (days) {
          url.searchParams.set('days', days);
        } else {
          url.searchParams.delete('days');
        }
        
        url.searchParams.delete('from');
        url.searchParams.delete('to');
      }
      
      url.searchParams.set('type', anomalyType);
      
      // Update URL without reloading the page
      window.history.pushState({}, '', url);
      
      // Update the coverage link
      updateCoverageLink();
    }
    
    // Parse URL parameters
    function parseUrlParameters() {
      const urlParams = new URLSearchParams(window.location.search);
      
      // Get parameters
      const receiverId = urlParams.get('receiver_id');
      const days = urlParams.get('days');
      const from = urlParams.get('from');
      const to = urlParams.get('to');
      const anomalyType = urlParams.get('type');
      
      // Set dropdown values if parameters exist
      if (receiverId) {
        const receiverSelect = document.getElementById('receiver-select');
        // We'll set this after receivers are loaded
        receiverSelect.dataset.preselect = receiverId;
      }
      
      // Set time range type based on parameters
      if (from && to) {
        document.getElementById('dateRangeRadio').checked = true;
        document.getElementById('fixedWindowRadio').checked = false;
        document.getElementById('fixedWindowContainer').style.display = 'none';
        document.getElementById('dateRangeContainer').style.display = 'block';
        
        try {
          // Format dates for datetime-local input
          const fromDate = new Date(from);
          const toDate = new Date(to);
          
          document.getElementById('from-date').value = fromDate.toISOString().slice(0, 16);
          document.getElementById('to-date').value = toDate.toISOString().slice(0, 16);
        } catch (e) {
          console.error('Error parsing dates from URL:', e);
        }
      } else if (days) {
        document.getElementById('fixedWindowRadio').checked = true;
        document.getElementById('dateRangeRadio').checked = false;
        document.getElementById('fixedWindowContainer').style.display = 'block';
        document.getElementById('dateRangeContainer').style.display = 'none';
        
        const daysSelect = document.getElementById('days-select');
        // Check if the value exists in the options
        for (let i = 0; i < daysSelect.options.length; i++) {
          if (daysSelect.options[i].value === days) {
            daysSelect.selectedIndex = i;
            break;
          }
        }
      }
      
      if (anomalyType) {
        const anomalyTypeSelect = document.getElementById('anomaly-type');
        // Check if the value exists in the options
        for (let i = 0; i < anomalyTypeSelect.options.length; i++) {
          if (anomalyTypeSelect.options[i].value === anomalyType) {
            anomalyTypeSelect.selectedIndex = i;
            break;
          }
        }
      }
    }
    
    // Sort anomalies by time (toggles between most recent first and oldest first)
    function sortAnomaliesByTime() {
      const btn = document.getElementById('sort-time-btn');
      let sortDir = 'desc'; // Default to descending (newest to oldest)
      
      // Only toggle if the button is already active (not first click)
      if (btn.classList.contains('active')) {
        sortDir = btn.dataset.sortDir === 'desc' ? 'asc' : 'desc';
      }
      
      // Update button states
      document.getElementById('sort-time-btn').classList.add('active');
      document.getElementById('sort-percent-btn').classList.remove('active');
      document.getElementById('sort-duration-btn').classList.remove('active');
      
      // Update sort direction
      btn.dataset.sortDir = sortDir;
      
      // Sort anomalies by start_time
      if (sortDir === 'desc') {
        // Descending order (most recent first)
        currentAnomalies.sort((a, b) => new Date(b.start_time) - new Date(a.start_time));
      } else {
        // Ascending order (oldest first)
        currentAnomalies.sort((a, b) => new Date(a.start_time) - new Date(b.start_time));
      }
      
      // Update the list with sorted anomalies
      const anomalyType = document.getElementById('anomaly-type').value;
      updateAnomaliesList(currentAnomalies, anomalyType);
    }
    
    // Sort anomalies by percent increase (toggles between highest first and lowest first)
    function sortAnomaliesByPercent() {
      const btn = document.getElementById('sort-percent-btn');
      let sortDir = 'desc'; // Default to descending (highest to lowest)
      
      // Only toggle if the button is already active (not first click)
      if (btn.classList.contains('active')) {
        sortDir = btn.dataset.sortDir === 'desc' ? 'asc' : 'desc';
      }
      
      // Update button states
      document.getElementById('sort-time-btn').classList.remove('active');
      document.getElementById('sort-percent-btn').classList.add('active');
      document.getElementById('sort-duration-btn').classList.remove('active');
      
      // Update sort direction
      btn.dataset.sortDir = sortDir;
      
      // Sort anomalies by percent_increase
      if (sortDir === 'desc') {
        // Descending order (highest first)
        currentAnomalies.sort((a, b) => b.percent_increase - a.percent_increase);
      } else {
        // Ascending order (lowest first)
        currentAnomalies.sort((a, b) => a.percent_increase - b.percent_increase);
      }
      
      // Update the list with sorted anomalies
      const anomalyType = document.getElementById('anomaly-type').value;
      updateAnomaliesList(currentAnomalies, anomalyType);
    }
    
    // Sort anomalies by duration (toggles between longest first and shortest first)
    function sortAnomaliesByDuration() {
      const btn = document.getElementById('sort-duration-btn');
      let sortDir = 'desc'; // Default to descending (longest to shortest)
      
      // Only toggle if the button is already active (not first click)
      if (btn.classList.contains('active')) {
        sortDir = btn.dataset.sortDir === 'desc' ? 'asc' : 'desc';
      }
      
      // Update button states
      document.getElementById('sort-time-btn').classList.remove('active');
      document.getElementById('sort-percent-btn').classList.remove('active');
      document.getElementById('sort-duration-btn').classList.add('active');
      
      // Update sort direction
      btn.dataset.sortDir = sortDir;
      
      // Sort anomalies by duration
      if (sortDir === 'desc') {
        // Descending order (longest first)
        currentAnomalies.sort((a, b) => {
          const durationA = new Date(a.end_time) - new Date(a.start_time);
          const durationB = new Date(b.end_time) - new Date(b.start_time);
          return durationB - durationA;
        });
      } else {
        // Ascending order (shortest first)
        currentAnomalies.sort((a, b) => {
          const durationA = new Date(a.end_time) - new Date(a.start_time);
          const durationB = new Date(b.end_time) - new Date(b.start_time);
          return durationA - durationB;
        });
      }
      
      // Update the list with sorted anomalies
      const anomalyType = document.getElementById('anomaly-type').value;
      updateAnomaliesList(currentAnomalies, anomalyType);
    }
    
    // Show all anomalies on the map
    function showAllAnomalies() {
      // Clear the map first
      clearMap();
      
      // Get the current anomaly type
      const anomalyType = document.getElementById('anomaly-type').value;
      
      if (currentAnomalies.length === 0) {
        showNoDataOverlay();
        return;
      }
      
      // Hide no data overlay
      hideNoDataOverlay();
      
      // Show all anomalies on the map
      if (anomalyType === 'range') {
        addRangeAnomaliesToMap(currentAnomalies);
        
        // Fit map to bounds
        getBoundsFromAnomalies(currentAnomalies).then(bounds => {
          if (bounds.isValid()) {
            map.fitBounds(bounds, { padding: [50, 50] });
          } else {
            console.warn('Invalid bounds, using default view');
            map.setView([51.505, -0.09], 6);
          }
        }).catch(err => {
          console.error('Error getting bounds:', err);
          map.setView([51.505, -0.09], 6);
        });
      } else {
        addDirectionAnomaliesToMap(currentAnomalies);
        
        // Create bounds from receiver locations using the globally stored data
        const bounds = L.latLngBounds();
        let validBounds = false;
        
        currentAnomalies.forEach(anomaly => {
          const receiver = receiversData.find(r => r.id === anomaly.receiver_id);
            if (receiver && receiver.latitude && receiver.longitude) {
              bounds.extend([receiver.latitude, receiver.longitude]);
              
              // Extend bounds in the direction of the anomaly
              const extendedPoint = getPointInDirection(
                receiver.latitude,
                receiver.longitude,
                getDirectionDegrees(anomaly.direction),
                anomaly.max_distance_meters / 1000
              );
              bounds.extend(extendedPoint);
              validBounds = true;
            }
        });
        
        if (validBounds) {
          map.fitBounds(bounds, { padding: [50, 50] });
        }
      }
    }
    
    // Initialize
    document.addEventListener('DOMContentLoaded', () => {
      // Parse URL parameters first
      parseUrlParameters();
      
      // Add event listeners
      document.getElementById('copy-link-btn').addEventListener('click', copyLinkToClipboard);
      document.getElementById('show-all-btn').addEventListener('click', showAllAnomalies);
      document.getElementById('sort-time-btn').addEventListener('click', sortAnomaliesByTime);
      document.getElementById('sort-percent-btn').addEventListener('click', sortAnomaliesByPercent);
      document.getElementById('sort-duration-btn').addEventListener('click', sortAnomaliesByDuration);
      
      // Add event listeners for time range radio buttons
      document.getElementById('fixedWindowRadio').addEventListener('change', function() {
        if (this.checked) {
          document.getElementById('fixedWindowContainer').style.display = 'block';
          document.getElementById('dateRangeContainer').style.display = 'none';
          document.getElementById('date-range-error').style.display = 'none';
        }
      });
      
      document.getElementById('dateRangeRadio').addEventListener('change', function() {
        if (this.checked) {
          document.getElementById('fixedWindowContainer').style.display = 'none';
          document.getElementById('dateRangeContainer').style.display = 'block';
          
          // Set default dates if not already set
          if (!document.getElementById('from-date').value) {
            const toDate = new Date();
            const fromDate = new Date();
            fromDate.setDate(fromDate.getDate() - 7); // Default to 7 days ago
            
            document.getElementById('to-date').value = toDate.toISOString().slice(0, 16);
            document.getElementById('from-date').value = fromDate.toISOString().slice(0, 16);
          }
        }
      });
      
      // Add event listener for date range go button
      document.getElementById('date-range-go').addEventListener('click', () => {
        const anomalyType = document.getElementById('anomaly-type').value;
        updateUrlParameters();
        if (anomalyType === 'range') {
          loadRangeAnomalies();
        } else {
          loadDirectionAnomalies();
        }
      });
      
      document.getElementById('receiver-select').addEventListener('change', () => {
        const anomalyType = document.getElementById('anomaly-type').value;
        updateUrlParameters();
        if (anomalyType === 'range') {
          loadRangeAnomalies();
        } else {
          loadDirectionAnomalies();
        }
      });
      
      document.getElementById('days-select').addEventListener('change', () => {
        const anomalyType = document.getElementById('anomaly-type').value;
        updateUrlParameters();
        if (anomalyType === 'range') {
          loadRangeAnomalies();
        } else {
          loadDirectionAnomalies();
        }
      });
      
      document.getElementById('anomaly-type').addEventListener('change', (e) => {
        updateUrlParameters();
        if (e.target.value === 'range') {
          loadRangeAnomalies();
        } else {
          loadDirectionAnomalies();
        }
      });
      
      // Load receivers
      loadReceivers().then(() => {
        // Check if we need to preselect a receiver from URL parameters
        const receiverSelect = document.getElementById('receiver-select');
        if (receiverSelect.dataset.preselect) {
          const receiverId = receiverSelect.dataset.preselect;
          for (let i = 0; i < receiverSelect.options.length; i++) {
            if (receiverSelect.options[i].value === receiverId) {
              receiverSelect.selectedIndex = i;
              break;
            }
          }
          // Remove the dataset attribute
          delete receiverSelect.dataset.preselect;
        }
        
        // Update the coverage link with the current receiver ID
        updateCoverageLink();
        
        // Load initial data based on selected parameters
        const anomalyType = document.getElementById('anomaly-type').value;
        if (anomalyType === 'range') {
          loadRangeAnomalies();
        } else {
          loadDirectionAnomalies();
        }
      });
    });
  </script>
</body>
</html>