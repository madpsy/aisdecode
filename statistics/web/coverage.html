<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Coverage Map</title>
  
  <!-- Bootstrap 5 CSS -->
  <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/css/bootstrap.min.css" rel="stylesheet">
  <!-- Leaflet CSS -->
  <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" integrity="sha256-p4NxAoJBhIIN+hmNHrzRCf9tD/miZyoHS5obTRR9BMY=" crossorigin=""/>
  <!-- Leaflet Heat plugin -->
  <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js" integrity="sha256-20nQCchB9co0qIjJZRGuk2/Z9VM+kNiyxNV1lvTlZBo=" crossorigin=""></script>
  <script src="https://unpkg.com/leaflet.heat@0.2.0/dist/leaflet-heat.js"></script>
  
  <style>
    body {
      background-color: #f8f9fa;
      padding: 2rem;
      font-family: sans-serif;
    }
    h1 {
      color: #343a40;
      margin-bottom: 1.5rem;
    }
    .card {
      box-shadow: 0 2px 6px rgba(0,0,0,0.1);
      margin-bottom: 2rem;
    }
    #coverage-map {
      height: 600px;
      width: 100%;
      border-radius: 5px;
    }
    .controls {
      margin-bottom: 1rem;
    }
    .receiver-tooltip {
      background-color: rgba(255, 255, 255, 0.9);
      border: none;
      box-shadow: 0 1px 3px rgba(0,0,0,0.3);
      padding: 3px 8px;
      border-radius: 4px;
      font-size: 12px;
      font-weight: bold;
      white-space: nowrap;
    }
    /* Loading overlay styles */
    .loading-overlay {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background-color: rgba(255, 255, 255, 0.8);
      display: flex;
      justify-content: center;
      align-items: center;
      z-index: 2000; /* Higher than all other overlays */
      font-size: 1.2rem;
      font-weight: bold;
      color: #666;
      display: none; /* Hidden by default */
    }
    .loading-spinner {
      border: 4px solid #f3f3f3;
      border-top: 4px solid #3498db;
      border-radius: 50%;
      width: 30px;
      height: 30px;
      animation: spin 1s linear infinite;
      margin-right: 10px;
    }
    @keyframes spin {
      0% { transform: rotate(0deg); }
      100% { transform: rotate(360deg); }
    }
  </style>
</head>
<body>
  <div class="container-fluid">
    <div class="d-flex justify-content-between align-items-center mb-3">
      <h1>Coverage Map</h1>
      <button id="copy-link-btn" class="btn btn-outline-secondary">
        <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" class="bi bi-link-45deg" viewBox="0 0 16 16">
          <path d="M4.715 6.542 3.343 7.914a3 3 0 1 0 4.243 4.243l1.828-1.829A3 3 0 0 0 8.586 5.5L8 6.086a1.002 1.002 0 0 0-.154.199 2 2 0 0 1 .861 3.337L6.88 11.45a2 2 0 1 1-2.83-2.83l.793-.792a4.018 4.018 0 0 1-.128-1.287z"/>
          <path d="M6.586 4.672A3 3 0 0 0 7.414 9.5l.775-.776a2 2 0 0 1-.896-3.346L9.12 3.55a2 2 0 1 1 2.83 2.83l-.793.792c.112.42.155.855.128 1.287l1.372-1.372a3 3 0 1 0-4.243-4.243L6.586 4.672z"/>
        </svg>
        Copy Link
      </button>
    </div>
    
    <div class="card">
      <div class="card-body">
        <div class="controls row">
          <div class="col-md-6">
            <label for="receiver-select" class="form-label">Receiver:</label>
            <select id="receiver-select" class="form-select">
              <option value="" selected>All</option>
              <!-- Receivers will be loaded dynamically -->
            </select>
          </div>
          <div class="col-md-6">
            <div class="mb-2">
              <label class="form-label">Select time range:</label>
              <div class="form-check">
                <input class="form-check-input" type="radio" name="timeRangeType" id="fixedWindowRadio" value="fixed" checked>
                <label class="form-check-label" for="fixedWindowRadio">
                  Fixed time window
                </label>
              </div>
              <div class="form-check">
                <input class="form-check-input" type="radio" name="timeRangeType" id="dateRangeRadio" value="dateRange">
                <label class="form-check-label" for="dateRangeRadio">
                  Custom date range
                </label>
              </div>
            </div>
            
            <!-- Fixed time window -->
            <div id="fixedWindowContainer">
              <label for="days-select" class="form-label">Time window:</label>
              <select id="days-select" class="form-select">
                <option value="1" selected>1 day</option>
                <option value="2">2 days</option>
                <option value="7">7 days</option>
                <option value="14">14 days</option>
                <option value="30">30 days</option>
              </select>
            </div>
            
            <!-- Date range -->
            <div id="dateRangeContainer" style="display: none;">
              <div class="row">
                <div class="col-md-6">
                  <label for="from-date" class="form-label">From:</label>
                  <input type="datetime-local" id="from-date" class="form-control">
                </div>
                <div class="col-md-6">
                  <label for="to-date" class="form-label">To:</label>
                  <input type="datetime-local" id="to-date" class="form-control">
                </div>
              </div>
              <div class="mt-2">
                <button id="date-range-go" class="btn btn-primary">Go</button>
                <div id="date-range-error" class="text-danger mt-2" style="display: none;"></div>
              </div>
            </div>
          </div>
        </div>
        
        <div id="coverage-map" style="position: relative;">
          <!-- Loading overlay for map -->
          <div class="loading-overlay" id="mapLoadingOverlay">
            <div class="loading-spinner"></div>
            <span>Loading...</span>
          </div>
          <!-- Coverage Area Display -->
          <div id="coverage-area-display" style="
            position: absolute;
            bottom: 10px;
            left: 10px;
            background: rgba(255, 255, 255, 0.8);
            padding: 5px 10px;
            border-radius: 5px;
            z-index: 1000;
            font-family: Arial, sans-serif;
            font-size: 14px;
            font-weight: bold;
          ">
            <span id="coverage-area-text">Coverage: 0 sq km</span>
          </div>
          <!-- Date/Time overlay for replay -->
          <div id="replay-datetime-overlay" style="
            position: absolute;
            bottom: 10px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(255, 255, 255, 0.8);
            padding: 5px 10px;
            border-radius: 5px;
            z-index: 1000;
            font-family: Arial, sans-serif;
            font-size: 14px;
            font-weight: bold;
            display: none;
          ">
            <span id="replay-datetime-text"></span>
          </div>
          <!-- Receivers toggle checkbox -->
          <div style="
            position: absolute;
            top: 10px;
            right: 10px;
            background: rgba(255, 255, 255, 0.8);
            padding: 5px 10px;
            border-radius: 5px;
            z-index: 1000;
            font-family: Arial, sans-serif;
            font-size: 14px;
          ">
            <div class="form-check">
              <input class="form-check-input" type="checkbox" id="show-receivers-checkbox" checked>
              <label class="form-check-label" for="show-receivers-checkbox">
                Receivers
              </label>
            </div>
          </div>
          <!-- Nautical Mile Scale -->
          <div id="nm-scale" style="
            position: absolute;
            top: 20px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(255, 255, 255, 0.8);
            padding: 5px 10px;
            border-radius: 5px;
            z-index: 1100;
            font-family: Arial, sans-serif;
            font-size: 12px;
            text-align: center;
          ">
          <div id="scale-bar" style="
            position: relative;
            width: 100px;
            height: 4px;
            background: black;
            margin-bottom: 2px;
          ">
            <!-- Left tick -->
            <div style="
              position: absolute;
              left: 0;
              top: -4px;
              width: 2px;
              height: 12px;
              background: black;
            "></div>
            <!-- Right tick -->
            <div style="
              position: absolute;
              right: 0;
              top: -4px;
              width: 2px;
              height: 12px;
              background: black;
            "></div>
          </div>
            <div id="scale-label">0 NM</div>
          </div>
        </div>
        
        <!-- Date Range Navigation Section - Hourly -->
        <div id="date-range-navigation-hour" class="mt-3 mb-2" style="display: none;">
          <div class="d-flex align-items-center justify-content-center">
            <button id="date-range-prev-hour-btn" class="btn btn-sm btn-outline-primary me-2">
              <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" class="bi bi-arrow-left" viewBox="0 0 16 16">
                <path fill-rule="evenodd" d="M15 8a.5.5 0 0 0-.5-.5H2.707l3.147-3.146a.5.5 0 1 0-.708-.708l-4 4a.5.5 0 0 0 0 .708l4 4a.5.5 0 0 0 .708-.708L2.707 8.5H14.5A.5.5 0 0 0 15 8z"/>
              </svg>
              <span>Previous hour</span>
            </button>
            <div id="current-hour-display" class="mx-3 fw-bold"></div>
            <button id="date-range-next-hour-btn" class="btn btn-sm btn-outline-primary ms-2">
              <span>Next hour</span>
              <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" class="bi bi-arrow-right" viewBox="0 0 16 16">
                <path fill-rule="evenodd" d="M1 8a.5.5 0 0 1 .5-.5h11.793l-3.147-3.146a.5.5 0 0 1 .708-.708l4 4a.5.5 0 0 1 0 .708l-4 4a.5.5 0 0 1-.708-.708L13.293 8.5H1.5A.5.5 0 0 1 1 8z"/>
              </svg>
            </button>
          </div>
        </div>
        
        <!-- Date Range Navigation Section - Daily -->
        <div id="date-range-navigation-day" class="mt-2 mb-2" style="display: none;">
          <div class="d-flex align-items-center justify-content-center">
            <button id="date-range-prev-day-btn" class="btn btn-sm btn-outline-secondary me-2">
              <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" class="bi bi-arrow-left" viewBox="0 0 16 16">
                <path fill-rule="evenodd" d="M15 8a.5.5 0 0 0-.5-.5H2.707l3.147-3.146a.5.5 0 1 0-.708-.708l-4 4a.5.5 0 0 0 0 .708l4 4a.5.5 0 0 0 .708-.708L2.707 8.5H14.5A.5.5 0 0 0 15 8z"/>
              </svg>
              <span>Previous day</span>
            </button>
            <div id="current-day-display" class="mx-3 fw-bold"></div>
            <button id="date-range-next-day-btn" class="btn btn-sm btn-outline-secondary ms-2">
              <span>Next day</span>
              <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" class="bi bi-arrow-right" viewBox="0 0 16 16">
                <path fill-rule="evenodd" d="M1 8a.5.5 0 0 1 .5-.5h11.793l-3.147-3.146a.5.5 0 0 1 .708-.708l4 4a.5.5 0 0 1 0 .708l-4 4a.5.5 0 0 1-.708-.708L13.293 8.5H1.5A.5.5 0 0 1 1 8z"/>
              </svg>
            </button>
          </div>
        </div>
        
        <!-- Replay Section -->
        <div class="mt-4 mb-3">
          <h4>Replay Previous</h4>
          <div class="btn-group mb-2">
            <button id="replay-day-btn" class="btn btn-outline-primary">24 hours</button>
            <button id="replay-week-btn" class="btn btn-outline-primary">7 days</button>
          </div>
          <div class="d-flex align-items-center mt-2" id="replay-controls" style="display: none !important;">
            <div class="btn-group me-3">
              <button id="replay-prev-btn" class="btn btn-sm btn-outline-secondary">
                <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" class="bi bi-skip-backward-fill" viewBox="0 0 16 16">
                  <path d="M.5 3.5A.5.5 0 0 0 0 4v8a.5.5 0 0 0 1 0V8.753l6.267 3.636c.54.313 1.233-.066 1.233-.697v-2.94l6.267 3.636c.54.314 1.233-.065 1.233-.696V4.308c0-.63-.693-1.01-1.233-.696L8.5 7.248v-2.94c0-.63-.692-1.01-1.233-.696L1 7.248V4a.5.5 0 0 0-.5-.5z"/>
                </svg>
              </button>
              <button id="replay-pause-btn" class="btn btn-sm btn-outline-secondary">
                <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" class="bi bi-pause" viewBox="0 0 16 16">
                  <path d="M6 3.5a.5.5 0 0 1 .5.5v8a.5.5 0 0 1-1 0V4a.5.5 0 0 1 .5-.5zm4 0a.5.5 0 0 1 .5.5v8a.5.5 0 0 1-1 0V4a.5.5 0 0 1 .5-.5z"/>
                </svg>
              </button>
              <button id="replay-play-btn" class="btn btn-sm btn-outline-secondary" style="display: none;">
                <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" class="bi bi-play" viewBox="0 0 16 16">
                  <path d="M10.804 8 5 4.633v6.734L10.804 8zm.792-.696a.802.802 0 0 1 0 1.392l-6.363 3.692C4.713 12.69 4 12.345 4 11.692V4.308c0-.653.713-.998 1.233-.696l6.363 3.692z"/>
                </svg>
              </button>
              <button id="replay-next-btn" class="btn btn-sm btn-outline-secondary">
                <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" class="bi bi-skip-forward" viewBox="0 0 16 16">
                  <path d="M15.5 3.5a.5.5 0 0 1 .5.5v8a.5.5 0 0 1-1 0V4a.5.5 0 0 1 .5-.5zM7.596 8.697l-6.363 3.692c-.54.313-1.233-.066-1.233-.697V4.308c0-.63.692-1.01 1.233-.696l6.363 3.692a.802.802 0 0 1 0 1.393z"/>
                  <path d="M11.596 8.697l-6.363 3.692c-.54.313-1.233-.066-1.233-.697V4.308c0-.63.692-1.01 1.233-.696l6.363 3.692a.802.802 0 0 1 0 1.393z"/>
                </svg>
              </button>
              <button id="replay-stop-btn" class="btn btn-sm btn-outline-secondary">
                <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" class="bi bi-stop" viewBox="0 0 16 16">
                  <path d="M3.5 5A1.5 1.5 0 0 1 5 3.5h6A1.5 1.5 0 0 1 12.5 5v6a1.5 1.5 0 0 1-1.5 1.5H5A1.5 1.5 0 0 1 3.5 11V5zM5 4.5a.5.5 0 0 0-.5.5v6a.5.5 0 0 0 .5.5h6a.5.5 0 0 0 .5-.5V5a.5.5 0 0 0-.5-.5H5z"/>
                </svg>
              </button>
            </div>
            <div class="progress flex-grow-1">
              <div id="replay-progress-bar" class="progress-bar" role="progressbar" style="width: 0%"></div>
            </div>
          </div>
          <div id="replay-info" class="mt-2 small text-muted" style="display: none;"></div>
        </div>
        
        <!-- Coverage Statistics Section -->
        <div id="coverage-stats" style="display: none; margin-top: 20px;">
          <h4>Coverage Statistics</h4>
          <div class="row">
            <div class="col-md-6">
              <div class="card">
                <div class="card-header">Messages by Distance</div>
                <div class="card-body">
                  <table class="table table-sm">
                    <thead>
                      <tr>
                        <th>Range</th>
                        <th>Messages</th>
                        <th>Percentage</th>
                      </tr>
                    </thead>
                    <tbody id="distance-stats">
                      <!-- Will be populated dynamically -->
                    </tbody>
                  </table>
                </div>
              </div>
            </div>
            <div class="col-md-6">
              <div class="card">
                <div class="card-header">Messages by Direction</div>
                <div class="card-body">
                  <table class="table table-sm">
                    <thead>
                      <tr>
                        <th>Direction</th>
                        <th>Messages</th>
                        <th>Percentage</th>
                      </tr>
                    </thead>
                    <tbody id="direction-stats">
                      <!-- Will be populated dynamically -->
                    </tbody>
                  </table>
                </div>
              </div>
            </div>
          </div>
        </div>
      </div>
    </div>
    
    <!-- CSV Download Buttons -->
    <div id="csv-buttons" class="mt-3">
      <button id="data-csv-btn" class="btn btn-sm btn-outline-secondary me-2">
        <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" class="bi bi-file-earmark-arrow-down" viewBox="0 0 16 16">
          <path d="M8.5 6.5a.5.5 0 0 0-1 0v3.793L6.354 9.146a.5.5 0 1 0-.708.708l2 2a.5.5 0 0 0 .708 0l2-2a.5.5 0 0 0-.708-.708L8.5 10.293V6.5z"/>
          <path d="M14 14V4.5L9.5 0H4a2 2 0 0 0-2 2v12a2 2 0 0 0 2 2h8a2 2 0 0 0 2-2zM9.5 3A1.5 1.5 0 0 0 11 4.5h2V14a1 1 0 0 1-1 1H4a1 1 0 0 1-1-1V2a1 1 0 0 1 1-1h5.5v2z"/>
        </svg>
        Data CSV
      </button>
      <button id="table-csv-btn" class="btn btn-sm btn-outline-secondary">
        <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" class="bi bi-table" viewBox="0 0 16 16">
          <path d="M0 2a2 2 0 0 1 2-2h12a2 2 0 0 1 2 2v12a2 2 0 0 1-2 2H2a2 2 0 0 1-2-2V2zm15 2h-4v3h4V4zm0 4h-4v3h4V8zm0 4h-4v3h3a1 1 0 0 0 1-1v-2zm-5 3v-3H6v3h4zm-5 0v-3H1v2a1 1 0 0 0 1 1h3zm-4-4h4V8H1v3zm0-4h4V4H1v3zm5-3v3h4V4H6zm4 4H6v3h4V8z"/>
        </svg>
        Table CSV
      </button>
    </div>
  </div>
  
  <script>
    // Initialize map
    const map = L.map('coverage-map').setView([51.505, -0.09], 6);
    
    // Add base map layer
    L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
      attribution: '&copy; <a href="https://www.openstreetmap.org/copyright">OpenStreetMap</a> contributors'
    }).addTo(map);
    
    // Map layers that need to be cleared between receiver changes
    let heatLayer = null;
    let receiverMarker = null;
    let receiverTooltip = null;
    let rangeCircles = []; // Array to store the range circles
    let rangeLabels = []; // Array to store the range labels
    let showReceivers = true; // Flag to control receiver marker visibility
    
    // Function to clear all previous map layers
    function clearMapLayers() {
      // Remove heat layer if it exists
      if (heatLayer) {
        map.removeLayer(heatLayer);
        heatLayer = null;
      }
      
      // Remove receiver marker if it exists
      if (receiverMarker) {
        map.removeLayer(receiverMarker);
        receiverMarker = null;
      }
      
      // Remove receiver tooltip if it exists
      if (receiverTooltip) {
        map.removeLayer(receiverTooltip);
        receiverTooltip = null;
      }
      
      // Clear any other receiver markers that might have been added
      map.eachLayer(function(layer) {
        if (layer instanceof L.Marker || layer instanceof L.Tooltip) {
          if (layer._icon && layer._icon.className.includes('receiver-marker') ||
              layer.options && layer.options.className === 'receiver-tooltip') {
            map.removeLayer(layer);
          }
        }
      });
      
      // Remove range circles and labels
      rangeCircles.forEach(circle => {
        if (circle) map.removeLayer(circle);
      });
      rangeCircles = [];
      
      rangeLabels.forEach(label => {
        if (label) map.removeLayer(label);
      });
      rangeLabels = [];
    }
    
    // Calculate the maximum distance from the receiver to any point in the heatmap
    function calculateMaxDistance(receiverLatLng, heatData) {
      let maxDistance = 0;
      
      heatData.forEach(point => {
        const pointLatLng = L.latLng(point[0], point[1]);
        const distance = receiverLatLng.distanceTo(pointLatLng);
        if (distance > maxDistance) {
          maxDistance = distance;
        }
      });
      
      return maxDistance; // in meters
    }
    
    // Draw concentric circles around the receiver
    function drawRangeCircles(receiverLatLng, maxDistance) {
      // Clear any existing circles and labels
      rangeCircles.forEach(circle => {
        if (circle) map.removeLayer(circle);
      });
      rangeCircles = [];
      
      rangeLabels.forEach(label => {
        if (label) map.removeLayer(label);
      });
      rangeLabels = [];
      
      // Create 3 equally spaced circles
      for (let i = 1; i <= 3; i++) {
        const radiusMeters = maxDistance * i / 3;
        const radiusNM = Math.round(radiusMeters / 1852); // Convert meters to nautical miles and round to nearest whole number
        
        // Create circle
        const circle = L.circle(receiverLatLng, {
          radius: radiusMeters,
          color: '#3388ff',
          fillColor: 'transparent',
          weight: 1.5,
          opacity: 0.7,
          dashArray: '5, 5' // Make the circles dashed
        }).addTo(map);
        
        rangeCircles.push(circle);
        
        // Calculate position for the label (east of the center)
        const labelLatLng = calculateLabelPosition(receiverLatLng, radiusMeters);
        
        // Create label
        const label = L.tooltip({
          permanent: true,
          direction: 'center',
          className: 'receiver-tooltip'
        })
        .setLatLng(labelLatLng)
        .setContent(`${radiusNM} NM`)
        .addTo(map);
        
        rangeLabels.push(label);
      }
    }
    
    // Calculate position for range label (east of center)
    function calculateLabelPosition(center, radiusMeters) {
      // Convert radius from meters to degrees longitude (approximate)
      // This is a simplified calculation that works for small distances
      const radiusLng = radiusMeters / (111320 * Math.cos(center.lat * Math.PI / 180));
      
      // Position the label to the east of the center
      return L.latLng(center.lat, center.lng + radiusLng);
    }
    
    // Calculate bearing between two points
    function calculateBearing(lat1, lon1, lat2, lon2) {
      const toRad = value => value * Math.PI / 180;
      const toDeg = value => value * 180 / Math.PI;
      
      const dLon = toRad(lon2 - lon1);
      const y = Math.sin(dLon) * Math.cos(toRad(lat2));
      const x = Math.cos(toRad(lat1)) * Math.sin(toRad(lat2)) -
                Math.sin(toRad(lat1)) * Math.cos(toRad(lat2)) * Math.cos(dLon);
      let bearing = toDeg(Math.atan2(y, x));
      
      // Normalize to 0-360
      bearing = (bearing + 360) % 360;
      return bearing;
    }
    
    // Convert bearing to cardinal direction
    function bearingToDirection(bearing) {
      const directions = ['N', 'NE', 'E', 'SE', 'S', 'SW', 'W', 'NW'];
      return directions[Math.round(bearing / 45) % 8];
    }
    
    // Calculate approximate coverage area in square kilometers
    function calculateCoverageArea(heatData) {
      if (!heatData || heatData.length === 0) return 0;
      
      // Create a grid to track covered cells
      const gridSize = 0.01; // Grid cell size in degrees (roughly 1km at equator)
      const coveredCells = new Set();
      
      // Track each cell that contains at least one data point
      heatData.forEach(point => {
        const lat = point[0];
        const lon = point[1];
        
        // Calculate grid cell coordinates
        const latCell = Math.floor(lat / gridSize);
        const lonCell = Math.floor(lon / gridSize);
        
        // Create a unique key for this cell
        const cellKey = `${latCell},${lonCell}`;
        
        // Add to set of covered cells
        coveredCells.add(cellKey);
      });
      
      // Calculate approximate area
      // Each cell is approximately gridSize × gridSize degrees
      // Convert to square kilometers (very approximate, varies by latitude)
      let totalAreaSqKm = 0;
      
      coveredCells.forEach(cellKey => {
        const [latCell, lonCell] = cellKey.split(',').map(Number);
        const centerLat = (latCell * gridSize) + (gridSize / 2);
        
        // Area of a 0.01° × 0.01° cell varies by latitude
        // At the equator, 1° latitude ≈ 111 km, 1° longitude ≈ 111 km
        // At higher latitudes, longitude degrees become shorter
        const latLengthKm = 111 * gridSize;
        const lonLengthKm = 111 * gridSize * Math.cos(centerLat * Math.PI / 180);
        
        const cellAreaSqKm = latLengthKm * lonLengthKm;
        totalAreaSqKm += cellAreaSqKm;
      });
      
      return Math.round(totalAreaSqKm);
    }
    
    // Calculate coverage statistics
    function calculateCoverageStats(heatData, receiverLatLng, maxDistance) {
      if (!receiverLatLng) return null;
      
      // Initialize statistics objects
      const distanceStats = {
        ring1: 0,
        ring2: 0,
        ring3: 0,
        beyond: 0
      };
      
      const directionStats = {
        'N': 0, 'NE': 0, 'E': 0, 'SE': 0,
        'S': 0, 'SW': 0, 'W': 0, 'NW': 0
      };
      
      let totalPoints = 0;
      
      // Calculate ring boundaries
      const ring1 = maxDistance / 3;
      const ring2 = maxDistance * 2 / 3;
      const ring3 = maxDistance;
      
      // Process each point
      heatData.forEach(point => {
        const pointLatLng = L.latLng(point[0], point[1]);
        const distance = receiverLatLng.distanceTo(pointLatLng);
        const bearing = calculateBearing(
          receiverLatLng.lat, receiverLatLng.lng,
          pointLatLng.lat, pointLatLng.lng
        );
        const direction = bearingToDirection(bearing);
        
        // Count by distance
        if (distance <= ring1) {
          distanceStats.ring1++;
        } else if (distance <= ring2) {
          distanceStats.ring2++;
        } else if (distance <= ring3) {
          distanceStats.ring3++;
        } else {
          distanceStats.beyond++;
        }
        
        // Count by direction
        directionStats[direction]++;
        
        totalPoints++;
      });
      
      return {
        distanceStats,
        directionStats,
        totalPoints,
        rings: {
          ring1: ring1,
          ring2: ring2,
          ring3: ring3
        }
      };
    }
    
    // Update the statistics display
    function updateStatsDisplay(stats, showDirectionStats) {
      const statsContainer = document.getElementById('coverage-stats');
      const distanceStatsTable = document.getElementById('distance-stats');
      const directionStatsTable = document.getElementById('direction-stats');
      const directionStatsCard = directionStatsTable.closest('.card').parentElement;
      
      if (!stats) {
        statsContainer.style.display = 'none';
        return;
      }
      
      // Show the stats container
      statsContainer.style.display = 'block';
      
      // Show/hide direction stats based on parameter
      directionStatsCard.style.display = showDirectionStats ? 'block' : 'none';
      
      // Clear previous stats
      distanceStatsTable.innerHTML = '';
      directionStatsTable.innerHTML = '';
      
      // Format distance stats
      const { distanceStats, directionStats, totalPoints, rings } = stats;
      
      // Add distance stats rows
      const ring1NM = Math.round(rings.ring1 / 1852);
      const ring2NM = Math.round(rings.ring2 / 1852);
      const ring3NM = Math.round(rings.ring3 / 1852);
      
      distanceStatsTable.innerHTML += `
        <tr>
          <td>0 - ${ring1NM} NM</td>
          <td>${distanceStats.ring1}</td>
          <td>${((distanceStats.ring1 / totalPoints) * 100).toFixed(1)}%</td>
        </tr>
        <tr>
          <td>${ring1NM} - ${ring2NM} NM</td>
          <td>${distanceStats.ring2}</td>
          <td>${((distanceStats.ring2 / totalPoints) * 100).toFixed(1)}%</td>
        </tr>
        <tr>
          <td>${ring2NM} - ${ring3NM} NM</td>
          <td>${distanceStats.ring3}</td>
          <td>${((distanceStats.ring3 / totalPoints) * 100).toFixed(1)}%</td>
        </tr>
      `;
      
      // Only add direction stats if we're showing them
      if (showDirectionStats) {
        // Sort directions by count (descending)
        const sortedDirections = Object.entries(directionStats)
          .sort((a, b) => b[1] - a[1]);
        
        // Add direction stats rows
        sortedDirections.forEach(([direction, count]) => {
          if (count > 0) {
            directionStatsTable.innerHTML += `
              <tr>
                <td>${direction}</td>
                <td>${count}</td>
                <td>${((count / totalPoints) * 100).toFixed(1)}%</td>
              </tr>
            `;
          }
        });
      }
    }
    
    // Load receivers
    async function loadReceivers() {
      try {
        const receivers = await fetch('/receivers').then(r => r.json());
        const select = document.getElementById('receiver-select');
        
        // Sort receivers by name
        receivers.sort((a, b) => a.name.localeCompare(b.name));
        
        // Add receivers to dropdown (excluding receiver ID 0)
        receivers.forEach(receiver => {
          // Skip receiver ID 0
          if (receiver.id === 0) return;
          
          const option = document.createElement('option');
          option.value = receiver.id;
          option.textContent = receiver.name;
          select.appendChild(option);
        });
      } catch (e) {
        console.error('Failed to load receivers:', e);
        alert('Failed to load receivers. Please try again later.');
      }
    }
    
    // Show global loading overlay - now just uses map loading overlay
    function showGlobalLoading() {
      // Use map loading overlay instead
      showMapLoading();
    }
    
    // Hide global loading overlay - now just uses map loading overlay
    function hideGlobalLoading() {
      // Use map loading overlay instead
      hideMapLoading();
    }
    
    // Show map loading overlay
    function showMapLoading() {
      document.getElementById('mapLoadingOverlay').style.display = 'flex';
    }
    
    // Hide map loading overlay
    function hideMapLoading() {
      document.getElementById('mapLoadingOverlay').style.display = 'none';
    }
    
    // Validate date range doesn't exceed 30 days
    function validateDateRange(fromDate, toDate) {
      if (!fromDate || !toDate) return false;
      
      const from = new Date(fromDate);
      const to = new Date(toDate);
      
      if (isNaN(from.getTime()) || isNaN(to.getTime())) return false;
      
      // Check if from date is before to date
      if (from > to) {
        document.getElementById('date-range-error').textContent = 'From date must be before To date';
        document.getElementById('date-range-error').style.display = 'block';
        return false;
      }
      
      // Calculate difference in days
      const diffTime = Math.abs(to - from);
      const diffDays = Math.ceil(diffTime / (1000 * 60 * 60 * 24));
      
      // Check if range exceeds 30 days
      if (diffDays > 30) {
        document.getElementById('date-range-error').textContent = 'Date range cannot exceed 30 days';
        document.getElementById('date-range-error').style.display = 'block';
        return false;
      }
      
      // Hide error message if validation passes
      document.getElementById('date-range-error').style.display = 'none';
      return true;
    }
    
    // Toggle between fixed window and date range
    function toggleTimeRangeType(triggerUpdate = false) {
      const isDateRange = document.getElementById('dateRangeRadio').checked;
      document.getElementById('fixedWindowContainer').style.display = isDateRange ? 'none' : 'block';
      document.getElementById('dateRangeContainer').style.display = isDateRange ? 'block' : 'none';
      
      // Hide date range navigation when switching to fixed window
      document.getElementById('date-range-navigation-hour').style.display = 'none';
      document.getElementById('date-range-navigation-day').style.display = 'none';
      document.getElementById('replay-datetime-overlay').style.display = 'none';
      
      // For fixed window, trigger update automatically
      // For date range, user will click the Go button
      if (!isDateRange && triggerUpdate) {
        updateURL();
        loadCoverageData();
      }
    }
    
    // Format date for API request (RFC3339 format)
    function formatDateForAPI(date) {
      return date.toISOString();
    }
    
    // Load coverage data
    async function loadCoverageData() {
      const receiverId = document.getElementById('receiver-select').value;
      const isDateRange = document.getElementById('dateRangeRadio').checked;
      
      try {
        // Show loading state
        showGlobalLoading();
        
        let url;
        
        if (isDateRange) {
          const fromDate = document.getElementById('from-date').value;
          const toDate = document.getElementById('to-date').value;
          
          // Validate date range
          if (!validateDateRange(fromDate, toDate)) {
            hideGlobalLoading();
            return; // Stop if validation fails
          }
          
          try {
            // Format dates for API
            const fromDateObj = new Date(fromDate);
            const toDateObj = new Date(toDate);
            
            // Reset navigation type to show full date range
            lastNavigationType = null;
            
            // Show the full selected range in the map overlay
            document.getElementById('replay-datetime-overlay').style.display = 'block';
            document.getElementById('replay-datetime-text').textContent =
              `${fromDateObj.toLocaleString()} - ${toDateObj.toLocaleString()}`;
            
            // Initialize date range navigation
            currentFromDate = fromDateObj;
            currentToDate = toDateObj;
            initializeDateRangeNavigation();
            
            // Fetch coverage data with date range
            url = `/statistics/stats/coverage-map?from=${formatDateForAPI(fromDateObj)}&to=${formatDateForAPI(toDateObj)}`;
            if (receiverId) {
              url += `&receiver_id=${receiverId}`;
            }
          } catch (e) {
            console.error('Date formatting error:', e);
            alert('Invalid date format. Please check your date inputs.');
            hideGlobalLoading();
            return;
          }
        } else {
          const days = document.getElementById('days-select').value;
          
          // Fetch coverage data with days parameter
          url = `/statistics/stats/coverage-map?days=${days}`;
          if (receiverId) {
            url += `&receiver_id=${receiverId}`;
          }
        }
        
        // Update URL with current selections
        updateURL();
        
        const data = await fetch(url).then(r => r.json());
        
        if (data.length === 0) {
          alert('No coverage data available for the selected receiver and time period');
          return;
        }
        
        // Convert data to heatmap format
        const heatData = data.map(point => {
          // Intensity based on logarithmic scale of count, but amplified for better visibility
          // Increase the divisor to make low counts more visible
          const intensity = Math.min(1, Math.log10(point.count + 1) / 2);
          return [point.lat, point.lon, intensity];
        });
        
        // Calculate and display coverage area
        const coverageAreaSqKm = calculateCoverageArea(heatData);
        document.getElementById('coverage-area-text').textContent = `Coverage: ${coverageAreaSqKm} sq km`;
        
        // Clear all previous map layers
        clearMapLayers();
        
        // Create new heat layer with improved visibility
        heatLayer = L.heatLayer(heatData, {
          radius: 20,           // Increased from 15
          blur: 15,             // Decreased from 20 for sharper points
          maxZoom: 17,
          minOpacity: 0.4,      // Added minimum opacity
          gradient: {0.2: 'blue', 0.4: 'cyan', 0.6: 'lime', 0.8: 'yellow', 1: 'red'}
        }).addTo(map);
        
        // Load all receivers
        const receivers = await fetch('/receivers').then(r => r.json());
        
        // Create a receiver icon
        const receiverIcon = L.divIcon({
          html: '<div style="background-color: #ff4136; width: 12px; height: 12px; border-radius: 50%; border: 2px solid white;"></div>',
          className: 'receiver-marker',
          iconSize: [12, 12]
        });
        
        // Points for bounds calculation
        const points = heatData.map(p => [p[0], p[1]]);
        
        if (receiverId) {
          // Specific receiver selected
          const selectedReceiver = receivers.find(r => r.id === parseInt(receiverId));
          
          if (selectedReceiver && selectedReceiver.latitude && selectedReceiver.longitude) {
            // Add marker with popup and store reference if receivers should be shown
            if (showReceivers) {
              receiverMarker = L.marker([selectedReceiver.latitude, selectedReceiver.longitude], {icon: receiverIcon})
                .addTo(map)
                .bindPopup(`<b>Receiver:</b> ${selectedReceiver.name}`);
              
              // Add permanent tooltip with receiver name and store reference
              receiverTooltip = L.tooltip({
                permanent: true,
                direction: 'top',
                className: 'receiver-tooltip',
                offset: [0, -10]
              })
              .setContent(`<b>${selectedReceiver.name}</b>`)
              .setLatLng([selectedReceiver.latitude, selectedReceiver.longitude])
              .addTo(map);
            }
            
            // Calculate maximum distance and draw range circles only if receivers are shown
            const receiverLatLng = L.latLng(selectedReceiver.latitude, selectedReceiver.longitude);
            const maxDistance = calculateMaxDistance(receiverLatLng, heatData);
            if (showReceivers) {
              drawRangeCircles(receiverLatLng, maxDistance);
            }
            
            // Add receiver location to points for bounds calculation
            points.push([selectedReceiver.latitude, selectedReceiver.longitude]);
          }
        } else {
          // "All" receivers selected - show markers for all receivers but no range circles
          receivers.forEach(receiver => {
            if (receiver.latitude && receiver.longitude) {
              // Add receiver location to points for bounds calculation
              points.push([receiver.latitude, receiver.longitude]);
              
              // Only add markers if receivers should be shown
              if (showReceivers) {
                // Add marker with popup
                L.marker([receiver.latitude, receiver.longitude], {icon: receiverIcon})
                  .addTo(map)
                  .bindPopup(`<b>Receiver:</b> ${receiver.name}`);
                
                // Add tooltip with receiver name
                L.tooltip({
                  permanent: true,
                  direction: 'top',
                  className: 'receiver-tooltip',
                  offset: [0, -10]
                })
                .setContent(`<b>${receiver.name}</b>`)
                .setLatLng([receiver.latitude, receiver.longitude])
                .addTo(map);
              }
            }
          });
        }
        
        // Fit bounds to include all points (heatmap + receivers)
        const bounds = L.latLngBounds(points);
        map.fitBounds(bounds, { padding: [50, 50] });
        
        // Calculate and display statistics
        if (receiverId) {
          // For specific receiver, show both distance and direction stats
          const selectedReceiver = receivers.find(r => r.id === parseInt(receiverId));
          if (selectedReceiver && selectedReceiver.latitude && selectedReceiver.longitude) {
            const receiverLatLng = L.latLng(selectedReceiver.latitude, selectedReceiver.longitude);
            const maxDistance = calculateMaxDistance(receiverLatLng, heatData);
            const stats = calculateCoverageStats(heatData, receiverLatLng, maxDistance);
            updateStatsDisplay(stats, true); // Show direction stats for specific receiver
          } else {
            updateStatsDisplay(null, false);
          }
        } else {
          // For "All" receivers, don't show direction stats as they wouldn't be meaningful
          updateStatsDisplay(null, false);
        }
      } catch (e) {
        console.error('Failed to load coverage data:', e);
        alert('Failed to load coverage data. Please try again later.');
      } finally {
        // Hide loading overlay
        hideGlobalLoading();
      }
    }
    
    // Parse URL query parameters
    function getQueryParams() {
      const params = new URLSearchParams(window.location.search);
      return {
        receiverId: params.get('receiver_id'),
        days: params.get('days'),
        from: params.get('from'),
        to: params.get('to')
      };
    }
    
    // Update URL with current selections without reloading the page
    function updateURL() {
      const receiverId = document.getElementById('receiver-select').value;
      const isDateRange = document.getElementById('dateRangeRadio').checked;
      const url = new URL(window.location.href);
      
      if (receiverId) {
        url.searchParams.set('receiver_id', receiverId);
      } else {
        url.searchParams.delete('receiver_id');
      }
      
      if (isDateRange) {
        const fromDate = document.getElementById('from-date').value;
        const toDate = document.getElementById('to-date').value;
        
        if (fromDate && toDate) {
          try {
            const fromDateObj = new Date(fromDate);
            const toDateObj = new Date(toDate);
            
            url.searchParams.set('from', formatDateForAPI(fromDateObj));
            url.searchParams.set('to', formatDateForAPI(toDateObj));
            url.searchParams.delete('days');
          } catch (e) {
            console.error('Error formatting dates for URL:', e);
          }
        }
      } else {
        const days = document.getElementById('days-select').value;
        
        if (days) {
          url.searchParams.set('days', days);
        } else {
          url.searchParams.delete('days');
        }
        
        url.searchParams.delete('from');
        url.searchParams.delete('to');
      }
      
      window.history.replaceState({}, '', url);
    }
    
    // Determine appropriate step size (hour or day) based on date range
    function determineDateRangeStepSize(fromDate, toDate) {
      const from = new Date(fromDate);
      const to = new Date(toDate);
      const diffTime = Math.abs(to - from);
      const diffDays = Math.ceil(diffTime / (1000 * 60 * 60 * 24));
      
      // If range is more than 7 days, use day step size, otherwise use hour
      return diffDays > 7 ? 'day' : 'hour';
    }
    
    // Initialize date range navigation
    function initializeDateRangeNavigation() {
      const fromDateInput = document.getElementById('from-date').value;
      const toDateInput = document.getElementById('to-date').value;
      
      if (!fromDateInput || !toDateInput) return;
      
      // Get the original date range selected by the user
      const originalFromDate = new Date(fromDateInput);
      const originalToDate = new Date(toDateInput);
      
      // Determine if we should show day navigation (if range > 24 hours)
      const diffTime = Math.abs(originalToDate - originalFromDate);
      const diffHours = diffTime / (1000 * 60 * 60);
      showDayNavigation = diffHours > 24;
      
      // Determine step size based on date range
      dateRangeStepSize = determineDateRangeStepSize(originalFromDate, originalToDate);
      
      // Set the initial date range for hourly navigation
      currentFromDate = new Date(originalFromDate);
      currentToDate = new Date(currentFromDate);
      currentToDate.setHours(currentToDate.getHours() + 1);
      
      // Show the appropriate navigation controls
      document.getElementById('date-range-navigation-hour').style.display = 'block';
      document.getElementById('date-range-navigation-day').style.display = showDayNavigation ? 'block' : 'none';
      
      // Update the hour and day displays in the navigation controls
      const hourEndTime = new Date(currentFromDate);
      hourEndTime.setHours(hourEndTime.getHours() + 1);
      
      const hourDisplay = document.getElementById('current-hour-display');
      hourDisplay.textContent = `${currentFromDate.toLocaleDateString()} ${currentFromDate.getHours()}:00 - ${hourEndTime.getHours()}:00`;
      
      if (showDayNavigation) {
        const currentDay = new Date(currentFromDate);
        currentDay.setHours(0, 0, 0, 0);
        
        const dayDisplay = document.getElementById('current-day-display');
        dayDisplay.textContent = currentDay.toLocaleDateString();
      }
      
      // Note: We don't update the map overlay here to preserve the full date range display
      // The overlay will be updated when the user clicks on a navigation button
    }
    
    // Update both time displays
    function updateTimeDisplays() {
      // Update hour display
      const hourEndTime = new Date(currentFromDate);
      hourEndTime.setHours(hourEndTime.getHours() + 1);
      
      const hourDisplay = document.getElementById('current-hour-display');
      hourDisplay.textContent = `${currentFromDate.toLocaleDateString()} ${currentFromDate.getHours()}:00 - ${hourEndTime.getHours()}:00`;
      
      // Update day display if showing
      if (showDayNavigation) {
        const currentDay = new Date(currentFromDate);
        currentDay.setHours(0, 0, 0, 0); // Start of the day
        
        const dayDisplay = document.getElementById('current-day-display');
        dayDisplay.textContent = currentDay.toLocaleDateString();
      }
      
      // Only update the date/time overlay if a navigation button has been clicked
      if (lastNavigationType === 'day') {
        // For day navigation, just show the date
        const currentDay = new Date(currentFromDate);
        currentDay.setHours(0, 0, 0, 0);
        document.getElementById('replay-datetime-overlay').style.display = 'block';
        document.getElementById('replay-datetime-text').textContent = currentDay.toLocaleDateString();
      } else if (lastNavigationType === 'hour') {
        // For hour navigation, show the hour range
        document.getElementById('replay-datetime-overlay').style.display = 'block';
        document.getElementById('replay-datetime-text').textContent = hourDisplay.textContent;
      }
      // If lastNavigationType is not set, we don't update the overlay
      // This preserves the full date range display set in loadCoverageData
    }
    
    // Step to previous hour
    function stepToPreviousHour() {
      if (!currentFromDate || !currentToDate) return;
      
      // Set navigation type
      lastNavigationType = 'hour';
      
      // Move back one hour and set range to exactly one hour
      const newFromDate = new Date(currentFromDate);
      newFromDate.setHours(newFromDate.getHours() - 1);
      
      const newToDate = new Date(newFromDate);
      newToDate.setHours(newToDate.getHours() + 1);
      
      currentFromDate = newFromDate;
      currentToDate = newToDate;
      
      updateTimeDisplays();
      loadDateRangeData();
    }
    
    // Step to next hour
    function stepToNextHour() {
      if (!currentFromDate || !currentToDate) return;
      
      // Set navigation type
      lastNavigationType = 'hour';
      
      // Don't allow navigating beyond current time
      const now = new Date();
      
      // Move forward one hour and set range to exactly one hour
      const newFromDate = new Date(currentFromDate);
      newFromDate.setHours(newFromDate.getHours() + 1);
      
      // Check if we'd be going beyond current time
      if (newFromDate > now) return;
      
      const newToDate = new Date(newFromDate);
      newToDate.setHours(newToDate.getHours() + 1);
      
      // If end time would be beyond now, cap it at now
      if (newToDate > now) {
        newToDate.setTime(now.getTime());
      }
      
      currentFromDate = newFromDate;
      currentToDate = newToDate;
      
      updateTimeDisplays();
      loadDateRangeData();
    }
    
    // Step to previous day
    function stepToPreviousDay() {
      if (!currentFromDate || !currentToDate) return;
      
      // Set navigation type
      lastNavigationType = 'day';
      
      // Get current day and move to start of day
      const currentDay = new Date(currentFromDate);
      currentDay.setHours(0, 0, 0, 0);
      
      // Move back one day
      const previousDay = new Date(currentDay);
      previousDay.setDate(previousDay.getDate() - 1);
      
      // Set from date to start of previous day
      currentFromDate = new Date(previousDay);
      
      // Set to date to end of previous day for full day data
      currentToDate = new Date(previousDay);
      currentToDate.setHours(23, 59, 59, 999);
      
      updateTimeDisplays();
      loadDateRangeData();
    }
    
    // Step to next day
    function stepToNextDay() {
      if (!currentFromDate || !currentToDate) return;
      
      // Set navigation type
      lastNavigationType = 'day';
      
      // Don't allow navigating beyond current time
      const now = new Date();
      
      // Get current day and move to start of day
      const currentDay = new Date(currentFromDate);
      currentDay.setHours(0, 0, 0, 0);
      
      // Move forward one day
      const nextDay = new Date(currentDay);
      nextDay.setDate(nextDay.getDate() + 1);
      
      // Check if we'd be going beyond current time
      if (nextDay > now) return;
      
      // Set from date to start of next day
      currentFromDate = new Date(nextDay);
      
      // Set to date to end of next day for full day data
      currentToDate = new Date(nextDay);
      currentToDate.setHours(23, 59, 59, 999);
      
      // If end time would be beyond now, cap it at now
      if (currentToDate > now) {
        currentToDate.setTime(now.getTime());
      }
      
      updateTimeDisplays();
      loadDateRangeData();
    }
    
    // Load data for the current date range
    async function loadDateRangeData() {
      const receiverId = document.getElementById('receiver-select').value;
      
      try {
        // Show loading state
        showMapLoading();
        
        // Format dates for API
        let fromFormatted, toFormatted;
        
        if (lastNavigationType === 'day') {
          // For day navigation, ensure we request the entire day's data
          const dayStart = new Date(currentFromDate);
          dayStart.setHours(0, 0, 0, 0);
          
          const dayEnd = new Date(dayStart);
          dayEnd.setHours(23, 59, 59, 999);
          
          fromFormatted = formatDateForAPI(dayStart);
          toFormatted = formatDateForAPI(dayEnd);
        } else {
          // For hour navigation, use the current from/to dates
          fromFormatted = formatDateForAPI(currentFromDate);
          toFormatted = formatDateForAPI(currentToDate);
        }
        
        // Build URL
        let url = `/statistics/stats/coverage-map?from=${fromFormatted}&to=${toFormatted}`;
        if (receiverId) {
          url += `&receiver_id=${receiverId}`;
        }
        
        // Update URL in browser without reloading
        const browserUrl = new URL(window.location.href);
        browserUrl.searchParams.set('from', fromFormatted);
        browserUrl.searchParams.set('to', toFormatted);
        if (receiverId) {
          browserUrl.searchParams.set('receiver_id', receiverId);
        }
        window.history.replaceState({}, '', browserUrl);
        
        // Fetch data
        const data = await fetch(url).then(r => r.json());
        
        if (data.length === 0) {
          alert('No coverage data available for the selected time period');
          hideMapLoading();
          return;
        }
        
        // Convert data to heatmap format
        const heatData = data.map(point => {
          const intensity = Math.min(1, Math.log10(point.count + 1) / 2);
          return [point.lat, point.lon, intensity];
        });
        
        // Calculate and display coverage area
        const coverageAreaSqKm = calculateCoverageArea(heatData);
        document.getElementById('coverage-area-text').textContent = `Coverage: ${coverageAreaSqKm} sq km`;
        
        // Clear all previous map layers
        clearMapLayers();
        
        // Create new heat layer
        heatLayer = L.heatLayer(heatData, {
          radius: 20,
          blur: 15,
          maxZoom: 17,
          minOpacity: 0.4,
          gradient: {0.2: 'blue', 0.4: 'cyan', 0.6: 'lime', 0.8: 'yellow', 1: 'red'}
        }).addTo(map);
        
        // Use cached receivers or fetch them if not available
        if (!cachedReceivers) {
          cachedReceivers = await fetch('/receivers').then(r => r.json());
        }
        const receivers = cachedReceivers;
        
        // Create a receiver icon
        const receiverIcon = L.divIcon({
          html: '<div style="background-color: #ff4136; width: 12px; height: 12px; border-radius: 50%; border: 2px solid white;"></div>',
          className: 'receiver-marker',
          iconSize: [12, 12]
        });
        
        // Points for bounds calculation
        const points = heatData.map(p => [p[0], p[1]]);
        
        if (receiverId) {
          // Specific receiver selected
          const selectedReceiver = receivers.find(r => r.id === parseInt(receiverId));
          
          if (selectedReceiver && selectedReceiver.latitude && selectedReceiver.longitude) {
            // Add marker with popup and store reference if receivers should be shown
            if (showReceivers) {
              receiverMarker = L.marker([selectedReceiver.latitude, selectedReceiver.longitude], {icon: receiverIcon})
                .addTo(map)
                .bindPopup(`<b>Receiver:</b> ${selectedReceiver.name}`);
              
              // Add permanent tooltip with receiver name and store reference
              receiverTooltip = L.tooltip({
                permanent: true,
                direction: 'top',
                className: 'receiver-tooltip',
                offset: [0, -10]
              })
              .setContent(`<b>${selectedReceiver.name}</b>`)
              .setLatLng([selectedReceiver.latitude, selectedReceiver.longitude])
              .addTo(map);
            }
            
            // Calculate maximum distance and draw range circles only if receivers are shown
            const receiverLatLng = L.latLng(selectedReceiver.latitude, selectedReceiver.longitude);
            const maxDistance = calculateMaxDistance(receiverLatLng, heatData);
            if (showReceivers) {
              drawRangeCircles(receiverLatLng, maxDistance);
            }
            
            // Add receiver location to points for bounds calculation
            points.push([selectedReceiver.latitude, selectedReceiver.longitude]);
            
            // Calculate and display statistics
            const stats = calculateCoverageStats(heatData, receiverLatLng, maxDistance);
            updateStatsDisplay(stats, true);
          }
        } else {
          // "All" receivers selected - show markers for all receivers but no range circles
          receivers.forEach(receiver => {
            if (receiver.latitude && receiver.longitude) {
              // Add receiver location to points for bounds calculation
              points.push([receiver.latitude, receiver.longitude]);
              
              // Only add markers if receivers should be shown
              if (showReceivers) {
                // Add marker with popup
                L.marker([receiver.latitude, receiver.longitude], {icon: receiverIcon})
                  .addTo(map)
                  .bindPopup(`<b>Receiver:</b> ${receiver.name}`);
                
                // Add tooltip with receiver name
                L.tooltip({
                  permanent: true,
                  direction: 'top',
                  className: 'receiver-tooltip',
                  offset: [0, -10]
                })
                .setContent(`<b>${receiver.name}</b>`)
                .setLatLng([receiver.latitude, receiver.longitude])
                .addTo(map);
              }
            }
          });
          
          // For "All" receivers, don't show direction stats
          updateStatsDisplay(null, false);
        }
        
        // Fit bounds to include all points (heatmap + receivers)
        const bounds = L.latLngBounds(points);
        map.fitBounds(bounds, { padding: [50, 50] });
      } catch (e) {
        console.error('Failed to load coverage data:', e);
        alert('Failed to load coverage data. Please try again later.');
      } finally {
        // Hide loading overlay
        hideMapLoading();
      }
    }
    
    // Copy current URL to clipboard
    function copyLinkToClipboard() {
      const url = window.location.href;
      navigator.clipboard.writeText(url).then(() => {
        const btn = document.getElementById('copy-link-btn');
        const originalText = btn.innerHTML;
        btn.innerHTML = 'Copied!';
        setTimeout(() => {
          btn.innerHTML = originalText;
        }, 2000);
      }).catch(err => {
        console.error('Failed to copy URL: ', err);
        alert('Failed to copy URL to clipboard');
      });
    }
    
    // Update the nautical mile scale based on current map zoom level
    function updateNauticalScale() {
      const scaleLabel = document.getElementById('scale-label');
      const scalePx = 100; // Width of scale bar in pixels
      const center = map.getCenter();
      const point = map.latLngToContainerPoint(center);
      const pointX = L.point(point.x + scalePx, point.y);
      const latLngX = map.containerPointToLatLng(pointX);
      const distanceMeters = center.distanceTo(latLngX);
      const distanceNM = distanceMeters / 1852; // Convert meters to nautical miles
      scaleLabel.textContent = `${Math.round(distanceNM)} NM`;
    }
    
    // Date range navigation variables
    let currentFromDate = null;
    let currentToDate = null;
    let dateRangeStepSize = 'hour'; // 'hour' or 'day'
    let showDayNavigation = false; // Flag to show/hide day navigation
    let cachedReceivers = null; // Cache receivers to avoid fetching on every time step
    let lastNavigationType = 'hour'; // Track which navigation type was last used ('hour' or 'day')
    
    // Replay functionality
    let replayData = [];
    let replayIndex = 0;
    let replayInterval = null;
    let isReplaying = false;
    let replayReceivers = null; // Store receivers data for replay
    
    // Fetch replay data for day (hourly for past 24 hours)
    async function fetchDayReplayData() {
      showGlobalLoading();
      const receiverId = document.getElementById('receiver-select').value;
      
      try {
        // Create array to store data for each hour
        const hourlyData = [];
        const now = new Date();
        
        // Get data for each hour in the past 24 hours
        for (let i = 0; i < 24; i++) {
          // Create date for current hour and set to exact hour (09:00:00)
          const hourDate = new Date(now);
          hourDate.setHours(now.getHours() - i);
          hourDate.setMinutes(0);
          hourDate.setSeconds(0);
          hourDate.setMilliseconds(0);
          
          // Create from date (previous hour, also on the hour)
          const fromDate = new Date(hourDate);
          fromDate.setHours(hourDate.getHours() - 1);
          
          // Format dates for API
          const fromFormatted = formatDateForAPI(fromDate);
          const toFormatted = formatDateForAPI(hourDate);
          
          // Build URL
          let url = `/statistics/stats/coverage-map?from=${fromFormatted}&to=${toFormatted}`;
          if (receiverId) {
            url += `&receiver_id=${receiverId}`;
          }
          
          // Fetch data for this hour
          const data = await fetch(url).then(r => r.json());
          
          // Add to hourly data with timestamp
          hourlyData.push({
            timestamp: hourDate,
            data: data,
            label: `${hourDate.toLocaleTimeString()}`
          });
        }
        
        // Reverse so we go from oldest to newest
        replayData = hourlyData.reverse();
        
        // Start replay if we have data
        if (replayData.length > 0) {
          startReplay();
        } else {
          alert('No data available for replay');
        }
      } catch (e) {
        console.error('Failed to fetch replay data:', e);
        alert('Failed to fetch replay data. Please try again later.');
      } finally {
        hideGlobalLoading();
      }
    }
    
    // Fetch replay data for week (daily for past 7 days)
    async function fetchWeekReplayData() {
      showGlobalLoading();
      const receiverId = document.getElementById('receiver-select').value;
      
      try {
        // Create array to store data for each day
        const dailyData = [];
        const now = new Date();
        
        // Get data for each day in the past 7 days
        for (let i = 0; i < 7; i++) {
          // Create date for current day and set to midnight
          const dayDate = new Date(now);
          dayDate.setDate(now.getDate() - i);
          
          // Set to start of day (00:00:00)
          dayDate.setHours(0, 0, 0, 0);
          
          // Create from and to dates for the full day
          const fromDate = new Date(dayDate);
          const toDate = new Date(dayDate);
          toDate.setHours(23, 0, 0, 0); // Use 23:00:00 instead of 23:59:59 for better cache hits
          
          // Format dates for API
          const fromFormatted = formatDateForAPI(fromDate);
          const toFormatted = formatDateForAPI(toDate);
          
          // Build URL
          let url = `/statistics/stats/coverage-map?from=${fromFormatted}&to=${toFormatted}`;
          if (receiverId) {
            url += `&receiver_id=${receiverId}`;
          }
          
          // Fetch data for this day
          const data = await fetch(url).then(r => r.json());
          
          // Add to daily data with timestamp
          dailyData.push({
            timestamp: dayDate,
            data: data,
            label: `${dayDate.toLocaleDateString()}`
          });
        }
        
        // Reverse so we go from oldest to newest
        replayData = dailyData.reverse();
        
        // Start replay if we have data
        if (replayData.length > 0) {
          startReplay();
        } else {
          alert('No data available for replay');
        }
      } catch (e) {
        console.error('Failed to fetch replay data:', e);
        alert('Failed to fetch replay data. Please try again later.');
      } finally {
        hideGlobalLoading();
      }
    }
    
    // Variables for replay state
    let originalData = null; // Store original data to restore after replay
    let isPaused = false;
    
    // Start replay of data
    function startReplay() {
      // If already replaying, stop it first
      if (isReplaying) {
        stopReplay();
      }
      
      // Store current data to restore after replay
      storeOriginalState();
      
      // Reset index
      replayIndex = 0;
      isReplaying = true;
      isPaused = false;
      
      // Fetch receivers once at the start of replay
      const receiverId = document.getElementById('receiver-select').value;
      if (receiverId) {
        fetch('/receivers').then(r => r.json()).then(receivers => {
          replayReceivers = receivers;
        });
      }
      
      // Show controls and info
      document.getElementById('replay-controls').style.display = 'flex !important';
      document.getElementById('replay-controls').setAttribute('style', 'display: flex !important');
      document.getElementById('replay-info').style.display = 'block';
      document.getElementById('replay-datetime-overlay').style.display = 'block';
      
      // Hide CSV buttons during replay
      updateCSVButtonsVisibility();
      
      // Set button states (keep day/week buttons enabled)
      document.getElementById('replay-pause-btn').style.display = 'inline-block';
      document.getElementById('replay-play-btn').style.display = 'none';
      
      // Calculate time per frame (total 10 seconds divided by number of frames)
      const timePerFrame = 10000 / replayData.length;
      
      // Update map with first frame
      updateMapWithReplayFrame(0);
      
      // Start interval for replay
      replayInterval = setInterval(() => {
        if (isPaused) return;
        
        replayIndex++;
        
        // Update progress bar
        updateProgressBar();
        
        // Update map with current frame
        updateMapWithReplayFrame(replayIndex);
        
        // Check if we're done
        if (replayIndex >= replayData.length - 1) {
          pauseReplay(); // Pause at the end
          
          // After a delay, reset to original state
          setTimeout(() => {
            if (isReplaying) { // Only if we haven't manually stopped
              restoreOriginalState();
            }
          }, 3000);
        }
      }, timePerFrame);
    }
    
    // Update progress bar
    function updateProgressBar() {
      const progress = (replayIndex / (replayData.length - 1)) * 100;
      document.getElementById('replay-progress-bar').style.width = `${progress}%`;
    }
    
    // Pause replay
    function pauseReplay() {
      isPaused = true;
      document.getElementById('replay-pause-btn').style.display = 'none';
      document.getElementById('replay-play-btn').style.display = 'inline-block';
    }
    
    // Resume replay
    function resumeReplay() {
      isPaused = false;
      document.getElementById('replay-pause-btn').style.display = 'inline-block';
      document.getElementById('replay-play-btn').style.display = 'none';
    }
    
    // Go to previous frame
    function previousFrame() {
      if (replayIndex > 0) {
        replayIndex--;
        updateProgressBar();
        updateMapWithReplayFrame(replayIndex);
      }
    }
    
    // Go to next frame
    function nextFrame() {
      if (replayIndex < replayData.length - 1) {
        replayIndex++;
        updateProgressBar();
        updateMapWithReplayFrame(replayIndex);
      }
    }
    
    // Store original state to restore after replay
    function storeOriginalState() {
      // Store current map state
      originalData = {
        receiverId: document.getElementById('receiver-select').value,
        isDateRange: document.getElementById('dateRangeRadio').checked,
        days: document.getElementById('days-select').value,
        fromDate: document.getElementById('from-date').value,
        toDate: document.getElementById('to-date').value
      };
    }
    
    // Restore original state after replay
    function restoreOriginalState() {
      if (!originalData) return;
      
      // Reload the original data
      loadCoverageData();
      
      // Hide replay elements
      document.getElementById('replay-datetime-overlay').style.display = 'none';
    }
    
    // Stop replay
    function stopReplay() {
      if (replayInterval) {
        clearInterval(replayInterval);
        replayInterval = null;
      }
      
      isReplaying = false;
      isPaused = false;
      replayReceivers = null; // Clear stored receivers when stopping replay
      
      // Hide controls and info
      document.getElementById('replay-controls').setAttribute('style', 'display: none !important');
      document.getElementById('replay-info').style.display = 'none';
      document.getElementById('replay-datetime-overlay').style.display = 'none';
      
      // Show CSV buttons
      updateCSVButtonsVisibility();
      
      // No need to re-enable replay buttons as they're always enabled
      
      // Restore original state
      restoreOriginalState();
    }
    
    // Update map with replay frame
    function updateMapWithReplayFrame(index) {
      if (!replayData[index]) return;
      
      const frameData = replayData[index];
      const heatData = frameData.data.map(point => {
        // Intensity based on logarithmic scale of count, but amplified for better visibility
        const intensity = Math.min(1, Math.log10(point.count + 1) / 2);
        return [point.lat, point.lon, intensity];
      });
      
      // Calculate and display coverage area
      const coverageAreaSqKm = calculateCoverageArea(heatData);
      document.getElementById('coverage-area-text').textContent = `Coverage: ${coverageAreaSqKm} sq km`;
      
      // Update info text
      document.getElementById('replay-info').textContent = `Showing data for: ${frameData.label}`;
      
      // Ensure datetime overlay is visible and update its content
      document.getElementById('replay-datetime-overlay').style.display = 'block';
      document.getElementById('replay-datetime-text').textContent = frameData.timestamp instanceof Date ?
        frameData.timestamp.toLocaleString() : frameData.label;
      
      // Clear previous heat layer
      if (heatLayer) {
        map.removeLayer(heatLayer);
      }
      
      // Create new heat layer
      heatLayer = L.heatLayer(heatData, {
        radius: 20,
        blur: 15,
        maxZoom: 17,
        minOpacity: 0.4,
        gradient: {0.2: 'blue', 0.4: 'cyan', 0.6: 'lime', 0.8: 'yellow', 1: 'red'}
      }).addTo(map);
      
      // Update statistics if we have a receiver selected
      const receiverId = document.getElementById('receiver-select').value;
      if (receiverId && replayReceivers) {
        // Use the already fetched receivers instead of fetching again
        const selectedReceiver = replayReceivers.find(r => r.id === parseInt(receiverId));
        if (selectedReceiver && selectedReceiver.latitude && selectedReceiver.longitude) {
          const receiverLatLng = L.latLng(selectedReceiver.latitude, selectedReceiver.longitude);
          const maxDistance = calculateMaxDistance(receiverLatLng, heatData);
          const stats = calculateCoverageStats(heatData, receiverLatLng, maxDistance);
          updateStatsDisplay(stats, true);
        }
      }
    }
    
    // Function to generate and download CSV
    function downloadCSV(data, filename) {
      // Create CSV content
      const csvContent = "data:text/csv;charset=utf-8," + data;
      
      // Create download link
      const encodedUri = encodeURI(csvContent);
      const link = document.createElement("a");
      link.setAttribute("href", encodedUri);
      link.setAttribute("download", filename);
      document.body.appendChild(link);
      
      // Trigger download
      link.click();
      
      // Clean up
      document.body.removeChild(link);
    }
    
    // Generate raw data CSV
    function generateDataCSV() {
      if (isReplaying) return; // Don't allow during replay
      
      // Get current data
      const receiverId = document.getElementById('receiver-select').value;
      const isDateRange = document.getElementById('dateRangeRadio').checked;
      let url;
      
      if (isDateRange) {
        const fromDate = document.getElementById('from-date').value;
        const toDate = document.getElementById('to-date').value;
        
        try {
          const fromDateObj = new Date(fromDate);
          const toDateObj = new Date(toDate);
          url = `/statistics/stats/coverage-map?from=${formatDateForAPI(fromDateObj)}&to=${formatDateForAPI(toDateObj)}`;
          if (receiverId) {
            url += `&receiver_id=${receiverId}`;
          }
        } catch (e) {
          console.error('Date formatting error:', e);
          alert('Invalid date format. Please check your date inputs.');
          return;
        }
      } else {
        const days = document.getElementById('days-select').value;
        url = `/statistics/stats/coverage-map?days=${days}`;
        if (receiverId) {
          url += `&receiver_id=${receiverId}`;
        }
      }
      
      // Add CSV format parameter
      url += '&format=csv';
      
      // Fetch data and download
      fetch(url)
        .then(response => response.text())
        .then(data => {
          downloadCSV(data, 'coverage_data.csv');
        })
        .catch(error => {
          console.error('Error fetching CSV data:', error);
          alert('Failed to download CSV data');
        });
    }
    
    // Generate table CSV from current statistics
    function generateTableCSV() {
      if (isReplaying) return; // Don't allow during replay
      
      // Check if stats are displayed
      if (document.getElementById('coverage-stats').style.display === 'none') {
        alert('No statistics available to export');
        return;
      }
      
      let csvContent = 'Category,Range,Count,Percentage\n';
      
      // Get distance stats
      const distanceRows = document.getElementById('distance-stats').querySelectorAll('tr');
      distanceRows.forEach(row => {
        const cells = row.querySelectorAll('td');
        if (cells.length === 3) {
          csvContent += `Distance,${cells[0].textContent},${cells[1].textContent},${cells[2].textContent}\n`;
        }
      });
      
      // Get direction stats if available
      const directionRows = document.getElementById('direction-stats').querySelectorAll('tr');
      directionRows.forEach(row => {
        const cells = row.querySelectorAll('td');
        if (cells.length === 3) {
          csvContent += `Direction,${cells[0].textContent},${cells[1].textContent},${cells[2].textContent}\n`;
        }
      });
      
      // Download the CSV
      downloadCSV(csvContent, 'coverage_statistics.csv');
    }
    
    // Update CSV button visibility based on replay state
    function updateCSVButtonsVisibility() {
      const buttons = document.getElementById('csv-buttons');
      if (isReplaying) {
        buttons.style.display = 'none';
      } else {
        buttons.style.display = 'block';
      }
    }
    
    // Function to update receiver visibility
    function updateReceiverVisibility() {
      // Get current state of checkbox
      showReceivers = document.getElementById('show-receivers-checkbox').checked;
      
      // Clear all receiver markers
      map.eachLayer(function(layer) {
        if (layer instanceof L.Marker || layer instanceof L.Tooltip) {
          if (layer._icon && layer._icon.className.includes('receiver-marker') ||
              layer.options && layer.options.className === 'receiver-tooltip') {
            map.removeLayer(layer);
          }
        }
      });
      
      // Clear range circles and labels when receivers are hidden
      if (!showReceivers) {
        // Remove range circles
        rangeCircles.forEach(circle => {
          if (circle) map.removeLayer(circle);
        });
        rangeCircles = [];
        
        // Remove range labels
        rangeLabels.forEach(label => {
          if (label) map.removeLayer(label);
        });
        rangeLabels = [];
      }
      
      // If receivers should be shown, add them back
      if (showReceivers) {
        // Reload the map data to add receivers back
        loadCoverageData();
      }
    }
    
    // Initialize
    document.addEventListener('DOMContentLoaded', async () => {
      // Add event listeners
      document.getElementById('copy-link-btn').addEventListener('click', copyLinkToClipboard);
      
      // Add event listeners for replay controls
      document.getElementById('replay-day-btn').addEventListener('click', fetchDayReplayData);
      document.getElementById('replay-week-btn').addEventListener('click', fetchWeekReplayData);
      document.getElementById('replay-prev-btn').addEventListener('click', previousFrame);
      document.getElementById('replay-next-btn').addEventListener('click', nextFrame);
      document.getElementById('replay-pause-btn').addEventListener('click', pauseReplay);
      document.getElementById('replay-play-btn').addEventListener('click', resumeReplay);
      document.getElementById('replay-stop-btn').addEventListener('click', stopReplay);
      
      // Add event listener for receivers checkbox
      document.getElementById('show-receivers-checkbox').addEventListener('change', updateReceiverVisibility);
      
      // Add event listeners for CSV buttons
      document.getElementById('data-csv-btn').addEventListener('click', generateDataCSV);
      document.getElementById('table-csv-btn').addEventListener('click', generateTableCSV);
      
      // Initialize CSV buttons visibility
      updateCSVButtonsVisibility();
      
      // Set up date range toggle
      document.getElementById('fixedWindowRadio').addEventListener('change', function() {
        toggleTimeRangeType(true); // Trigger update when switching to fixed window
      });
      document.getElementById('dateRangeRadio').addEventListener('change', function() {
        toggleTimeRangeType(false); // Don't trigger update when switching to date range
      });
      
      // Set default values for date inputs (today and yesterday)
      const today = new Date();
      const yesterday = new Date();
      yesterday.setDate(yesterday.getDate() - 1);
      
      // Format dates for datetime-local input (YYYY-MM-DDThh:mm)
      const formatDateForInput = (date) => {
        return date.toISOString().slice(0, 16);
      };
      
      document.getElementById('to-date').value = formatDateForInput(today);
      document.getElementById('from-date').value = formatDateForInput(yesterday);
      
      // Add event listeners for date inputs - only validate, don't trigger update
      document.getElementById('from-date').addEventListener('change', function() {
        validateDateRange(
          document.getElementById('from-date').value,
          document.getElementById('to-date').value
        );
      });
      
      document.getElementById('to-date').addEventListener('change', function() {
        validateDateRange(
          document.getElementById('from-date').value,
          document.getElementById('to-date').value
        );
      });
      
      // Add event listener for the Go button
      document.getElementById('date-range-go').addEventListener('click', function() {
        if (validateDateRange(
          document.getElementById('from-date').value,
          document.getElementById('to-date').value
        )) {
          updateURL();
          loadCoverageData();
        }
      });
      
      // Update URL and load data when selections change
      document.getElementById('receiver-select').addEventListener('change', function() {
        updateURL();
        loadCoverageData();
      });
      
      document.getElementById('days-select').addEventListener('change', function() {
        updateURL();
        loadCoverageData();
      });
      
      // Load receivers
      await loadReceivers();
      
      // Check for query parameters and load map
      const params = getQueryParams();
      
      // Set the dropdown values to match query parameters if available
      if (params.receiverId) {
        document.getElementById('receiver-select').value = params.receiverId;
      }
      
      // Check if we have from/to parameters
      if (params.from && params.to) {
        try {
          const fromDate = new Date(params.from);
          const toDate = new Date(params.to);
          
          // Switch to date range mode
          document.getElementById('dateRangeRadio').checked = true;
          document.getElementById('fixedWindowRadio').checked = false;
          toggleTimeRangeType(false); // Don't trigger update yet
          
          // Set the date inputs
          document.getElementById('from-date').value = formatDateForInput(fromDate);
          document.getElementById('to-date').value = formatDateForInput(toDate);
          
          // Load the coverage map
          loadCoverageData();
        } catch (e) {
          console.error('Error parsing date parameters:', e);
          // Fall back to days parameter
          if (params.days) {
            document.getElementById('days-select').value = params.days;
            loadCoverageData();
          }
        }
      } else if (params.days) {
        // Use days parameter
        document.getElementById('days-select').value = params.days;
        loadCoverageData();
      } else {
        // If no parameters, show an initial loading state
        showMapLoading();
        setTimeout(() => hideMapLoading(), 500); // Hide after a short delay if no data is loaded
      }
      
      // Add event listeners for replay buttons
      document.getElementById('replay-day-btn').addEventListener('click', fetchDayReplayData);
      document.getElementById('replay-week-btn').addEventListener('click', fetchWeekReplayData);
      
      // Add event listeners for date range navigation
      document.getElementById('date-range-prev-hour-btn').addEventListener('click', stepToPreviousHour);
      document.getElementById('date-range-next-hour-btn').addEventListener('click', stepToNextHour);
      document.getElementById('date-range-prev-day-btn').addEventListener('click', stepToPreviousDay);
      document.getElementById('date-range-next-day-btn').addEventListener('click', stepToNextDay);
      
      // Update the scale whenever the map is zoomed or moved
      map.on('zoomend moveend', updateNauticalScale);
      // Call once to set the initial scale
      updateNauticalScale();
    });
  </script>
</body>
</html>