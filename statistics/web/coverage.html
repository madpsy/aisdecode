<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Coverage Map</title>
  
  <!-- Bootstrap 5 CSS -->
  <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/css/bootstrap.min.css" rel="stylesheet">
  <!-- Leaflet CSS -->
  <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" integrity="sha256-p4NxAoJBhIIN+hmNHrzRCf9tD/miZyoHS5obTRR9BMY=" crossorigin=""/>
  <!-- Leaflet Heat plugin -->
  <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js" integrity="sha256-20nQCchB9co0qIjJZRGuk2/Z9VM+kNiyxNV1lvTlZBo=" crossorigin=""></script>
  <script src="https://unpkg.com/leaflet.heat@0.2.0/dist/leaflet-heat.js"></script>
  
  <style>
    body {
      background-color: #f8f9fa;
      padding: 2rem;
      font-family: sans-serif;
    }
    h1 {
      color: #343a40;
      margin-bottom: 1.5rem;
    }
    .card {
      box-shadow: 0 2px 6px rgba(0,0,0,0.1);
      margin-bottom: 2rem;
    }
    #coverage-map {
      height: 600px;
      width: 100%;
      border-radius: 5px;
    }
    .controls {
      margin-bottom: 1rem;
    }
    .receiver-tooltip {
      background-color: rgba(255, 255, 255, 0.9);
      border: none;
      box-shadow: 0 1px 3px rgba(0,0,0,0.3);
      padding: 3px 8px;
      border-radius: 4px;
      font-size: 12px;
      font-weight: bold;
      white-space: nowrap;
    }
    /* Loading overlay styles */
    .loading-overlay {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background-color: rgba(255, 255, 255, 0.8);
      display: flex;
      justify-content: center;
      align-items: center;
      z-index: 10;
      font-size: 1.2rem;
      font-weight: bold;
      color: #666;
      display: none; /* Hidden by default */
    }
    .loading-spinner {
      border: 4px solid #f3f3f3;
      border-top: 4px solid #3498db;
      border-radius: 50%;
      width: 30px;
      height: 30px;
      animation: spin 1s linear infinite;
      margin-right: 10px;
    }
    @keyframes spin {
      0% { transform: rotate(0deg); }
      100% { transform: rotate(360deg); }
    }
    /* Global loading overlay */
    .global-loading-overlay {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background-color: rgba(255, 255, 255, 0.9);
      display: none;
      justify-content: center;
      align-items: center;
      z-index: 1000; /* Higher than other elements */
      flex-direction: column;
    }
    .global-loading-spinner {
      border: 6px solid #f3f3f3;
      border-top: 6px solid #3498db;
      border-radius: 50%;
      width: 60px;
      height: 60px;
      animation: spin 1.5s linear infinite;
      margin-bottom: 20px;
    }
    .global-loading-text {
      font-size: 1.5rem;
      font-weight: bold;
      color: #333;
    }
  </style>
</head>
<body>
  <!-- Global loading overlay -->
  <div class="global-loading-overlay" id="globalLoadingOverlay">
    <div class="global-loading-spinner"></div>
    <div class="global-loading-text">Loading data...</div>
  </div>

  <div class="container-fluid">
    <div class="d-flex justify-content-between align-items-center mb-3">
      <h1>Coverage Map</h1>
      <button id="copy-link-btn" class="btn btn-outline-secondary">
        <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" class="bi bi-link-45deg" viewBox="0 0 16 16">
          <path d="M4.715 6.542 3.343 7.914a3 3 0 1 0 4.243 4.243l1.828-1.829A3 3 0 0 0 8.586 5.5L8 6.086a1.002 1.002 0 0 0-.154.199 2 2 0 0 1 .861 3.337L6.88 11.45a2 2 0 1 1-2.83-2.83l.793-.792a4.018 4.018 0 0 1-.128-1.287z"/>
          <path d="M6.586 4.672A3 3 0 0 0 7.414 9.5l.775-.776a2 2 0 0 1-.896-3.346L9.12 3.55a2 2 0 1 1 2.83 2.83l-.793.792c.112.42.155.855.128 1.287l1.372-1.372a3 3 0 1 0-4.243-4.243L6.586 4.672z"/>
        </svg>
        Copy Link
      </button>
    </div>
    
    <div class="card">
      <div class="card-body">
        <div class="controls row">
          <div class="col-md-6">
            <label for="receiver-select" class="form-label">Receiver:</label>
            <select id="receiver-select" class="form-select">
              <option value="" selected>All</option>
              <!-- Receivers will be loaded dynamically -->
            </select>
          </div>
          <div class="col-md-6">
            <div class="mb-2">
              <label class="form-label">Select time range:</label>
              <div class="form-check">
                <input class="form-check-input" type="radio" name="timeRangeType" id="fixedWindowRadio" value="fixed" checked>
                <label class="form-check-label" for="fixedWindowRadio">
                  Fixed time window
                </label>
              </div>
              <div class="form-check">
                <input class="form-check-input" type="radio" name="timeRangeType" id="dateRangeRadio" value="dateRange">
                <label class="form-check-label" for="dateRangeRadio">
                  Custom date range
                </label>
              </div>
            </div>
            
            <!-- Fixed time window -->
            <div id="fixedWindowContainer">
              <label for="days-select" class="form-label">Time window:</label>
              <select id="days-select" class="form-select">
                <option value="1" selected>1 day</option>
                <option value="2">2 days</option>
                <option value="7">7 days</option>
                <option value="14">14 days</option>
                <option value="30">30 days</option>
              </select>
            </div>
            
            <!-- Date range -->
            <div id="dateRangeContainer" style="display: none;">
              <div class="row">
                <div class="col-md-6">
                  <label for="from-date" class="form-label">From:</label>
                  <input type="datetime-local" id="from-date" class="form-control">
                </div>
                <div class="col-md-6">
                  <label for="to-date" class="form-label">To:</label>
                  <input type="datetime-local" id="to-date" class="form-control">
                </div>
              </div>
              <div class="mt-2">
                <button id="date-range-go" class="btn btn-primary">Go</button>
                <div id="date-range-error" class="text-danger mt-2" style="display: none;"></div>
              </div>
            </div>
          </div>
        </div>
        
        <div id="coverage-map" style="position: relative;">
          <!-- Loading overlay for map -->
          <div class="loading-overlay" id="mapLoadingOverlay">
            <div class="loading-spinner"></div>
            <span>Loading...</span>
          </div>
          <!-- Date/Time overlay for replay -->
          <div id="replay-datetime-overlay" style="
            position: absolute;
            bottom: 10px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(255, 255, 255, 0.8);
            padding: 5px 10px;
            border-radius: 5px;
            z-index: 1000;
            font-family: Arial, sans-serif;
            font-size: 14px;
            font-weight: bold;
            display: none;
          ">
            <span id="replay-datetime-text"></span>
          </div>
          <!-- Receivers toggle checkbox -->
          <div style="
            position: absolute;
            top: 10px;
            right: 10px;
            background: rgba(255, 255, 255, 0.8);
            padding: 5px 10px;
            border-radius: 5px;
            z-index: 1000;
            font-family: Arial, sans-serif;
            font-size: 14px;
          ">
            <div class="form-check">
              <input class="form-check-input" type="checkbox" id="show-receivers-checkbox" checked>
              <label class="form-check-label" for="show-receivers-checkbox">
                Receivers
              </label>
            </div>
          </div>
          <!-- Nautical Mile Scale -->
          <div id="nm-scale" style="
            position: absolute;
            top: 20px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(255, 255, 255, 0.8);
            padding: 5px 10px;
            border-radius: 5px;
            z-index: 1100;
            font-family: Arial, sans-serif;
            font-size: 12px;
            text-align: center;
          ">
          <div id="scale-bar" style="
            position: relative;
            width: 100px;
            height: 4px;
            background: black;
            margin-bottom: 2px;
          ">
            <!-- Left tick -->
            <div style="
              position: absolute;
              left: 0;
              top: -4px;
              width: 2px;
              height: 12px;
              background: black;
            "></div>
            <!-- Right tick -->
            <div style="
              position: absolute;
              right: 0;
              top: -4px;
              width: 2px;
              height: 12px;
              background: black;
            "></div>
          </div>
            <div id="scale-label">0 NM</div>
          </div>
        </div>
        
        <!-- Replay Section -->
        <div class="mt-4 mb-3">
          <h4>Replay</h4>
          <div class="btn-group mb-2">
            <button id="replay-day-btn" class="btn btn-outline-primary">Day</button>
            <button id="replay-week-btn" class="btn btn-outline-primary">Week</button>
          </div>
          <div class="d-flex align-items-center mt-2" id="replay-controls" style="display: none !important;">
            <div class="btn-group me-3">
              <button id="replay-prev-btn" class="btn btn-sm btn-outline-secondary">
                <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" class="bi bi-skip-backward-fill" viewBox="0 0 16 16">
                  <path d="M.5 3.5A.5.5 0 0 0 0 4v8a.5.5 0 0 0 1 0V8.753l6.267 3.636c.54.313 1.233-.066 1.233-.697v-2.94l6.267 3.636c.54.314 1.233-.065 1.233-.696V4.308c0-.63-.693-1.01-1.233-.696L8.5 7.248v-2.94c0-.63-.692-1.01-1.233-.696L1 7.248V4a.5.5 0 0 0-.5-.5z"/>
                </svg>
              </button>
              <button id="replay-pause-btn" class="btn btn-sm btn-outline-secondary">
                <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" class="bi bi-pause" viewBox="0 0 16 16">
                  <path d="M6 3.5a.5.5 0 0 1 .5.5v8a.5.5 0 0 1-1 0V4a.5.5 0 0 1 .5-.5zm4 0a.5.5 0 0 1 .5.5v8a.5.5 0 0 1-1 0V4a.5.5 0 0 1 .5-.5z"/>
                </svg>
              </button>
              <button id="replay-play-btn" class="btn btn-sm btn-outline-secondary" style="display: none;">
                <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" class="bi bi-play" viewBox="0 0 16 16">
                  <path d="M10.804 8 5 4.633v6.734L10.804 8zm.792-.696a.802.802 0 0 1 0 1.392l-6.363 3.692C4.713 12.69 4 12.345 4 11.692V4.308c0-.653.713-.998 1.233-.696l6.363 3.692z"/>
                </svg>
              </button>
              <button id="replay-next-btn" class="btn btn-sm btn-outline-secondary">
                <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" class="bi bi-skip-forward" viewBox="0 0 16 16">
                  <path d="M15.5 3.5a.5.5 0 0 1 .5.5v8a.5.5 0 0 1-1 0V4a.5.5 0 0 1 .5-.5zM7.596 8.697l-6.363 3.692c-.54.313-1.233-.066-1.233-.697V4.308c0-.63.692-1.01 1.233-.696l6.363 3.692a.802.802 0 0 1 0 1.393z"/>
                  <path d="M11.596 8.697l-6.363 3.692c-.54.313-1.233-.066-1.233-.697V4.308c0-.63.692-1.01 1.233-.696l6.363 3.692a.802.802 0 0 1 0 1.393z"/>
                </svg>
              </button>
              <button id="replay-stop-btn" class="btn btn-sm btn-outline-secondary">
                <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" class="bi bi-stop" viewBox="0 0 16 16">
                  <path d="M3.5 5A1.5 1.5 0 0 1 5 3.5h6A1.5 1.5 0 0 1 12.5 5v6a1.5 1.5 0 0 1-1.5 1.5H5A1.5 1.5 0 0 1 3.5 11V5zM5 4.5a.5.5 0 0 0-.5.5v6a.5.5 0 0 0 .5.5h6a.5.5 0 0 0 .5-.5V5a.5.5 0 0 0-.5-.5H5z"/>
                </svg>
              </button>
            </div>
            <div class="progress flex-grow-1">
              <div id="replay-progress-bar" class="progress-bar" role="progressbar" style="width: 0%"></div>
            </div>
          </div>
          <div id="replay-info" class="mt-2 small text-muted" style="display: none;"></div>
        </div>
        
        <!-- Coverage Statistics Section -->
        <div id="coverage-stats" style="display: none; margin-top: 20px;">
          <h4>Coverage Statistics</h4>
          <div class="row">
            <div class="col-md-6">
              <div class="card">
                <div class="card-header">Messages by Distance</div>
                <div class="card-body">
                  <table class="table table-sm">
                    <thead>
                      <tr>
                        <th>Range</th>
                        <th>Message Count</th>
                        <th>Percentage</th>
                      </tr>
                    </thead>
                    <tbody id="distance-stats">
                      <!-- Will be populated dynamically -->
                    </tbody>
                  </table>
                </div>
              </div>
            </div>
            <div class="col-md-6">
              <div class="card">
                <div class="card-header">Messages by Direction</div>
                <div class="card-body">
                  <table class="table table-sm">
                    <thead>
                      <tr>
                        <th>Direction</th>
                        <th>Message Count</th>
                        <th>Percentage</th>
                      </tr>
                    </thead>
                    <tbody id="direction-stats">
                      <!-- Will be populated dynamically -->
                    </tbody>
                  </table>
                </div>
              </div>
            </div>
          </div>
        </div>
      </div>
    </div>
  </div>
  
  <script>
    // Initialize map
    const map = L.map('coverage-map').setView([51.505, -0.09], 6);
    
    // Add base map layer
    L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
      attribution: '&copy; <a href="https://www.openstreetmap.org/copyright">OpenStreetMap</a> contributors'
    }).addTo(map);
    
    // Map layers that need to be cleared between receiver changes
    let heatLayer = null;
    let receiverMarker = null;
    let receiverTooltip = null;
    let rangeCircles = []; // Array to store the range circles
    let rangeLabels = []; // Array to store the range labels
    let showReceivers = true; // Flag to control receiver marker visibility
    
    // Function to clear all previous map layers
    function clearMapLayers() {
      // Remove heat layer if it exists
      if (heatLayer) {
        map.removeLayer(heatLayer);
        heatLayer = null;
      }
      
      // Remove receiver marker if it exists
      if (receiverMarker) {
        map.removeLayer(receiverMarker);
        receiverMarker = null;
      }
      
      // Remove receiver tooltip if it exists
      if (receiverTooltip) {
        map.removeLayer(receiverTooltip);
        receiverTooltip = null;
      }
      
      // Remove range circles and labels
      rangeCircles.forEach(circle => {
        if (circle) map.removeLayer(circle);
      });
      rangeCircles = [];
      
      rangeLabels.forEach(label => {
        if (label) map.removeLayer(label);
      });
      rangeLabels = [];
    }
    
    // Calculate the maximum distance from the receiver to any point in the heatmap
    function calculateMaxDistance(receiverLatLng, heatData) {
      let maxDistance = 0;
      
      heatData.forEach(point => {
        const pointLatLng = L.latLng(point[0], point[1]);
        const distance = receiverLatLng.distanceTo(pointLatLng);
        if (distance > maxDistance) {
          maxDistance = distance;
        }
      });
      
      return maxDistance; // in meters
    }
    
    // Draw concentric circles around the receiver
    function drawRangeCircles(receiverLatLng, maxDistance) {
      // Clear any existing circles and labels
      rangeCircles.forEach(circle => {
        if (circle) map.removeLayer(circle);
      });
      rangeCircles = [];
      
      rangeLabels.forEach(label => {
        if (label) map.removeLayer(label);
      });
      rangeLabels = [];
      
      // Create 3 equally spaced circles
      for (let i = 1; i <= 3; i++) {
        const radiusMeters = maxDistance * i / 3;
        const radiusNM = Math.round(radiusMeters / 1852); // Convert meters to nautical miles and round to nearest whole number
        
        // Create circle
        const circle = L.circle(receiverLatLng, {
          radius: radiusMeters,
          color: '#3388ff',
          fillColor: 'transparent',
          weight: 1.5,
          opacity: 0.7,
          dashArray: '5, 5' // Make the circles dashed
        }).addTo(map);
        
        rangeCircles.push(circle);
        
        // Calculate position for the label (east of the center)
        const labelLatLng = calculateLabelPosition(receiverLatLng, radiusMeters);
        
        // Create label
        const label = L.tooltip({
          permanent: true,
          direction: 'center',
          className: 'receiver-tooltip'
        })
        .setLatLng(labelLatLng)
        .setContent(`${radiusNM} NM`)
        .addTo(map);
        
        rangeLabels.push(label);
      }
    }
    
    // Calculate position for range label (east of center)
    function calculateLabelPosition(center, radiusMeters) {
      // Convert radius from meters to degrees longitude (approximate)
      // This is a simplified calculation that works for small distances
      const radiusLng = radiusMeters / (111320 * Math.cos(center.lat * Math.PI / 180));
      
      // Position the label to the east of the center
      return L.latLng(center.lat, center.lng + radiusLng);
    }
    
    // Calculate bearing between two points
    function calculateBearing(lat1, lon1, lat2, lon2) {
      const toRad = value => value * Math.PI / 180;
      const toDeg = value => value * 180 / Math.PI;
      
      const dLon = toRad(lon2 - lon1);
      const y = Math.sin(dLon) * Math.cos(toRad(lat2));
      const x = Math.cos(toRad(lat1)) * Math.sin(toRad(lat2)) -
                Math.sin(toRad(lat1)) * Math.cos(toRad(lat2)) * Math.cos(dLon);
      let bearing = toDeg(Math.atan2(y, x));
      
      // Normalize to 0-360
      bearing = (bearing + 360) % 360;
      return bearing;
    }
    
    // Convert bearing to cardinal direction
    function bearingToDirection(bearing) {
      const directions = ['N', 'NE', 'E', 'SE', 'S', 'SW', 'W', 'NW'];
      return directions[Math.round(bearing / 45) % 8];
    }
    
    // Calculate coverage statistics
    function calculateCoverageStats(heatData, receiverLatLng, maxDistance) {
      if (!receiverLatLng) return null;
      
      // Initialize statistics objects
      const distanceStats = {
        ring1: 0,
        ring2: 0,
        ring3: 0,
        beyond: 0
      };
      
      const directionStats = {
        'N': 0, 'NE': 0, 'E': 0, 'SE': 0,
        'S': 0, 'SW': 0, 'W': 0, 'NW': 0
      };
      
      let totalPoints = 0;
      
      // Calculate ring boundaries
      const ring1 = maxDistance / 3;
      const ring2 = maxDistance * 2 / 3;
      const ring3 = maxDistance;
      
      // Process each point
      heatData.forEach(point => {
        const pointLatLng = L.latLng(point[0], point[1]);
        const distance = receiverLatLng.distanceTo(pointLatLng);
        const bearing = calculateBearing(
          receiverLatLng.lat, receiverLatLng.lng,
          pointLatLng.lat, pointLatLng.lng
        );
        const direction = bearingToDirection(bearing);
        
        // Count by distance
        if (distance <= ring1) {
          distanceStats.ring1++;
        } else if (distance <= ring2) {
          distanceStats.ring2++;
        } else if (distance <= ring3) {
          distanceStats.ring3++;
        } else {
          distanceStats.beyond++;
        }
        
        // Count by direction
        directionStats[direction]++;
        
        totalPoints++;
      });
      
      return {
        distanceStats,
        directionStats,
        totalPoints,
        rings: {
          ring1: ring1,
          ring2: ring2,
          ring3: ring3
        }
      };
    }
    
    // Update the statistics display
    function updateStatsDisplay(stats, showDirectionStats) {
      const statsContainer = document.getElementById('coverage-stats');
      const distanceStatsTable = document.getElementById('distance-stats');
      const directionStatsTable = document.getElementById('direction-stats');
      const directionStatsCard = directionStatsTable.closest('.card').parentElement;
      
      if (!stats) {
        statsContainer.style.display = 'none';
        return;
      }
      
      // Show the stats container
      statsContainer.style.display = 'block';
      
      // Show/hide direction stats based on parameter
      directionStatsCard.style.display = showDirectionStats ? 'block' : 'none';
      
      // Clear previous stats
      distanceStatsTable.innerHTML = '';
      directionStatsTable.innerHTML = '';
      
      // Format distance stats
      const { distanceStats, directionStats, totalPoints, rings } = stats;
      
      // Add distance stats rows
      const ring1NM = Math.round(rings.ring1 / 1852);
      const ring2NM = Math.round(rings.ring2 / 1852);
      const ring3NM = Math.round(rings.ring3 / 1852);
      
      distanceStatsTable.innerHTML += `
        <tr>
          <td>0 - ${ring1NM} NM</td>
          <td>${distanceStats.ring1}</td>
          <td>${((distanceStats.ring1 / totalPoints) * 100).toFixed(1)}%</td>
        </tr>
        <tr>
          <td>${ring1NM} - ${ring2NM} NM</td>
          <td>${distanceStats.ring2}</td>
          <td>${((distanceStats.ring2 / totalPoints) * 100).toFixed(1)}%</td>
        </tr>
        <tr>
          <td>${ring2NM} - ${ring3NM} NM</td>
          <td>${distanceStats.ring3}</td>
          <td>${((distanceStats.ring3 / totalPoints) * 100).toFixed(1)}%</td>
        </tr>
      `;
      
      // Only add direction stats if we're showing them
      if (showDirectionStats) {
        // Sort directions by count (descending)
        const sortedDirections = Object.entries(directionStats)
          .sort((a, b) => b[1] - a[1]);
        
        // Add direction stats rows
        sortedDirections.forEach(([direction, count]) => {
          if (count > 0) {
            directionStatsTable.innerHTML += `
              <tr>
                <td>${direction}</td>
                <td>${count}</td>
                <td>${((count / totalPoints) * 100).toFixed(1)}%</td>
              </tr>
            `;
          }
        });
      }
    }
    
    // Load receivers
    async function loadReceivers() {
      try {
        const receivers = await fetch('/receivers').then(r => r.json());
        const select = document.getElementById('receiver-select');
        
        // Sort receivers by name
        receivers.sort((a, b) => a.name.localeCompare(b.name));
        
        // Add receivers to dropdown (excluding receiver ID 0)
        receivers.forEach(receiver => {
          // Skip receiver ID 0
          if (receiver.id === 0) return;
          
          const option = document.createElement('option');
          option.value = receiver.id;
          option.textContent = receiver.name;
          select.appendChild(option);
        });
      } catch (e) {
        console.error('Failed to load receivers:', e);
        alert('Failed to load receivers. Please try again later.');
      }
    }
    
    // Show global loading overlay
    function showGlobalLoading() {
      document.getElementById('globalLoadingOverlay').style.display = 'flex';
    }
    
    // Hide global loading overlay
    function hideGlobalLoading() {
      document.getElementById('globalLoadingOverlay').style.display = 'none';
    }
    
    // Show map loading overlay
    function showMapLoading() {
      document.getElementById('mapLoadingOverlay').style.display = 'flex';
    }
    
    // Hide map loading overlay
    function hideMapLoading() {
      document.getElementById('mapLoadingOverlay').style.display = 'none';
    }
    
    // Validate date range doesn't exceed 30 days
    function validateDateRange(fromDate, toDate) {
      if (!fromDate || !toDate) return false;
      
      const from = new Date(fromDate);
      const to = new Date(toDate);
      
      if (isNaN(from.getTime()) || isNaN(to.getTime())) return false;
      
      // Check if from date is before to date
      if (from > to) {
        document.getElementById('date-range-error').textContent = 'From date must be before To date';
        document.getElementById('date-range-error').style.display = 'block';
        return false;
      }
      
      // Calculate difference in days
      const diffTime = Math.abs(to - from);
      const diffDays = Math.ceil(diffTime / (1000 * 60 * 60 * 24));
      
      // Check if range exceeds 30 days
      if (diffDays > 30) {
        document.getElementById('date-range-error').textContent = 'Date range cannot exceed 30 days';
        document.getElementById('date-range-error').style.display = 'block';
        return false;
      }
      
      // Hide error message if validation passes
      document.getElementById('date-range-error').style.display = 'none';
      return true;
    }
    
    // Toggle between fixed window and date range
    function toggleTimeRangeType(triggerUpdate = false) {
      const isDateRange = document.getElementById('dateRangeRadio').checked;
      document.getElementById('fixedWindowContainer').style.display = isDateRange ? 'none' : 'block';
      document.getElementById('dateRangeContainer').style.display = isDateRange ? 'block' : 'none';
      
      // For fixed window, trigger update automatically
      // For date range, user will click the Go button
      if (!isDateRange && triggerUpdate) {
        updateURL();
        loadCoverageData();
      }
    }
    
    // Format date for API request (RFC3339 format)
    function formatDateForAPI(date) {
      return date.toISOString();
    }
    
    // Load coverage data
    async function loadCoverageData() {
      const receiverId = document.getElementById('receiver-select').value;
      const isDateRange = document.getElementById('dateRangeRadio').checked;
      
      try {
        // Show loading state
        showGlobalLoading();
        showMapLoading();
        
        let url;
        
        if (isDateRange) {
          const fromDate = document.getElementById('from-date').value;
          const toDate = document.getElementById('to-date').value;
          
          // Validate date range
          if (!validateDateRange(fromDate, toDate)) {
            hideGlobalLoading();
            hideMapLoading();
            return; // Stop if validation fails
          }
          
          try {
            // Format dates for API
            const fromDateObj = new Date(fromDate);
            const toDateObj = new Date(toDate);
            
            // Fetch coverage data with date range
            url = `/statistics/stats/coverage-map?from=${formatDateForAPI(fromDateObj)}&to=${formatDateForAPI(toDateObj)}`;
            if (receiverId) {
              url += `&receiver_id=${receiverId}`;
            }
          } catch (e) {
            console.error('Date formatting error:', e);
            alert('Invalid date format. Please check your date inputs.');
            hideGlobalLoading();
            hideMapLoading();
            return;
          }
        } else {
          const days = document.getElementById('days-select').value;
          
          // Fetch coverage data with days parameter
          url = `/statistics/stats/coverage-map?days=${days}`;
          if (receiverId) {
            url += `&receiver_id=${receiverId}`;
          }
        }
        
        // Update URL with current selections
        updateURL();
        
        const data = await fetch(url).then(r => r.json());
        
        if (data.length === 0) {
          alert('No coverage data available for the selected receiver and time period');
          return;
        }
        
        // Convert data to heatmap format
        const heatData = data.map(point => {
          // Intensity based on logarithmic scale of count, but amplified for better visibility
          // Increase the divisor to make low counts more visible
          const intensity = Math.min(1, Math.log10(point.count + 1) / 2);
          return [point.lat, point.lon, intensity];
        });
        
        // Clear all previous map layers
        clearMapLayers();
        
        // Create new heat layer with improved visibility
        heatLayer = L.heatLayer(heatData, {
          radius: 20,           // Increased from 15
          blur: 15,             // Decreased from 20 for sharper points
          maxZoom: 17,
          minOpacity: 0.4,      // Added minimum opacity
          gradient: {0.2: 'blue', 0.4: 'cyan', 0.6: 'lime', 0.8: 'yellow', 1: 'red'}
        }).addTo(map);
        
        // Load all receivers
        const receivers = await fetch('/receivers').then(r => r.json());
        
        // Create a receiver icon
        const receiverIcon = L.divIcon({
          html: '<div style="background-color: #ff4136; width: 12px; height: 12px; border-radius: 50%; border: 2px solid white;"></div>',
          className: 'receiver-marker',
          iconSize: [12, 12]
        });
        
        // Points for bounds calculation
        const points = heatData.map(p => [p[0], p[1]]);
        
        if (receiverId) {
          // Specific receiver selected
          const selectedReceiver = receivers.find(r => r.id === parseInt(receiverId));
          
          if (selectedReceiver && selectedReceiver.latitude && selectedReceiver.longitude) {
            // Add marker with popup and store reference if receivers should be shown
            if (showReceivers) {
              receiverMarker = L.marker([selectedReceiver.latitude, selectedReceiver.longitude], {icon: receiverIcon})
                .addTo(map)
                .bindPopup(`<b>Receiver:</b> ${selectedReceiver.name}`);
              
              // Add permanent tooltip with receiver name and store reference
              receiverTooltip = L.tooltip({
                permanent: true,
                direction: 'top',
                className: 'receiver-tooltip',
                offset: [0, -10]
              })
              .setContent(`<b>${selectedReceiver.name}</b>`)
              .setLatLng([selectedReceiver.latitude, selectedReceiver.longitude])
              .addTo(map);
            }
            
            // Calculate maximum distance and draw range circles
            const receiverLatLng = L.latLng(selectedReceiver.latitude, selectedReceiver.longitude);
            const maxDistance = calculateMaxDistance(receiverLatLng, heatData);
            drawRangeCircles(receiverLatLng, maxDistance);
            
            // Add receiver location to points for bounds calculation
            points.push([selectedReceiver.latitude, selectedReceiver.longitude]);
          }
        } else {
          // "All" receivers selected - show markers for all receivers but no range circles
          receivers.forEach(receiver => {
            if (receiver.latitude && receiver.longitude) {
              // Add receiver location to points for bounds calculation
              points.push([receiver.latitude, receiver.longitude]);
              
              // Only add markers if receivers should be shown
              if (showReceivers) {
                // Add marker with popup
                L.marker([receiver.latitude, receiver.longitude], {icon: receiverIcon})
                  .addTo(map)
                  .bindPopup(`<b>Receiver:</b> ${receiver.name}`);
                
                // Add tooltip with receiver name
                L.tooltip({
                  permanent: true,
                  direction: 'top',
                  className: 'receiver-tooltip',
                  offset: [0, -10]
                })
                .setContent(`<b>${receiver.name}</b>`)
                .setLatLng([receiver.latitude, receiver.longitude])
                .addTo(map);
              }
            }
          });
        }
        
        // Fit bounds to include all points (heatmap + receivers)
        const bounds = L.latLngBounds(points);
        map.fitBounds(bounds, { padding: [50, 50] });
        
        // Calculate and display statistics
        if (receiverId) {
          // For specific receiver, show both distance and direction stats
          const selectedReceiver = receivers.find(r => r.id === parseInt(receiverId));
          if (selectedReceiver && selectedReceiver.latitude && selectedReceiver.longitude) {
            const receiverLatLng = L.latLng(selectedReceiver.latitude, selectedReceiver.longitude);
            const maxDistance = calculateMaxDistance(receiverLatLng, heatData);
            const stats = calculateCoverageStats(heatData, receiverLatLng, maxDistance);
            updateStatsDisplay(stats, true); // Show direction stats for specific receiver
          } else {
            updateStatsDisplay(null, false);
          }
        } else {
          // For "All" receivers, don't show direction stats as they wouldn't be meaningful
          updateStatsDisplay(null, false);
        }
      } catch (e) {
        console.error('Failed to load coverage data:', e);
        alert('Failed to load coverage data. Please try again later.');
      } finally {
        // Hide loading overlays
        hideGlobalLoading();
        hideMapLoading();
      }
    }
    
    // Parse URL query parameters
    function getQueryParams() {
      const params = new URLSearchParams(window.location.search);
      return {
        receiverId: params.get('receiver_id'),
        days: params.get('days'),
        from: params.get('from'),
        to: params.get('to')
      };
    }
    
    // Update URL with current selections without reloading the page
    function updateURL() {
      const receiverId = document.getElementById('receiver-select').value;
      const isDateRange = document.getElementById('dateRangeRadio').checked;
      const url = new URL(window.location.href);
      
      if (receiverId) {
        url.searchParams.set('receiver_id', receiverId);
      } else {
        url.searchParams.delete('receiver_id');
      }
      
      if (isDateRange) {
        const fromDate = document.getElementById('from-date').value;
        const toDate = document.getElementById('to-date').value;
        
        if (fromDate && toDate) {
          try {
            const fromDateObj = new Date(fromDate);
            const toDateObj = new Date(toDate);
            
            url.searchParams.set('from', formatDateForAPI(fromDateObj));
            url.searchParams.set('to', formatDateForAPI(toDateObj));
            url.searchParams.delete('days');
          } catch (e) {
            console.error('Error formatting dates for URL:', e);
          }
        }
      } else {
        const days = document.getElementById('days-select').value;
        
        if (days) {
          url.searchParams.set('days', days);
        } else {
          url.searchParams.delete('days');
        }
        
        url.searchParams.delete('from');
        url.searchParams.delete('to');
      }
      
      window.history.replaceState({}, '', url);
    }
    
    // Copy current URL to clipboard
    function copyLinkToClipboard() {
      const url = window.location.href;
      navigator.clipboard.writeText(url).then(() => {
        const btn = document.getElementById('copy-link-btn');
        const originalText = btn.innerHTML;
        btn.innerHTML = 'Copied!';
        setTimeout(() => {
          btn.innerHTML = originalText;
        }, 2000);
      }).catch(err => {
        console.error('Failed to copy URL: ', err);
        alert('Failed to copy URL to clipboard');
      });
    }
    
    // Update the nautical mile scale based on current map zoom level
    function updateNauticalScale() {
      const scaleLabel = document.getElementById('scale-label');
      const scalePx = 100; // Width of scale bar in pixels
      const center = map.getCenter();
      const point = map.latLngToContainerPoint(center);
      const pointX = L.point(point.x + scalePx, point.y);
      const latLngX = map.containerPointToLatLng(pointX);
      const distanceMeters = center.distanceTo(latLngX);
      const distanceNM = distanceMeters / 1852; // Convert meters to nautical miles
      scaleLabel.textContent = `${Math.round(distanceNM)} NM`;
    }
    
    // Replay functionality
    let replayData = [];
    let replayIndex = 0;
    let replayInterval = null;
    let isReplaying = false;
    
    // Fetch replay data for day (hourly for past 24 hours)
    async function fetchDayReplayData() {
      showGlobalLoading();
      const receiverId = document.getElementById('receiver-select').value;
      
      try {
        // Create array to store data for each hour
        const hourlyData = [];
        const now = new Date();
        
        // Get data for each hour in the past 24 hours
        for (let i = 0; i < 24; i++) {
          // Create date for current hour and set to exact hour (09:00:00)
          const hourDate = new Date(now);
          hourDate.setHours(now.getHours() - i);
          hourDate.setMinutes(0);
          hourDate.setSeconds(0);
          hourDate.setMilliseconds(0);
          
          // Create from date (previous hour, also on the hour)
          const fromDate = new Date(hourDate);
          fromDate.setHours(hourDate.getHours() - 1);
          
          // Format dates for API
          const fromFormatted = formatDateForAPI(fromDate);
          const toFormatted = formatDateForAPI(hourDate);
          
          // Build URL
          let url = `/statistics/stats/coverage-map?from=${fromFormatted}&to=${toFormatted}`;
          if (receiverId) {
            url += `&receiver_id=${receiverId}`;
          }
          
          // Fetch data for this hour
          const data = await fetch(url).then(r => r.json());
          
          // Add to hourly data with timestamp
          hourlyData.push({
            timestamp: hourDate,
            data: data,
            label: `${hourDate.toLocaleTimeString()}`
          });
        }
        
        // Reverse so we go from oldest to newest
        replayData = hourlyData.reverse();
        
        // Start replay if we have data
        if (replayData.length > 0) {
          startReplay();
        } else {
          alert('No data available for replay');
        }
      } catch (e) {
        console.error('Failed to fetch replay data:', e);
        alert('Failed to fetch replay data. Please try again later.');
      } finally {
        hideGlobalLoading();
      }
    }
    
    // Fetch replay data for week (daily for past 7 days)
    async function fetchWeekReplayData() {
      showGlobalLoading();
      const receiverId = document.getElementById('receiver-select').value;
      
      try {
        // Create array to store data for each day
        const dailyData = [];
        const now = new Date();
        
        // Get data for each day in the past 7 days
        for (let i = 0; i < 7; i++) {
          // Create date for current day and set to midnight
          const dayDate = new Date(now);
          dayDate.setDate(now.getDate() - i);
          
          // Set to start of day (00:00:00)
          dayDate.setHours(0, 0, 0, 0);
          
          // Create from and to dates for the full day
          const fromDate = new Date(dayDate);
          const toDate = new Date(dayDate);
          toDate.setHours(23, 0, 0, 0); // Use 23:00:00 instead of 23:59:59 for better cache hits
          
          // Format dates for API
          const fromFormatted = formatDateForAPI(fromDate);
          const toFormatted = formatDateForAPI(toDate);
          
          // Build URL
          let url = `/statistics/stats/coverage-map?from=${fromFormatted}&to=${toFormatted}`;
          if (receiverId) {
            url += `&receiver_id=${receiverId}`;
          }
          
          // Fetch data for this day
          const data = await fetch(url).then(r => r.json());
          
          // Add to daily data with timestamp
          dailyData.push({
            timestamp: dayDate,
            data: data,
            label: `${dayDate.toLocaleDateString()}`
          });
        }
        
        // Reverse so we go from oldest to newest
        replayData = dailyData.reverse();
        
        // Start replay if we have data
        if (replayData.length > 0) {
          startReplay();
        } else {
          alert('No data available for replay');
        }
      } catch (e) {
        console.error('Failed to fetch replay data:', e);
        alert('Failed to fetch replay data. Please try again later.');
      } finally {
        hideGlobalLoading();
      }
    }
    
    // Variables for replay state
    let originalData = null; // Store original data to restore after replay
    let isPaused = false;
    
    // Start replay of data
    function startReplay() {
      // If already replaying, stop it first
      if (isReplaying) {
        stopReplay();
      }
      
      // Store current data to restore after replay
      storeOriginalState();
      
      // Reset index
      replayIndex = 0;
      isReplaying = true;
      isPaused = false;
      
      // Show controls and info
      document.getElementById('replay-controls').style.display = 'flex !important';
      document.getElementById('replay-controls').setAttribute('style', 'display: flex !important');
      document.getElementById('replay-info').style.display = 'block';
      document.getElementById('replay-datetime-overlay').style.display = 'block';
      
      // Set button states (keep day/week buttons enabled)
      document.getElementById('replay-pause-btn').style.display = 'inline-block';
      document.getElementById('replay-play-btn').style.display = 'none';
      
      // Calculate time per frame (total 10 seconds divided by number of frames)
      const timePerFrame = 10000 / replayData.length;
      
      // Update map with first frame
      updateMapWithReplayFrame(0);
      
      // Start interval for replay
      replayInterval = setInterval(() => {
        if (isPaused) return;
        
        replayIndex++;
        
        // Update progress bar
        updateProgressBar();
        
        // Update map with current frame
        updateMapWithReplayFrame(replayIndex);
        
        // Check if we're done
        if (replayIndex >= replayData.length - 1) {
          pauseReplay(); // Pause at the end
          
          // After a delay, reset to original state
          setTimeout(() => {
            if (isReplaying) { // Only if we haven't manually stopped
              restoreOriginalState();
            }
          }, 3000);
        }
      }, timePerFrame);
    }
    
    // Update progress bar
    function updateProgressBar() {
      const progress = (replayIndex / (replayData.length - 1)) * 100;
      document.getElementById('replay-progress-bar').style.width = `${progress}%`;
    }
    
    // Pause replay
    function pauseReplay() {
      isPaused = true;
      document.getElementById('replay-pause-btn').style.display = 'none';
      document.getElementById('replay-play-btn').style.display = 'inline-block';
    }
    
    // Resume replay
    function resumeReplay() {
      isPaused = false;
      document.getElementById('replay-pause-btn').style.display = 'inline-block';
      document.getElementById('replay-play-btn').style.display = 'none';
    }
    
    // Go to previous frame
    function previousFrame() {
      if (replayIndex > 0) {
        replayIndex--;
        updateProgressBar();
        updateMapWithReplayFrame(replayIndex);
      }
    }
    
    // Go to next frame
    function nextFrame() {
      if (replayIndex < replayData.length - 1) {
        replayIndex++;
        updateProgressBar();
        updateMapWithReplayFrame(replayIndex);
      }
    }
    
    // Store original state to restore after replay
    function storeOriginalState() {
      // Store current map state
      originalData = {
        receiverId: document.getElementById('receiver-select').value,
        isDateRange: document.getElementById('dateRangeRadio').checked,
        days: document.getElementById('days-select').value,
        fromDate: document.getElementById('from-date').value,
        toDate: document.getElementById('to-date').value
      };
    }
    
    // Restore original state after replay
    function restoreOriginalState() {
      if (!originalData) return;
      
      // Reload the original data
      loadCoverageData();
      
      // Hide replay elements
      document.getElementById('replay-datetime-overlay').style.display = 'none';
    }
    
    // Stop replay
    function stopReplay() {
      if (replayInterval) {
        clearInterval(replayInterval);
        replayInterval = null;
      }
      
      isReplaying = false;
      isPaused = false;
      
      // Hide controls and info
      document.getElementById('replay-controls').setAttribute('style', 'display: none !important');
      document.getElementById('replay-info').style.display = 'none';
      document.getElementById('replay-datetime-overlay').style.display = 'none';
      
      // No need to re-enable replay buttons as they're always enabled
      
      // Restore original state
      restoreOriginalState();
    }
    
    // Update map with replay frame
    function updateMapWithReplayFrame(index) {
      if (!replayData[index]) return;
      
      const frameData = replayData[index];
      const heatData = frameData.data.map(point => {
        // Intensity based on logarithmic scale of count, but amplified for better visibility
        const intensity = Math.min(1, Math.log10(point.count + 1) / 2);
        return [point.lat, point.lon, intensity];
      });
      
      // Update info text
      document.getElementById('replay-info').textContent = `Showing data for: ${frameData.label}`;
      
      // Ensure datetime overlay is visible and update its content
      document.getElementById('replay-datetime-overlay').style.display = 'block';
      document.getElementById('replay-datetime-text').textContent = frameData.timestamp instanceof Date ?
        frameData.timestamp.toLocaleString() : frameData.label;
      
      // Clear previous heat layer
      if (heatLayer) {
        map.removeLayer(heatLayer);
      }
      
      // Create new heat layer
      heatLayer = L.heatLayer(heatData, {
        radius: 20,
        blur: 15,
        maxZoom: 17,
        minOpacity: 0.4,
        gradient: {0.2: 'blue', 0.4: 'cyan', 0.6: 'lime', 0.8: 'yellow', 1: 'red'}
      }).addTo(map);
      
      // Update statistics if we have a receiver selected
      const receiverId = document.getElementById('receiver-select').value;
      if (receiverId) {
        // Load all receivers
        fetch('/receivers').then(r => r.json()).then(receivers => {
          const selectedReceiver = receivers.find(r => r.id === parseInt(receiverId));
          if (selectedReceiver && selectedReceiver.latitude && selectedReceiver.longitude) {
            const receiverLatLng = L.latLng(selectedReceiver.latitude, selectedReceiver.longitude);
            const maxDistance = calculateMaxDistance(receiverLatLng, heatData);
            const stats = calculateCoverageStats(heatData, receiverLatLng, maxDistance);
            updateStatsDisplay(stats, true);
          }
        });
      }
    }
    
    // Initialize
    document.addEventListener('DOMContentLoaded', async () => {
      // Add event listeners
      document.getElementById('copy-link-btn').addEventListener('click', copyLinkToClipboard);
      
      // Add event listeners for replay controls
      document.getElementById('replay-day-btn').addEventListener('click', fetchDayReplayData);
      document.getElementById('replay-week-btn').addEventListener('click', fetchWeekReplayData);
      document.getElementById('replay-prev-btn').addEventListener('click', previousFrame);
      document.getElementById('replay-next-btn').addEventListener('click', nextFrame);
      document.getElementById('replay-pause-btn').addEventListener('click', pauseReplay);
      document.getElementById('replay-play-btn').addEventListener('click', resumeReplay);
      document.getElementById('replay-stop-btn').addEventListener('click', stopReplay);
      
      // Add event listener for receivers checkbox
      document.getElementById('show-receivers-checkbox').addEventListener('change', function() {
        showReceivers = this.checked;
        loadCoverageData(); // Reload the map with the new setting
      });
      
      // Set up date range toggle
      document.getElementById('fixedWindowRadio').addEventListener('change', function() {
        toggleTimeRangeType(true); // Trigger update when switching to fixed window
      });
      document.getElementById('dateRangeRadio').addEventListener('change', function() {
        toggleTimeRangeType(false); // Don't trigger update when switching to date range
      });
      
      // Set default values for date inputs (today and yesterday)
      const today = new Date();
      const yesterday = new Date();
      yesterday.setDate(yesterday.getDate() - 1);
      
      // Format dates for datetime-local input (YYYY-MM-DDThh:mm)
      const formatDateForInput = (date) => {
        return date.toISOString().slice(0, 16);
      };
      
      document.getElementById('to-date').value = formatDateForInput(today);
      document.getElementById('from-date').value = formatDateForInput(yesterday);
      
      // Add event listeners for date inputs - only validate, don't trigger update
      document.getElementById('from-date').addEventListener('change', function() {
        validateDateRange(
          document.getElementById('from-date').value,
          document.getElementById('to-date').value
        );
      });
      
      document.getElementById('to-date').addEventListener('change', function() {
        validateDateRange(
          document.getElementById('from-date').value,
          document.getElementById('to-date').value
        );
      });
      
      // Add event listener for the Go button
      document.getElementById('date-range-go').addEventListener('click', function() {
        if (validateDateRange(
          document.getElementById('from-date').value,
          document.getElementById('to-date').value
        )) {
          updateURL();
          loadCoverageData();
        }
      });
      
      // Update URL and load data when selections change
      document.getElementById('receiver-select').addEventListener('change', function() {
        updateURL();
        loadCoverageData();
      });
      
      document.getElementById('days-select').addEventListener('change', function() {
        updateURL();
        loadCoverageData();
      });
      
      // Load receivers
      await loadReceivers();
      
      // Check for query parameters and load map
      const params = getQueryParams();
      
      // Set the dropdown values to match query parameters if available
      if (params.receiverId) {
        document.getElementById('receiver-select').value = params.receiverId;
      }
      
      // Check if we have from/to parameters
      if (params.from && params.to) {
        try {
          const fromDate = new Date(params.from);
          const toDate = new Date(params.to);
          
          // Switch to date range mode
          document.getElementById('dateRangeRadio').checked = true;
          document.getElementById('fixedWindowRadio').checked = false;
          toggleTimeRangeType(false); // Don't trigger update yet
          
          // Set the date inputs
          document.getElementById('from-date').value = formatDateForInput(fromDate);
          document.getElementById('to-date').value = formatDateForInput(toDate);
          
          // Load the coverage map
          loadCoverageData();
        } catch (e) {
          console.error('Error parsing date parameters:', e);
          // Fall back to days parameter
          if (params.days) {
            document.getElementById('days-select').value = params.days;
            loadCoverageData();
          }
        }
      } else if (params.days) {
        // Use days parameter
        document.getElementById('days-select').value = params.days;
        loadCoverageData();
      } else {
        // If no parameters, show an initial loading state
        showMapLoading();
        setTimeout(() => hideMapLoading(), 500); // Hide after a short delay if no data is loaded
      }
      
      // Add event listeners for replay buttons
      document.getElementById('replay-day-btn').addEventListener('click', fetchDayReplayData);
      document.getElementById('replay-week-btn').addEventListener('click', fetchWeekReplayData);
      
      // Update the scale whenever the map is zoomed or moved
      map.on('zoomend moveend', updateNauticalScale);
      // Call once to set the initial scale
      updateNauticalScale();
    });
  </script>
</body>
</html>