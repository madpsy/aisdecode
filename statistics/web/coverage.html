<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Coverage Map</title>
  
  <!-- Bootstrap 5 CSS -->
  <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/css/bootstrap.min.css" rel="stylesheet">
  <!-- Leaflet CSS -->
  <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" integrity="sha256-p4NxAoJBhIIN+hmNHrzRCf9tD/miZyoHS5obTRR9BMY=" crossorigin=""/>
  <!-- Leaflet Heat plugin -->
  <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js" integrity="sha256-20nQCchB9co0qIjJZRGuk2/Z9VM+kNiyxNV1lvTlZBo=" crossorigin=""></script>
  <script src="https://unpkg.com/leaflet.heat@0.2.0/dist/leaflet-heat.js"></script>
  
  <style>
    body {
      background-color: #f8f9fa;
      padding: 2rem;
      font-family: sans-serif;
    }
    h1 {
      color: #343a40;
      margin-bottom: 1.5rem;
    }
    .card {
      box-shadow: 0 2px 6px rgba(0,0,0,0.1);
      margin-bottom: 2rem;
    }
    #coverage-map {
      height: 600px;
      width: 100%;
      border-radius: 5px;
    }
    .controls {
      margin-bottom: 1rem;
    }
    .receiver-tooltip {
      background-color: rgba(255, 255, 255, 0.9);
      border: none;
      box-shadow: 0 1px 3px rgba(0,0,0,0.3);
      padding: 3px 8px;
      border-radius: 4px;
      font-size: 12px;
      font-weight: bold;
      white-space: nowrap;
    }
  </style>
</head>
<body>
  <div class="container-fluid">
    <div class="d-flex justify-content-between align-items-center mb-3">
      <h1>Coverage Map</h1>
      <button id="copy-link-btn" class="btn btn-outline-secondary">
        <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" class="bi bi-link-45deg" viewBox="0 0 16 16">
          <path d="M4.715 6.542 3.343 7.914a3 3 0 1 0 4.243 4.243l1.828-1.829A3 3 0 0 0 8.586 5.5L8 6.086a1.002 1.002 0 0 0-.154.199 2 2 0 0 1 .861 3.337L6.88 11.45a2 2 0 1 1-2.83-2.83l.793-.792a4.018 4.018 0 0 1-.128-1.287z"/>
          <path d="M6.586 4.672A3 3 0 0 0 7.414 9.5l.775-.776a2 2 0 0 1-.896-3.346L9.12 3.55a2 2 0 1 1 2.83 2.83l-.793.792c.112.42.155.855.128 1.287l1.372-1.372a3 3 0 1 0-4.243-4.243L6.586 4.672z"/>
        </svg>
        Copy Link
      </button>
    </div>
    
    <div class="card">
      <div class="card-body">
        <div class="controls row">
          <div class="col-md-4">
            <label for="receiver-select" class="form-label">Receiver:</label>
            <select id="receiver-select" class="form-select">
              <option value="" disabled selected>Select a receiver</option>
              <!-- Receivers will be loaded dynamically -->
            </select>
          </div>
          <div class="col-md-4">
            <label for="days-select" class="form-label">Time window:</label>
            <select id="days-select" class="form-select">
              <option value="1" selected>1 day</option>
              <option value="2">2 days</option>
              <option value="7">7 days</option>
              <option value="14">14 days</option>
              <option value="30">30 days</option>
              <option value="60">60 days</option>
              <option value="90">90 days</option>
            </select>
          </div>
          <div class="col-md-4 d-flex align-items-end">
            <button id="load-btn" class="btn btn-primary">Load Coverage Map</button>
          </div>
        </div>
        
        <div id="coverage-map" style="position: relative;">
          <!-- Nautical Mile Scale -->
          <div id="nm-scale" style="
            position: absolute;
            top: 20px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(255, 255, 255, 0.8);
            padding: 5px 10px;
            border-radius: 5px;
            z-index: 1100;
            font-family: Arial, sans-serif;
            font-size: 12px;
            text-align: center;
          ">
          <div id="scale-bar" style="
            position: relative;
            width: 100px;
            height: 4px;
            background: black;
            margin-bottom: 2px;
          ">
            <!-- Left tick -->
            <div style="
              position: absolute;
              left: 0;
              top: -4px;
              width: 2px;
              height: 12px;
              background: black;
            "></div>
            <!-- Right tick -->
            <div style="
              position: absolute;
              right: 0;
              top: -4px;
              width: 2px;
              height: 12px;
              background: black;
            "></div>
          </div>
            <div id="scale-label">0 NM</div>
          </div>
      </div>
    </div>
  </div>
  
  <script>
    // Initialize map
    const map = L.map('coverage-map').setView([51.505, -0.09], 6);
    
    // Add base map layer
    L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
      attribution: '&copy; <a href="https://www.openstreetmap.org/copyright">OpenStreetMap</a> contributors'
    }).addTo(map);
    
    // Map layers that need to be cleared between receiver changes
    let heatLayer = null;
    let receiverMarker = null;
    let receiverTooltip = null;
    let rangeCircles = []; // Array to store the range circles
    let rangeLabels = []; // Array to store the range labels
    
    // Function to clear all previous map layers
    function clearMapLayers() {
      // Remove heat layer if it exists
      if (heatLayer) {
        map.removeLayer(heatLayer);
        heatLayer = null;
      }
      
      // Remove receiver marker if it exists
      if (receiverMarker) {
        map.removeLayer(receiverMarker);
        receiverMarker = null;
      }
      
      // Remove receiver tooltip if it exists
      if (receiverTooltip) {
        map.removeLayer(receiverTooltip);
        receiverTooltip = null;
      }
      
      // Remove range circles and labels
      rangeCircles.forEach(circle => {
        if (circle) map.removeLayer(circle);
      });
      rangeCircles = [];
      
      rangeLabels.forEach(label => {
        if (label) map.removeLayer(label);
      });
      rangeLabels = [];
    }
    
    // Calculate the maximum distance from the receiver to any point in the heatmap
    function calculateMaxDistance(receiverLatLng, heatData) {
      let maxDistance = 0;
      
      heatData.forEach(point => {
        const pointLatLng = L.latLng(point[0], point[1]);
        const distance = receiverLatLng.distanceTo(pointLatLng);
        if (distance > maxDistance) {
          maxDistance = distance;
        }
      });
      
      return maxDistance; // in meters
    }
    
    // Draw concentric circles around the receiver
    function drawRangeCircles(receiverLatLng, maxDistance) {
      // Clear any existing circles and labels
      rangeCircles.forEach(circle => {
        if (circle) map.removeLayer(circle);
      });
      rangeCircles = [];
      
      rangeLabels.forEach(label => {
        if (label) map.removeLayer(label);
      });
      rangeLabels = [];
      
      // Create 3 equally spaced circles
      for (let i = 1; i <= 3; i++) {
        const radiusMeters = maxDistance * i / 3;
        const radiusNM = (radiusMeters / 1852).toFixed(1); // Convert meters to nautical miles
        
        // Create circle
        const circle = L.circle(receiverLatLng, {
          radius: radiusMeters,
          color: '#3388ff',
          fillColor: 'transparent',
          weight: 1.5,
          opacity: 0.7,
          dashArray: '5, 5' // Make the circles dashed
        }).addTo(map);
        
        rangeCircles.push(circle);
        
        // Calculate position for the label (east of the center)
        const labelLatLng = calculateLabelPosition(receiverLatLng, radiusMeters);
        
        // Create label
        const label = L.tooltip({
          permanent: true,
          direction: 'center',
          className: 'receiver-tooltip'
        })
        .setLatLng(labelLatLng)
        .setContent(`${radiusNM} NM`)
        .addTo(map);
        
        rangeLabels.push(label);
      }
    }
    
    // Calculate position for range label (east of center)
    function calculateLabelPosition(center, radiusMeters) {
      // Convert radius from meters to degrees longitude (approximate)
      // This is a simplified calculation that works for small distances
      const radiusLng = radiusMeters / (111320 * Math.cos(center.lat * Math.PI / 180));
      
      // Position the label to the east of the center
      return L.latLng(center.lat, center.lng + radiusLng);
    }
    
    // Load receivers
    async function loadReceivers() {
      try {
        const receivers = await fetch('/receivers').then(r => r.json());
        const select = document.getElementById('receiver-select');
        
        // Sort receivers by name
        receivers.sort((a, b) => a.name.localeCompare(b.name));
        
        // Add receivers to dropdown
        receivers.forEach(receiver => {
          const option = document.createElement('option');
          option.value = receiver.id;
          option.textContent = receiver.name;
          select.appendChild(option);
        });
      } catch (e) {
        console.error('Failed to load receivers:', e);
        alert('Failed to load receivers. Please try again later.');
      }
    }
    
    // Load coverage data
    async function loadCoverageData() {
      const receiverId = document.getElementById('receiver-select').value;
      const days = document.getElementById('days-select').value;
      
      if (!receiverId) {
        alert('Please select a receiver');
        return;
      }
      
      // Update URL with current selections
      updateURL();
      
      try {
        // Show loading state
        document.getElementById('load-btn').disabled = true;
        document.getElementById('load-btn').textContent = 'Loading...';
        
        // Fetch coverage data
        const url = `/statistics/stats/coverage-map?receiver_id=${receiverId}&days=${days}`;
        const data = await fetch(url).then(r => r.json());
        
        if (data.length === 0) {
          alert('No coverage data available for the selected receiver and time period');
          return;
        }
        
        // Convert data to heatmap format
        const heatData = data.map(point => {
          // Intensity based on logarithmic scale of count, but amplified for better visibility
          // Increase the divisor to make low counts more visible
          const intensity = Math.min(1, Math.log10(point.count + 1) / 2);
          return [point.lat, point.lon, intensity];
        });
        
        // Clear all previous map layers
        clearMapLayers();
        
        // Create new heat layer with improved visibility
        heatLayer = L.heatLayer(heatData, {
          radius: 20,           // Increased from 15
          blur: 15,             // Decreased from 20 for sharper points
          maxZoom: 17,
          minOpacity: 0.4,      // Added minimum opacity
          gradient: {0.2: 'blue', 0.4: 'cyan', 0.6: 'lime', 0.8: 'yellow', 1: 'red'}
        }).addTo(map);
        
        // Find receiver from the list we already loaded
        const receivers = await fetch('/receivers').then(r => r.json());
        const selectedReceiver = receivers.find(r => r.id === parseInt(receiverId));
        
        if (selectedReceiver && selectedReceiver.latitude && selectedReceiver.longitude) {
          // Add receiver marker
          const receiverIcon = L.divIcon({
            html: '<div style="background-color: #ff4136; width: 12px; height: 12px; border-radius: 50%; border: 2px solid white;"></div>',
            className: 'receiver-marker',
            iconSize: [12, 12]
          });
          
          // Add marker with popup and store reference
          receiverMarker = L.marker([selectedReceiver.latitude, selectedReceiver.longitude], {icon: receiverIcon})
            .addTo(map)
            .bindPopup(`<b>Receiver:</b> ${selectedReceiver.name}`);
          
          // Add permanent tooltip with receiver name and store reference
          receiverTooltip = L.tooltip({
            permanent: true,
            direction: 'top',
            className: 'receiver-tooltip',
            offset: [0, -10]
          })
          .setContent(`<b>${selectedReceiver.name}</b>`)
          .setLatLng([selectedReceiver.latitude, selectedReceiver.longitude])
          .addTo(map);
          
          // Calculate maximum distance and draw range circles
          const receiverLatLng = L.latLng(selectedReceiver.latitude, selectedReceiver.longitude);
          const maxDistance = calculateMaxDistance(receiverLatLng, heatData);
          drawRangeCircles(receiverLatLng, maxDistance);
          
          // Create bounds that include both the receiver and all heatmap points
          const points = heatData.map(p => [p[0], p[1]]);
          points.push([selectedReceiver.latitude, selectedReceiver.longitude]);
          const bounds = L.latLngBounds(points);
          map.fitBounds(bounds, { padding: [50, 50] });
        } else {
          // If no receiver location, fit bounds to data
          const bounds = L.latLngBounds(heatData.map(p => [p[0], p[1]]));
          map.fitBounds(bounds, { padding: [50, 50] });
        }
      } catch (e) {
        console.error('Failed to load coverage data:', e);
        alert('Failed to load coverage data. Please try again later.');
      } finally {
        // Reset button state
        document.getElementById('load-btn').disabled = false;
        document.getElementById('load-btn').textContent = 'Load Coverage Map';
      }
    }
    
    // Parse URL query parameters
    function getQueryParams() {
      const params = new URLSearchParams(window.location.search);
      return {
        receiverId: params.get('receiver_id'),
        days: params.get('days')
      };
    }
    
    // Update URL with current selections without reloading the page
    function updateURL() {
      const receiverId = document.getElementById('receiver-select').value;
      const days = document.getElementById('days-select').value;
      
      const url = new URL(window.location.href);
      
      if (receiverId) {
        url.searchParams.set('receiver_id', receiverId);
      } else {
        url.searchParams.delete('receiver_id');
      }
      
      if (days) {
        url.searchParams.set('days', days);
      } else {
        url.searchParams.delete('days');
      }
      
      window.history.replaceState({}, '', url);
    }
    
    // Copy current URL to clipboard
    function copyLinkToClipboard() {
      const url = window.location.href;
      navigator.clipboard.writeText(url).then(() => {
        const btn = document.getElementById('copy-link-btn');
        const originalText = btn.innerHTML;
        btn.innerHTML = 'Copied!';
        setTimeout(() => {
          btn.innerHTML = originalText;
        }, 2000);
      }).catch(err => {
        console.error('Failed to copy URL: ', err);
        alert('Failed to copy URL to clipboard');
      });
    }
    
    // Update the nautical mile scale based on current map zoom level
    function updateNauticalScale() {
      const scaleLabel = document.getElementById('scale-label');
      const scalePx = 100; // Width of scale bar in pixels
      const center = map.getCenter();
      const point = map.latLngToContainerPoint(center);
      const pointX = L.point(point.x + scalePx, point.y);
      const latLngX = map.containerPointToLatLng(pointX);
      const distanceMeters = center.distanceTo(latLngX);
      const distanceNM = distanceMeters / 1852; // Convert meters to nautical miles
      scaleLabel.textContent = `${distanceNM.toFixed(1)} NM`;
    }
    
    // Initialize
    document.addEventListener('DOMContentLoaded', async () => {
      // Add event listeners
      document.getElementById('load-btn').addEventListener('click', loadCoverageData);
      document.getElementById('copy-link-btn').addEventListener('click', copyLinkToClipboard);
      
      // Update URL when selections change
      document.getElementById('receiver-select').addEventListener('change', updateURL);
      document.getElementById('days-select').addEventListener('change', updateURL);
      
      // Load receivers
      await loadReceivers();
      
      // Check for query parameters and load map if both are present
      const params = getQueryParams();
      if (params.receiverId && params.days) {
        // Set the dropdown values to match query parameters
        document.getElementById('receiver-select').value = params.receiverId;
        document.getElementById('days-select').value = params.days;
        
        // Load the coverage map
        loadCoverageData();
      }
      
      // Update the scale whenever the map is zoomed or moved
      map.on('zoomend moveend', updateNauticalScale);
      // Call once to set the initial scale
      updateNauticalScale();
    });
  </script>
</body>
</html>