<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>AIS Tracker</title>
    <!-- Leaflet CSS (from CDN, without integrity) -->
    <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.3/dist/leaflet.css" crossorigin="" />
    <!-- Google Fonts for modern look -->
    <link href="https://fonts.googleapis.com/css2?family=Roboto:wght@400;500&display=swap" rel="stylesheet">
    <style>
        html, body, #map {
          height: 100%;
          margin: 0;
          padding: 0;
        }
        .popup-content {
          font-family: Arial, sans-serif;
          font-size: 14px;
          line-height: 1.3;
        }
        .boat-icon {
          background: transparent;
          border: none;
          transition: transform 0.5s ease-out;
        }
	.leaflet-div-icon.non-vessel-icon {
	  width: 30px !important;
	  height: 30px !important;
	  padding: 0 !important;
	  margin: 0 !important;
	  text-align: center;
	  line-height: 30px;
	}
	#vessel-detail a {
	  text-decoration: none;
	}
	.port-marker-tooltip {
	  border: none;
	  box-shadow: none;
	  background: white;
	  padding: 2px 4px;
	  z-index: 1100;
	}	
        /* CSS for the enlargement animation */
        .boat-icon.enlarge {
          transform: scale(1.5);
        }
        .vessel-tooltip {
          font-family: Arial, sans-serif;
          font-size: 10px;
          font-weight: bold;
          background: rgba(255, 255, 255, 0.9);
          padding: 2px 4px;
          border: 1px solid #aaa;
          border-radius: 3px;
          cursor: pointer;
        }
        .receiver-tooltip {
          font-family: Arial, sans-serif;
          font-size: 10px;
          font-weight: bold;
          background: rgba(255, 255, 255, 0.9);
          padding: 2px 4px;
          border: 1px solid #aaa;
          border-radius: 3px;
          cursor: pointer;
        }
        /* Style for the distance label tooltip */
        .distance-label-tooltip, .distance-tooltip {
          background: rgba(255, 255, 255, 0.7);
          border: 1px solid #aaa;
          border-radius: 3px;
          padding: 1px 3px;
          font-size: 12px;
          text-align: center;
          box-shadow: none;
          white-space: nowrap;
          z-index: 1500 !important; /* Ensure higher than vessel tooltips */
        }
        /* Style for the known vessels overlay (bottom left) */
        #vessel-overlay {
          position: absolute;
          bottom: 50px;
          left: 10px;
          background: rgba(255, 255, 255, 0.75);
          border: 2px solid #aaa;
          border-radius: 8px;
          padding: 5px;
          height: 300px;
          width: 150px;
          overflow-y: auto;
          z-index: 1000;
          font-family: 'Roboto', sans-serif;
          font-size: 13px;
          line-height: 1.4;
          box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }
        #vessel-overlay h4 {
          margin: 5px 0;
          text-align: center;
          font-size: 14px;
        }
        /* Style for the filter input box */
        #vessel-filter {
          width: 90%;
          margin: 5px auto;
          display: block;
          padding: 3px;
          font-size: 13px;
        }
        #vessel-overlay .vessel-entry {
          border-bottom: 1px solid #eee;
          padding: 4px 0;
          cursor: pointer;
        }
        #vessel-overlay .vessel-entry:last-child {
          border-bottom: none;
        }
        #vessel-overlay .vessel-name {
          font-weight: bold;
          text-decoration: underline;
        }
        #vessel-overlay .vessel-callsign {
          color: #555;
        }
        #vessel-overlay .vessel-timestamp {
          color: #888;
          font-size: 12px;
        }
        /* New Style for the vessel detail overlay (bottom right) */
        #vessel-detail {
          position: absolute;
          bottom: 50px;
          right: 10px;
          background: rgba(255, 255, 255, 0.75);
          border: 2px solid #aaa;
          border-radius: 8px;
          padding: 5px;
          max-height: 300px;
          min-width: 200px;
   max-width: 200px;
          width: auto;
          overflow-y: auto;
          z-index: 1500;
          font-family: 'Roboto', sans-serif;
          font-size: 13px;
          line-height: 1.4;
          display: none;
          white-space: nowrap;
          box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }
        #vessel-detail h4 {
          margin: 5px 0;
          text-align: center;
          font-size: 14px;
        }
        /* Style for the controls overlay */
        #controls {
          position: absolute;
          top: 10px;
          right: 10px;
          background: rgba(255, 255, 255, 0.75);
          border: 2px solid #aaa;
          border-radius: 8px;
          padding: 5px;
          z-index: 1000;
          font-family: 'Roboto', sans-serif;
          font-size: 14px;
          box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }
        #controls label {
          cursor: pointer;
          display: block;
          margin-bottom: 5px;
        }
        /* Styles for the new toggle buttons */
        .toggle-button {
          position: absolute;
          background: rgba(255, 255, 255, 0.75);
          border: 1px solid #ddd;
          border-radius: 8px;
          padding: 5px 8px;
          font-family: 'Roboto', sans-serif;
          font-size: 14px;
          font-weight: 500;
          cursor: pointer;
          z-index: 1100;
          box-shadow: 0 2px 4px rgba(0,0,0,0.1);
          transition: all 0.2s ease;
        }
        .toggle-button:hover {
          background: rgba(248, 248, 248, 0.8);
          box-shadow: 0 3px 6px rgba(0,0,0,0.15);
        }
        #toggle-known-overlay {
          bottom: 20px;
          left: 10px;
        }
        #toggle-detail-overlay {
          bottom: 20px;
          right: 15px;
          display: none;
        }
        /* Live Logs button styling (positioned to the left of Show/Hide Details) */
        #live-logs {
          position: absolute;
          bottom: 20px;
          right: 75px;
          background: rgba(255, 255, 255, 0.75);
          border: 1px solid #ddd;
          border-radius: 8px;
          padding: 5px 8px;
          font-family: 'Roboto', sans-serif;
          font-size: 14px;
          font-weight: 500;
          cursor: pointer;
          z-index: 1100;
          box-shadow: 0 2px 4px rgba(0,0,0,0.1);
          transition: all 0.2s ease;
          display: none;
        }
        #live-logs:hover {
          background: rgba(248, 248, 248, 0.8);
          box-shadow: 0 3px 6px rgba(0,0,0,0.15);
        }
        /* Live Logs overlay styling */
        #live-logs-overlay {
          display: none;
          position: absolute;
          top: 100px;
          left: 50px;
          background: rgba(255,255,255,0.85);
          border: 2px solid #aaa;
          border-radius: 8px;
          padding: 10px;
          width: 290px;
          max-height: 400px;
          overflow-y: auto;
          z-index: 1200;
          box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }
        #live-logs-header {
          cursor: move;
          font-weight: bold;
          margin-bottom: 5px;
        }
        #live-logs-header button {
          float: right;
          cursor: pointer;
        }
        .log-entry {
          border-bottom: 1px solid #eee;
          padding: 5px 0;
          font-family: monospace;
          font-size: 12px;
        }
        .log-entry:last-child {
          border-bottom: none;
        }
        .log-field {
          font-weight: normal;
        }
        #stats-button {
          position: absolute;
          bottom: 20px;
          right: 155px;  /* Adjust as needed so it appears left of the "Messages" button */
          background: rgba(255, 255, 255, 0.75);
          border: 1px solid #ddd;
          border-radius: 8px;
          padding: 5px 8px;
          font-family: 'Roboto', sans-serif;
          font-size: 14px;
          font-weight: 500;
          cursor: pointer;
          z-index: 1100;
          box-shadow: 0 2px 4px rgba(0,0,0,0.1);
          transition: all 0.2s ease;
          display: none;  /* Hidden by default */
        }
        #stats-button:hover {
          background: rgba(248, 248, 248, 0.8);
          box-shadow: 0 3px 6px rgba(0,0,0,0.15);
        }

#vessel-legend {
  font-family: Arial, sans-serif;
  font-size: 14px;
  padding: 5px;
  background-color: rgba(255, 255, 255, 0.95);
  border: 1px solid #ccc;
  border-radius: 5px;
  width: 150px;
  height: 200px;
  overflow-y: auto;
  z-index: 1000;
}

#vessel-legend .legend-item {
  display: flex;
  align-items: center;
  margin: 1px 0;
  padding: 0;
  line-height: 1;
}

#vessel-legend .legend-item svg {
  margin-right: 5px; 
  width: 20px;   
  height: 20px;
}

#vessel-legend .legend-item span {
  flex: 1;
  font-size: 14px;
  line-height: 1;
}


#slider-container {
  position: absolute;
  bottom: 20px;
  left: 50%;
  transform: translateX(-50%);
  background: rgba(255, 255, 255, 0.75);
  border-radius: 8px;
  padding: 0px;
  z-index: 900;
  font-family: 'Roboto', sans-serif;
  font-size: 12px;
  text-align: center;
  border: 2px solid #aaa;
  box-shadow: 0 2px 4px rgba(0,0,0,0.1);
}

/* Move slider container higher on narrow screens to prevent button overlap */
@media screen and (max-width: 768px) {
  #slider-container {
    bottom: 50px;
  }
}

#slider-container label {
  display: block;
  margin: 0 5px 0 0;
}

#slider-container input {
  width: 100%;
  margin: 0 10px 0 0;
}
#github-link {
  position: absolute;
  bottom: 5px; 
  left: 50%;
  transform: translateX(-50%);
  color: black;
  text-decoration: none;
  font-size: 12px;
  z-index: 1500;
}

.speed-scale-container {
  margin-bottom: 6px;
  padding: 0 5px;       
  font-family: Arial, sans-serif;
  font-size: 12px;
  line-height: 1;
}

.speed-scale-bar {
  height: 6px;
  border-radius: 3px;
  background: linear-gradient(
    to right,
    hsl(120,100%,50%) 0%,    /* green */
    hsl(60, 100%,50%) 50%,   /* yellow */
    hsl(0,  100%,50%) 100%   /* red */
  );
  margin-bottom: 2px;
}

.speed-scale-labels {
  display: flex;
  justify-content: space-between;
}

.speed-scale-labels span {
}

#latest-message-overlay {
  position: absolute;
  top: 50px;
  right: 50px;
  width: 300px;
  max-height: 400px;
  overflow: auto;
  background: rgba(255, 255, 255, 0.85);
  border: 2px solid #aaa;
  border-radius: 8px;
  padding: 10px;
  z-index: 2000;
  display: none;            /* hidden by default */
  box-shadow: 0 2px 8px rgba(0,0,0,0.3);
  font-family: monospace;
  font-size: 13px;
}
.latest-message-overlay .lm-header {
  display: flex;
  justify-content: space-between;
  align-items: center;
  margin-bottom: 8px;
}
.latest-message-overlay .lm-close {
  background: transparent;
  border: none;
  font-size: 16px;
  cursor: pointer;
}
.latest-message-overlay pre {
  background: #f7f7f7;
  padding: 5px;
  border-radius: 3px;
  overflow-x: auto;
}

#latest-message-overlay .lm-header {
  display: flex;
  justify-content: space-between;  /* push items to ends */
  align-items: center;
  margin-bottom: 8px;
  position: relative;              /* ensure children are positioned relative to this */
}

#latest-message-overlay .lm-close {
  background: transparent;
  border: none;
  font-size: 16px;
  cursor: pointer;
  padding: 0;
  margin: 0;
}

#metrics-display {
  display: flex;           /* Use flexbox layout */
  justify-content: space-between; /* Space out the items */
  align-items: center;     /* Vertically align them to the center */
  margin-top: 0px;
  margin-top: 5px;
  font-size: 14px;
}

#metrics-display div {
  margin-right: 5px;      /* Add some space between the two elements */
  color: #333;             /* Optional: Set color */
}

    /* Welcome overlay for first-time visitors */
    #welcome-overlay {
        position: fixed;
        top: 0;
        left: 0;
        right: 0;
        background-color: rgba(0, 120, 215, 0.9);
        color: white;
        padding: 15px;
        text-align: center;
        z-index: 2000;
        font-family: 'Roboto', sans-serif;
        box-shadow: 0 2px 10px rgba(0, 0, 0, 0.3);
        display: none; /* Hidden by default, shown via JS */
    }
    
    #welcome-overlay a {
        color: white;
        font-weight: bold;
        text-decoration: underline;
    }
    
    #welcome-overlay button {
        background-color: white;
        color: #0078d7;
        border: none;
        padding: 5px 15px;
        margin-left: 15px;
        border-radius: 4px;
        cursor: pointer;
        font-weight: bold;
    }
    
    #welcome-overlay button:hover {
        background-color: #f0f0f0;
    }
    </style>
</head>

<body>
    <div id="map"></div>
    <!-- Welcome overlay for first-time visitors -->
    <div id="welcome-overlay">
        Welcome to AIS Tracker! Learn how to <a href="/howto.html" target="_blank">set up your own AIS receiver</a>
        <button id="welcome-close">Got it</button>
    </div>
    <div id="latlong-display" style="
	    position: absolute;
	    top: 10px;
	    left: 50%;
	    transform: translateX(-50%);
	    background: rgba(255, 255, 255, 0.8);
	    padding: 5px 10px;
	    border-radius: 5px;
	    z-index: 1100;
	    font-family: Arial, sans-serif;
	    font-size: 14px;
	">
        0, 0
    </div>
    <div id="nm-scale" style="
    position: absolute;
    top: 40px;
    left: 50%;
    transform: translateX(-50%);
    background: rgba(255, 255, 255, 0.8);
    padding: 5px 10px;
    border-radius: 5px;
    z-index: 1100;
    font-family: Arial, sans-serif;
    font-size: 12px;
    text-align: center;
">
        <div id="scale-bar" style="
      position: relative;
      width: 100px;
      height: 4px;
      background: black;
      margin-bottom: 2px;
  ">
            <!-- Left tick -->
            <div style="
        position: absolute;
        left: 0;
        top: -4px;
        width: 2px;
        height: 12px;
        background: black;
    "></div>
            <!-- Right tick -->
            <div style="
        position: absolute;
        right: 0;
        top: -4px;
        width: 2px;
        height: 12px;
        background: black;
    "></div>
        </div>
        <div id="scale-label">0 NM</div>
    </div>

    <!-- Controls Overlay -->
    <div id="controls">
        <label>
  <div id="connection-status" style="display: flex; align-items: center; margin-bottom: 5px; margin-left: 5px;">
    <span id="status-dot" style="width: 10px; height: 10px; border-radius: 50%; background: red; display: inline-block; margin-right: 5px;"></span>
    <span id="status-text">Disconnected</span>
  </div>
  <div id="metrics-display">
    <div id="msg-per-sec">0/sec</div>
    <div id="forwarded-ratio">0%</div>
  </div>
        <label style="margin-bottom: 1px; display: block;">
    <input type="checkbox" id="only-focussed">
    Only Tracked
  </label>
        <label style="margin-bottom: 1px; display: block;">
    <input type="checkbox" id="openseamap-overlay" checked>
    Map Overlay
  </label>
  <label style="margin-bottom: 1px; display: block;">
    <input type="checkbox" id="show-paths">
    History
  </label>
        <label style="margin-bottom: 1px; display: block;">
    <input type="checkbox" id="stationary" checked>
    Stationary
  </label>
        <div style="border-top: 1px solid #ccc; margin-top: 3px; padding-top: 3px;">
            <div style="display: flex; margin-bottom: 0px; align-items: center;">
                <label style="white-space: nowrap; display: flex; align-items: center; margin-right: 5px;">
                    <input type="checkbox" id="class-a" checked style="margin: 0;">
                    <span style="margin-left: 2px;">A</span>
                </label>
                <label style="white-space: nowrap; display: flex; align-items: center; margin-right: 5px;">
                    <input type="checkbox" id="class-b" checked style="margin: 0;">
                    <span style="margin-left: 2px;">B</span>
                </label>
                <label style="white-space: nowrap; display: flex; align-items: center;">
                    <input type="checkbox" id="class-sar" checked style="margin: 0;">
                    <span style="margin-left: 2px;">SAR</span>
                </label>
            </div>
            <div style="display: flex; align-items: center;">
                <label style="white-space: nowrap; display: flex; align-items: center; margin-right: 5px;">
                    <input type="checkbox" id="class-aton" checked style="margin: 0;">
                    <span style="margin-left: 2px;">AtoN</span>
                </label>
                <label style="white-space: nowrap; display: flex; align-items: center;">
                    <input type="checkbox" id="class-base" checked style="margin: 0;">
                    <span style="margin-left: 2px;">Base</span>
                </label>
            </div>
        </div>
        <button id="toggle-legend" class="toggle-button" style="margin-top: 15px;">Show Types</button>
    </div>

    <div id="vessel-legend" style="display: none; position: absolute; top: 240px; right: 5px; background: rgba(255, 255, 255, 0.75); border: 2px solid #aaa; border-radius: 8px; padding: 5px; z-index: 1000; font-family: 'Roboto', sans-serif; font-size: 13px; max-height: 400px; overflow-y: auto; box-shadow: 0 2px 4px rgba(0,0,0,0.1);">
      <div class="speed-scale-container" style="border-bottom: 1px solid #ccc; padding-bottom: 5px; margin-bottom: 5px;">
        <div class="speed-scale-bar"></div>
        <div class="speed-scale-labels">
          <span>0 kn</span>
          <span>40 kn</span>
        </div>
      </div>
      <table style="width: 100%; margin: 0 0 23px 0;">
        <tr>
          <td style="width: 60px; padding-top: 0px; padding-left: 5px;">
            <button id="legend-filter-button" class="toggle-button" style="padding: 2px 5px; font-size: 12px; width: 50px;">Filter</button>
          </td>
          <td style="padding-top: 0px;">
            <button id="legend-clear-button" class="toggle-button" style="padding: 2px 5px; font-size: 12px; width: 50px;">Clear</button>
          </td>
        </tr>
      </table>
      <div id="legend-content"></div>
    </div>

    <!-- Known vessels overlay (bottom left) -->
    <div id="vessel-overlay" style="display: none;">
        <!-- Filter input box -->
        <input type="text" id="vessel-filter" placeholder="Search...">
        <div id="vessel-count" style="text-align: left; margin-bottom: 0px;">Total: 0</div>
        <div id="overlay-content"></div>
    </div>

    <!-- Vessel detail overlay (bottom right) -->
    <div id="vessel-detail">
        <div id="vessel-detail-header">
	  <div id="vessel-header-text"></div>
	  <div id="vessel-header-image"></div>
	</div>
        <div id="detail-content"></div>
    </div>

    <div id="image-modal-overlay" style="display:none; position:fixed; top:0; left:0; width:100%; height:100%; background:rgba(0,0,0,0.8); z-index:1500; align-items:center; justify-content:center;">
      <div id="image-modal-content" style="position:relative;">
        <button id="modal-close" style="position:absolute; top:10px; right:10px; font-size:20px; background:transparent; border:none; color:white; cursor:pointer;">X</button>
        <img id="modal-image" src="" alt="Full-size Vessel Image" style="max-width:90vw; max-height:90vh; display:block; margin:0 auto;">
      </div>
    </div>

    <!-- Toggle Buttons -->
    <button id="toggle-known-overlay" class="toggle-button">Show Vessels</button>
    <button id="toggle-detail-overlay" class="toggle-button">Hide</button>

    <button id="stats-button">Watch</button>
    <button id="live-logs">Decodes</button>
    <div id="slider-container">
        <label for="history-slider">
       History: <span id="history-value">24</span> hrs
   </label>
        <input type="range" id="history-slider" min="1" max="24" value="24" step="1">
        <label for="age-slider">
     Age: <span id="age-value">24</span> hrs
  </label>
        <input type="range" id="age-slider" min="1" max="24" value="24" step="1">
    </div>
    <a href="https://github.com/madpsy/aisdecode" target="_blank" id="github-link">OpenSource @ GitHub</a>
    <!-- Live Logs Overlay (draggable) -->
    <div id="live-logs-overlay">
        <div id="live-logs-header">
            <span id="live-logs-title">Live Messages</span>
            <button id="close-live-logs">X</button>
        </div>
	<div id="live-logs-filters" style="padding: 2px; border-bottom: 1px solid #ccc; font-size: 12px;">
	  <label style="white-space: nowrap;">
	    <input type="checkbox" id="log-filter-all" checked> All
	  </label>
	  <label style="white-space: nowrap;">
	    <input type="checkbox" class="log-filter" value="1,2,3" checked> Position A
	  </label>
	  <label style="white-space: nowrap;">
	    <input type="checkbox" class="log-filter" value="18,19" checked> Position B
	  </label>
	  <label style="white-space: nowrap;">
	    <input type="checkbox" class="log-filter" value="5" checked> Static A
	  </label>
	  <label style="white-space: nowrap;">
	    <input type="checkbox" class="log-filter" value="24" checked> Static B
	  </label>
	  <label style="white-space: nowrap;">
	    <input type="checkbox" class="log-filter" value="21" checked> AtoN
	  </label>
	  <label style="white-space: nowrap;">
	    <input type="checkbox" class="log-filter" value="4" checked> Base Stn
	  </label>
	  <label style="white-space: nowrap;">
	    <input type="checkbox" class="log-filter" value="8,17,25,26" checked> Binary
	  </label>
	  <label style="white-space: nowrap;">
	    <input type="checkbox" class="log-filter" value="9" checked> SAR
	  </label>
	  <input type="text" id="live-log-search" placeholder="Search logs..." style="width:100%; margin-top:5px; padding:3px; font-size:12px;">
</div>

        <div id="live-logs-content"></div>
    </div>

    <!-- Socket.IO client (local copy) -->
    <script src="socket.io.min.js"></script>
    <!-- Leaflet JS (from CDN, without integrity) -->
    <script src="https://unpkg.com/leaflet@1.9.3/dist/leaflet.js" crossorigin=""></script>
    <script>
  // Clear vessel data from localStorage immediately
  localStorage.removeItem('vesselData');
  
  // Check if this is the first visit
  document.addEventListener('DOMContentLoaded', function() {
    if (!localStorage.getItem('hasVisitedBefore')) {
      // First time visit - show welcome overlay
      document.getElementById('welcome-overlay').style.display = 'block';
      
      // Add event listener to close button
      document.getElementById('welcome-close').addEventListener('click', function() {
        document.getElementById('welcome-overlay').style.display = 'none';
        // Set flag in localStorage to remember this user has visited before
        localStorage.setItem('hasVisitedBefore', 'true');
      });
    }
  });
     
     // Function to get selected vessel classes
     function getSelectedClasses() {
       const classA = document.getElementById('class-a').checked;
       const classB = document.getElementById('class-b').checked;
       const classSAR = document.getElementById('class-sar').checked;
       const classBASE = document.getElementById('class-base').checked;
       const classAtoN = document.getElementById('class-aton').checked;
       
       // Build the classes string based on checked boxes
       const selectedClasses = [];
       if (classA) selectedClasses.push('A');
       if (classB) selectedClasses.push('B');
       if (classSAR) selectedClasses.push('SAR');
       if (classBASE) selectedClasses.push('BASE');
       if (classAtoN) selectedClasses.push('AtoN');
       
       // Ensure at least one class is selected
       if (selectedClasses.length === 0) {
         document.getElementById('class-a').checked = true;
         selectedClasses.push('A');
       }
       
       return selectedClasses.join(',');
     }
        // Detect if the device is touch capable.
        const isMobile = ('ontouchstart' in window || navigator.maxTouchPoints > 0);

	const TOOLTIP_ZOOM_THRESHOLD = 12;

	let currentLoadedImageUrl = '';

	const vesselSolidTracks = {};
	const vesselColoredTracks = {};
	// Store the vessel-to-receiver polyline
	let receiverPolyline = null;
	let receiverDistanceLabel = null;
	let lastReceiverUpdateTime = 0;
	const RECEIVER_UPDATE_THROTTLE = 250; // ms - reduced from 500ms to be more responsive
	let receiverUpdateInterval = null; // For periodic updates
	
	// Variables for concentric radius circles
	let radiusCircles = [];
	let radiusLabels = [];

        // Flag to track if the user manually hid the details overlay.
        let detailsOverlayHidden = false;
 let userLatLng = null;
 
 // Store the selected receiver coordinates
 let selectedReceiverCoords = null;

	let messageTypeNames = {};

	fetch('/message_types.json')
	  .then(res => {
	    if (!res.ok) throw new Error(`Failed to load message types: ${res.status}`);
	    return res.json();
	  })
	  .then(json => {
	    messageTypeNames = json;
	  })
	  .catch(err => console.error(err));

	let mids = {};
	fetch('mids.json')
	  .then(response => {
	    if (!response.ok) {
	      throw new Error(`Network error: ${response.status}`);
	    }
	    return response.json();
	  })
	  .then(data => {
	    mids = data;
	  })
	  .catch(error => {
	    console.error('Error loading mids.json:', error);
	  });

        // Global variable to store the currently focused vessel (if any).
        let focusedVessel = null;

	const receiverData = {};    // Stores receiver info keyed by receiver ID.

	// Create the base layers
	const googleSat = L.tileLayer('https://{s}.google.com/vt/lyrs=s,h&x={x}&y={y}&z={z}', {
	  maxZoom: 20,
	  subdomains: ['mt0', 'mt1', 'mt2', 'mt3'],
	  attribution: '&copy; Google'
	});

	const osm = L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
	  attribution: '&copy; OpenStreetMap'
	});

	// Object to hold your base layers.
	const baseLayers = {
	  "Google": googleSat,
	  "OSM": osm
	};

	// Initialize the map with a default base layer
	const map = L.map('map').setView([55.0, -3.0], 5);
	osm.addTo(map);

	// Add the layers control.
	L.control.layers(baseLayers, null, { position: 'topleft' }).addTo(map);

	// Listen for the base layer change event.
	map.on('baselayerchange', function(e) {
	  // 'e.name' holds the key ("Google" or "OSM")
	  localStorage.setItem('selectedBasemap', e.name);
	  if (map.hasLayer(openSeaMapLayer)) {
	    openSeaMapLayer.bringToFront();
	  }
	});

        // OpenSeaMap overlay layer (enabled by default).
        const openSeaMapLayer = L.tileLayer('https://tiles.openseamap.org/seamark/{z}/{x}/{y}.png', {
          attribution: 'Map data: &copy; OpenSeaMap'
        }).addTo(map);
	openSeaMapLayer.bringToFront();

    const allowedMessageTypes = {
      "PositionReport": true,
      "ShipStaticData": true,
      "StaticDataReport": true,
      "StandardClassBPositionReport": true,
      "ExtendedClassBPositionReport": true,
      "AidsToNavigationReport": true,
      "BaseStationReport": true,
      "BinaryBroadcastMessage": true,
      "StandardSearchAndRescueAircraftReport": true
    };

	map.on('mousemove', function(e) {
	  if (!focusedVessel) {
	    document.getElementById('latlong-display').textContent =
	      `${e.latlng.lat.toFixed(5)}, ${e.latlng.lng.toFixed(5)}`;
	  }
	});

        // Helper function to clear all live logs and show a placeholder.
        function clearLiveLogs() {
          liveLogsContent.innerHTML = "<div class='placeholder' style='font-family: monospace; font-size: 12px; color: #888; text-align: center; padding: 10px;'>Waiting for next packet...</div>";
        }


map.on('click', () => {
  // Clear selected receiver when clicking on the map
  if (selectedReceiverId && receiverMarkers[selectedReceiverId]) {
    receiverMarkers[selectedReceiverId].setIcon(createReceiverIcon());
    selectedReceiverId = null;
    
    // Clear any radius circles
    clearRadiusCircles();
    
    // Show a notification that filter is removed
    const notification = document.createElement('div');
    notification.textContent = `Receiver filter removed`;
    notification.style.position = 'absolute';
    notification.style.top = '100px';
    notification.style.left = '50%';
    notification.style.transform = 'translateX(-50%)';
    notification.style.background = 'rgba(255,255,255,0.8)';
    notification.style.padding = '10px';
    notification.style.borderRadius = '5px';
    notification.style.zIndex = '1000';
    document.body.appendChild(notification);
    setTimeout(() => document.body.removeChild(notification), 2000);
    
    sendSummaryRequest();
  }
  
  if (focusedVessel) {
    document.getElementById('show-paths').checked = false;
    const vessel = vesselData[focusedVessel];
    vesselMarkers[focusedVessel].getTooltip().setContent(vessel.Name);
    vesselMarkers[focusedVessel].setZIndexOffset(0);
    
    // Remove vessel-receiver connection
    if (receiverPolyline) {
      map.removeLayer(receiverPolyline);
      receiverPolyline = null;
    }
    
    if (receiverDistanceLabel) {
      // Handle both marker and tooltip types for backward compatibility
      if (typeof receiverDistanceLabel.closeTooltip === 'function') {
        receiverDistanceLabel.closeTooltip();
      }
      map.removeLayer(receiverDistanceLabel);
      receiverDistanceLabel = null;
    }
    
    // Clear any existing update interval
    if (receiverUpdateInterval) {
      clearInterval(receiverUpdateInterval);
      receiverUpdateInterval = null;
    }
    
    focusedVessel = null;
    unsubscribeInstantUpdates();

    // Hide detail overlay and all related buttons when no vessel is focused.
    document.getElementById('vessel-detail').style.display = 'none';
    document.getElementById('toggle-detail-overlay').style.display = 'none';
    document.getElementById('toggle-detail-overlay').textContent = 'Show';
    document.getElementById('live-logs').style.display = 'none';
    document.getElementById('stats-button').style.display = 'none';

    clearLiveLogs();
    updateFocussedVisibility();
    updateStationaryMarkers();
  }
  sendSummaryRequest();
});

function sendSummaryRequest() {
  const onlyTracked = document.getElementById('only-focussed').checked;
  
  if (onlyTracked && focusedVessel) {
    const filterParams = {
      UserID: parseInt(focusedVessel, 10),
      classes: getSelectedClasses()
    };
    
    // Add receiver filter if a receiver is selected
    if (selectedReceiverId) {
      filterParams.receiver = parseInt(selectedReceiverId, 10);
    }
    console.log(`sendSummaryRequest: onlyTracked for vessel ${focusedVessel}`);
    socket.emit("requestSummary", JSON.stringify(filterParams));
    updateOverlay();
    return;
  }
  
  const center = map.getCenter();
  const bounds = map.getBounds();
  const radius = center.distanceTo(bounds.getNorthEast()) * 1.5;
  const maxAge = parseInt(document.getElementById("age-slider").value, 10);
  const zoom   = map.getZoom();
  
  // Dynamically choose updatePeriod based on zoom ranges
  let updatePeriod;
  if (zoom >= 13) {
    updatePeriod = 5;
  } else if (zoom >= 10) {
    updatePeriod = 10;
  } else {
    updatePeriod = 15;
  }

  const filterParams = {
    latitude:     center.lat,
    longitude:    center.lng,
    radius:       radius,
    maxResults:   500,
    maxAge:       maxAge,
    updatePeriod: updatePeriod,
    classes:      getSelectedClasses()
  };
  
  // Add receiver filter if a receiver is selected
  if (selectedReceiverId) {
    filterParams.receiver = parseInt(selectedReceiverId, 10);
  }

  if (!document.getElementById('stationary').checked) {
    filterParams.minSpeed = 1;
  }
  
  
  // Get all checked groups
  const checkedGroups = [];
  for (const groupName in typeGroupCheckboxStates) {
    if (typeGroupCheckboxStates[groupName] !== false) {
      checkedGroups.push(groupName);
    }
  }
  
  // Handle filtering by type groups
  if (checkedGroups.length === 1) {
    // If only one group is checked, use that for filtering
    const groupName = checkedGroups[0];
    const groupId = typeGroupMapping[groupName];
    
    if (groupId !== undefined) {
      console.log(`Filtering by single type group: ${groupId}`);
      filterParams.typeGroups = groupId.toString();
      
      // Debug output to verify the request
      console.log("Sending filter request:", JSON.stringify(filterParams, null, 2));
    }
  } else if (checkedGroups.length > 1) {
    // Multiple groups checked - include all of them
    const groupIds = [];
    for (const groupName of checkedGroups) {
      const groupId = typeGroupMapping[groupName];
      if (groupId !== undefined) {
        groupIds.push(groupId);
      }
    }
    
    if (groupIds.length > 0) {
      filterParams.typeGroups = groupIds.join(',');
    }
  }
  
  // IMPORTANT: Don't stringify the object - send it directly
  socket.emit("requestSummary", filterParams);
  updateOverlay();
}

// Add event listeners for class checkboxes
document.getElementById('class-a').addEventListener('change', sendSummaryRequest);
document.getElementById('class-b').addEventListener('change', sendSummaryRequest);
document.getElementById('class-sar').addEventListener('change', sendSummaryRequest);
document.getElementById('class-base').addEventListener('change', sendSummaryRequest);
document.getElementById('class-aton').addEventListener('change', sendSummaryRequest);

        // Mapping objects for Nav Status, and Static Message Types.

        const navigationalStatusMapping = {
          0: "Using Engine",
          1: "At Anchor",
          2: "Not Under Command",
          3: "Restricted Manoeuvrability",
          4: "Constrained by Draft",
          5: "Moored",
          6: "Aground",
          7: "Engaged in Fishing",
          8: "Under Way Sailing",
          15: "Unknown"
        };

        const staticTypeMapping = {
          0: "Not available",
          1: "Reserved",
          2: "Reserved",
          3: "Reserved",
          4: "Reserved",
          5: "Reserved",
          6: "Reserved",
          7: "Reserved",
          8: "Reserved",
          9: "Reserved",
          10: "Reserved",
          11: "Reserved",
          12: "Reserved",
          13: "Reserved",
          14: "Reserved",
          15: "Reserved",
          16: "Reserved",
          17: "Reserved",
          18: "Reserved",
          19: "Reserved",
          20: "Wing in ground (WIG)",
          21: "Wing in ground (WIG)",
          22: "Wing in ground (WIG)",
          23: "Wing in ground (WIG)",
          24: "Wing in ground (WIG)",
          25: "Wing in ground (WIG)",
          26: "Wing in ground (WIG)",
          27: "Wing in ground (WIG)",
          28: "Wing in ground (WIG)",
          29: "Wing in ground (WIG)",
          30: "Fishing",
          31: "Towing",
          32: "Towing: length>200m, breadth>25m",
          33: "Dredging or underwater ops",
          34: "Diving ops",
          35: "Military ops",
          36: "Sailing",
          37: "Pleasure Craft",
          38: "Reserved",
          39: "Reserved",
          40: "High speed craft (HSC)",
          41: "High speed craft (HSC)",
          42: "High speed craft (HSC)",
          43: "High speed craft (HSC)",
          44: "High speed craft (HSC)",
          45: "High speed craft (HSC)",
          46: "High speed craft (HSC)",
          47: "High speed craft (HSC)",
          48: "High speed craft (HSC)",
          49: "High speed craft (HSC)",
          50: "Pilot Vessel",
          51: "Search and Rescue",
          52: "Tug",
          53: "Port Tender",
          54: "Anti-pollution equipment",
          55: "Law Enforcement",
          56: "Spare - Local Vessel",
          57: "Spare - Local Vessel",
          58: "Medical Transport",
          59: "Noncombatant ship",
          60: "Passenger",
          61: "Passenger",
          62: "Passenger",
          63: "Passenger",
          64: "Passenger",
          65: "Passenger",
          66: "Passenger",
          67: "Passenger",
          68: "Passenger",
          69: "Passenger",
          70: "Cargo",
          71: "Cargo",
          72: "Cargo",
          73: "Cargo",
          74: "Cargo",
          75: "Cargo",
          76: "Cargo",
          77: "Cargo",
          78: "Cargo",
          79: "Cargo",
          80: "Tanker",
          81: "Tanker",
          82: "Tanker",
          83: "Tanker",
          84: "Tanker",
          85: "Tanker",
          86: "Tanker",
          87: "Tanker",
          88: "Tanker",
          89: "Tanker",
          90: "Other Type",
          91: "Other Type",
          92: "Other Type",
          93: "Other Type",
          94: "Other Type",
          95: "Other Type",
          96: "Other Type",
          97: "Other Type",
          98: "Other Type",
          99: "Other Type"
        };

	const staticAtoNTypeMapping = {
	  0:  "Default, Type of AtoN not specified",
	  1:  "Reference point",
	  2:  "RACON",
	  3:  "Fixed structures off-shore",
	  4:  "Emergency Wreck Marking Buoy",
	  5:  "Light, without sectors",
	  6:  "Light, with sectors",
	  7:  "Leading Light Front",
	  8:  "Leading Light Rear",
	  9:  "Beacon, Cardinal N",
	  10: "Beacon, Cardinal E",
	  11: "Beacon, Cardinal S",
	  12: "Beacon, Cardinal W",
	  13: "Beacon, Port hand",
	  14: "Beacon, Starboard hand",
	  15: "Beacon, Preferred Channel port hand",
	  16: "Beacon, Preferred Channel starboard hand",
	  17: "Beacon, Isolated danger",
	  18: "Beacon, Safe water",
	  19: "Beacon, Special mark",
	  20: "Cardinal Mark N",
	  21: "Cardinal Mark E",
	  22: "Cardinal Mark S",
	  23: "Cardinal Mark W",
	  24: "Port hand Mark",
	  25: "Starboard hand Mark",
	  26: "Preferred Channel Port hand",
	  27: "Preferred Channel Starboard hand",
	  28: "Isolated danger",
	  29: "Safe Water",
	  30: "Special Mark",
	  31: "Light Vessel/LANBY/Rigs"
	};


// Direct mapping from vessel type groups to server group IDs
const typeGroupMapping = {
  "Wing in ground": 2,
  "Fishing": 3,
  "Towing": 4,
  "Dredging": 6,
  "Diving": 7,
  "Military": 8,
  "Sailing": 9,
  "Pleasure": 10,
  "High speed craft": 11,
  "Pilot": 12,
  "Search and Rescue": 13,
  "Tug": 14,
  "Port Tender": 15,
  "Anti-pollution": 16,
  "Law Enforcement": 17,
  "Medical": 19,
  "Passenger": 21,
  "Cargo": 22,
  "Tanker": 23,
  "Other": 24
};

// Define vessel type groups for better color differentiation
const vesselTypeGroups = {
  "Wing in ground": [20, 21, 22, 23, 24, 25, 26, 27, 28, 29],
  "Fishing": [30],
  "Towing": [31, 32],
  "Dredging": [33],
  "Diving": [34],
  "Military": [35],
  "Sailing": [36],
  "Pleasure": [37],
  "High speed craft": [40, 41, 42, 43, 44, 45, 46, 47, 48, 49],
  "Pilot": [50],
  "Search and Rescue": [51],
  "Tug": [52],
  "Port Tender": [53],
  "Anti-pollution": [54],
  "Law Enforcement": [55],
  "Medical": [58],
  "Passenger": [60, 61, 62, 63, 64, 65, 66, 67, 68, 69],
  "Cargo": [70, 71, 72, 73, 74, 75, 76, 77, 78, 79],
  "Tanker": [80, 81, 82, 83, 84, 85, 86, 87, 88, 89],
  "Other": [90, 91, 92, 93, 94, 95, 96, 97, 98, 99]
};

// Map each group to a distinct color with maximum contrast
const vesselGroupColors = {
  "Wing in ground": "#FF4500", // Orange Red
  "Fishing": "#006400",        // Dark Green
  "Towing": "#8B4513",         // Saddle Brown
  "Dredging": "#00FFFF",       // Cyan
  "Diving": "#000080",         // Navy Blue
  "Military": "#8A2BE2",       // Blue Violet
  "Sailing": "#0082C8",        // Vibrant Blue
  "Pleasure": "#FF1493",       // Deep Pink
  "High speed craft": "#E6194B", // Vibrant Red
  "Pilot": "#FFD700",          // Gold
  "Search and Rescue": "#00BFFF", // Deep Sky Blue
  "Tug": "#00FF00",            // Lime
  "Port Tender": "#FF8C00",    // Dark Orange
  "Anti-pollution": "#9ACD32", // Yellow Green
  "Law Enforcement": "#FF6347", // Tomato
  "Medical": "#DC143C",        // Crimson
  "Passenger": "#FFFF00",      // Yellow
  "Cargo": "#800000",          // Maroon
  "Tanker": "#4682B4",         // Steel Blue
  "Other": "#20B2AA"           // Light Sea Green
};

// Fallback color palette for any types not in the groups
const vesselColorPalette = [
  "#3CB44B",  // Vibrant Green
  "#4363d8",  // Blue
  "#f58231",  // Orange
  "#911eb4",  // Purple
  "#42d4f4",  // Cyan
  "#f032e6",  // Magenta
  "#bfef45",  // Lime
  "#fabebe",  // Pink
  "#469990",  // Teal
  "#e6beff",  // Lavender
  "#9A6324",  // Brown
  "#fffac8",  // Beige
  "#800000",  // Maroon
  "#aaffc3",  // Mint
  "#808000",  // Olive
  "#ffd8b1",  // Apricot
  "#000075",  // Navy
  "#a9a9a9",  // Grey
  "#ffffff",  // White
  "#000000"   // Black
];

const friendlyMessageTypes = {
  "PositionReport": "Position (A)",
  "ShipStaticData": "Static (A)",
  "StaticDataReport": "Static (B)",
  "StandardClassBPositionReport": "Position (B std)",
  "ExtendedClassBPositionReport": "Position (B ext)",
  "AidsToNavigationReport": "AtoN",
  "BaseStationReport": "Base Station",
  "BinaryBroadcastMessage": "Binary Broadcast",
  "StandardSearchAndRescueAircraftReport": "SAR"
};

function djb2Hash(str) {
  let hash = 8393;
  for (let i = 0; i < str.length; i++) {
    hash = ((hash << 5) + hash) + str.charCodeAt(i); // hash * 33 + c
  }
  return hash >>> 0; // Ensure a positive integer
}

function hashStringToIndex(description, modulo) {
  return djb2Hash(description) % modulo;
}

// Change receiverMarkers from an array to an object.
let receiverMarkers = {};
// Track the currently selected receiver
let selectedReceiverId = null;

function refreshReceivers() {
  // Get the maxage value from the age slider
  const maxAgeHours = parseInt(document.getElementById("age-slider").value, 10);
  
  // Use the maxage parameter in the API request instead of filtering client-side
  fetch(`/receivers?maxage=${maxAgeHours}`)
    .then(response => {
      if (!response.ok) {
        throw new Error(`Network error: ${response.status}`);
      }
      return response.json();
    })
    .then(receivers => {
      const currentReceiverIDs = new Set();

      if (Array.isArray(receivers) && receivers.length > 0) {
        receivers.forEach(receiver => {
          const id = String(receiver.id);
          currentReceiverIDs.add(id);

          const lat = parseFloat(receiver.latitude);
          const lng = parseFloat(receiver.longitude);

          if (isNaN(lat) || isNaN(lng)) {
            return;
          }

          // Check if lastseen exists and is not undefined
          if (!receiver.lastseen) {
            return; // Skip this receiver if lastseen is missing
          }

          let updatedLocalTime;
          try {
            // Try to create a new Date object from receiver.lastseen.
            updatedLocalTime = new Date(receiver.lastseen);
            
            // Check if the date is invalid (NaN)
            if (isNaN(updatedLocalTime)) {
              console.warn("Invalid date for receiver id", id, "lastseen:", receiver.lastseen);
              // Try to handle common formats if the date is invalid.
              updatedLocalTime = new Date(receiver.lastseen.replace(/-/g, '/'));
              if (isNaN(updatedLocalTime)) {
                // If it's still invalid, log the failure and set a default message
                console.error("Failed to parse lastseen date for receiver id", id);
                updatedLocalTime = "Invalid date";
              }
            }
          } catch (error) {
            console.error("Error processing date for receiver id", id, error);
            updatedLocalTime = "Invalid date";
          }
          
          // No need to filter by age here anymore since we're using the server-side maxage parameter

          // Create or update the receiver marker.
          if (receiverMarkers[id]) {
            // Update marker position.
            receiverMarkers[id].setLatLng([lat, lng]);

            let linksHTML = "";
            if (receiver.url && receiver.url.trim() !== "") {
              linksHTML += `<a href="${receiver.url}" target="_blank">Website</a>`;
            }
            if (receiver.metrics) {
              if (linksHTML !== "") {
                linksHTML += " | ";
              }
              linksHTML += `<a href="/metrics.html?id=${id}" target="_blank">Metrics</a>`;
            }
            if (receiver.state) {
              if (linksHTML !== "") {
                linksHTML += " | ";
              }
              linksHTML += `<a href="/coverage.html?id=${id}" target="_blank">Coverage</a>`;
            }
            const popupContent = `
              <strong><a href="/metrics/receiver.html?receiver=${receiver.id}" target="_blank">${receiver.name}</a></strong><br>
              ${receiver.description}<br>
              Seen: ${updatedLocalTime === "Invalid date" ? updatedLocalTime : updatedLocalTime.toLocaleString()}<br>
              ${linksHTML}
            `;
            // Update the popup content.
            receiverMarkers[id].setPopupContent(popupContent);
          } else {
            const marker = L.marker([lat, lng], { icon: createReceiverIcon() }).addTo(map);

            let linksHTML = "";
            if (receiver.url && receiver.url.trim() !== "") {
              linksHTML += `<a href="${receiver.url}" target="_blank">Website</a>`;
            }
            if (receiver.metrics) {
              if (linksHTML !== "") {
                linksHTML += " | ";
              }
              linksHTML += `<a href="/metrics.html?id=${id}" target="_blank">Metrics</a>`;
            }
            if (receiver.state) {
              if (linksHTML !== "") {
                linksHTML += " | ";
              }
              linksHTML += `<a href="/coverage.html?id=${id}" target="_blank">Coverage</a>`;
            }
            const popupContent = `
              <strong><a href="/metrics/receiver.html?receiver=${receiver.id}" target="_blank">${receiver.name}</a></strong><br>
              ${receiver.description}<br>
              Seen: ${updatedLocalTime === "Invalid date" ? updatedLocalTime : updatedLocalTime.toLocaleString()}<br>
              ${linksHTML}
            `;
            marker.bindPopup(popupContent, { autoPan: true });

            // Bind tooltip showing a label for a receiver.
            marker.bindTooltip(`${receiver.name}`, {
              permanent: true,
              interactive: true,
              direction: 'top',
              className: 'receiver-tooltip'
            }).openTooltip();

            // Add click event handler for receiver markers
            marker.on('click', function(e) {
              // Stop propagation to prevent map click from firing
              L.DomEvent.stopPropagation(e);
              
              // Toggle selection state
              if (selectedReceiverId === id) {
                // Deselect if already selected
                selectedReceiverId = null;
                marker.setIcon(createReceiverIcon()); // Reset to default icon
                
                // Show a notification that filter is removed
                const notification = document.createElement('div');
                notification.textContent = `Receiver filter removed`;
                notification.style.position = 'absolute';
                notification.style.top = '100px';
                notification.style.left = '50%';
                notification.style.transform = 'translateX(-50%)';
                notification.style.background = 'rgba(255,255,255,0.8)';
                notification.style.padding = '10px';
                notification.style.borderRadius = '5px';
                notification.style.zIndex = '1000';
                document.body.appendChild(notification);
                setTimeout(() => document.body.removeChild(notification), 2000);
              } else {
                // Deselect previous receiver if any
                if (selectedReceiverId && receiverMarkers[selectedReceiverId]) {
                  receiverMarkers[selectedReceiverId].setIcon(createReceiverIcon());
                }
                
                // Select this receiver
                selectedReceiverId = id;
                
                // Use a different icon to show it's selected
                const selectedIcon = createReceiverIcon('blue');
                marker.setIcon(selectedIcon);
                
                // Store the receiver coordinates for later use
                selectedReceiverCoords = [lat, lng];
                
                // Note: We'll draw the circles after receiving data from the server
                
                // Show a notification that filter is applied
                const notification = document.createElement('div');
                notification.textContent = `Filtering by receiver: ${receiver.name}`;
                notification.style.position = 'absolute';
                notification.style.top = '100px';
                notification.style.left = '50%';
                notification.style.transform = 'translateX(-50%)';
                notification.style.background = 'rgba(255,255,255,0.8)';
                notification.style.padding = '10px';
                notification.style.borderRadius = '5px';
                notification.style.zIndex = '1000';
                document.body.appendChild(notification);
                setTimeout(() => document.body.removeChild(notification), 2000);
              }
              
              // Request updated data with or without the receiver filter
              sendSummaryRequest();
            });
            
            receiverMarkers[id] = marker;
          }

          // Store receiver info with an extra flag.
          receiverData[id] = {
            Name: receiver.name,
            LastUpdated: receiver.lastseen,
            UserID: id,
            isReceiver: true,
            // You can store other properties (url, description, etc.) if needed.
            url: receiver.url,
            description: receiver.description
          };
        });
      } else {
        console.warn("No receivers found.");
      }

      // Remove stale markers/data.
      for (const id in receiverMarkers) {
        if (!currentReceiverIDs.has(id)) {
          map.removeLayer(receiverMarkers[id]);
          delete receiverMarkers[id];
          delete receiverData[id];
        }
      }
    })
    .catch(error => {
      console.error('Error fetching receivers:', error);
    });
}

// Function to calculate maximum distance from receiver to any vessel
function calculateMaxDistance(receiverLatLng) {
  if (!receiverLatLng) return 0;
  
  let maxDistance = 0;
  let vesselCount = 0;
  console.log("Calculating max distance for receiver at", receiverLatLng);
  
  // Loop through all vessels to find the maximum distance
  for (const UserID in vesselData) {
    // Skip non-vessel entries
    if (UserID.length !== 9 || vesselData[UserID].isReceiver) continue;
    
    const vessel = vesselData[UserID];
    
    // Check if we should filter by receiver
    let includeVessel = true;
    if (selectedReceiverId) {
      // Try different ways the receiver ID might be stored
      if (vessel.ReceiverIDs && Array.isArray(vessel.ReceiverIDs)) {
        // Check if the selected receiver is in the array
        includeVessel = vessel.ReceiverIDs.includes(parseInt(selectedReceiverId));
      } else if (vessel.receiver_id !== undefined) {
        // Check if the vessel's receiver_id matches
        includeVessel = vessel.receiver_id == selectedReceiverId;
      } else if (vessel.ReceiverID !== undefined) {
        // Check if the vessel's ReceiverID matches
        includeVessel = vessel.ReceiverID == selectedReceiverId;
      } else {
        // If we can't determine the receiver, include all vessels
        includeVessel = true;
      }
    }
    
    if (!includeVessel) continue;
    
    const lat = vessel.Latitude;
    const lon = vessel.Longitude;
    
    if (typeof lat !== 'number' || typeof lon !== 'number') continue;
    
    // Calculate distance using Leaflet's built-in method
    const vesselLatLng = L.latLng(lat, lon);
    const distance = receiverLatLng.distanceTo(vesselLatLng) / 1000; // Convert to km
    
    if (distance > maxDistance) {
      maxDistance = distance;
    }
    vesselCount++;
  }
  
  console.log(`Found ${vesselCount} vessels for receiver, max distance: ${maxDistance} km`);
  
  // If no vessels found, use a default distance
  if (maxDistance === 0) {
    maxDistance = 10; // Default to 10 km if no vessels found
    console.log("No vessels found, using default distance of 10 km");
  }
  
  return maxDistance;
}

// Function to convert kilometers to nautical miles
function kmToNM(km) {
  return km * 0.539957;
}

// Function to clear radius circles and labels
function clearRadiusCircles() {
  radiusCircles.forEach(circle => {
    if (circle) map.removeLayer(circle);
  });
  radiusCircles = [];
  
  radiusLabels.forEach(label => {
    if (label) map.removeLayer(label);
  });
  radiusLabels = [];
}

// Function to calculate position for radius label (east of center)
function calculateLabelPosition(center, radiusKm) {
  // Validate center coordinates
  if (!center || typeof center.lat !== 'number' || typeof center.lng !== 'number' ||
      isNaN(center.lat) || isNaN(center.lng)) {
    console.warn('Invalid center coordinates for label position');
    return null;
  }
  
  // Convert radius from km to degrees longitude (approximate)
  // This is a simplified calculation that works for small distances
  const radiusLng = radiusKm / (111.32 * Math.cos(center.lat * Math.PI / 180));
  
  // Position the label to the east of the center
  return L.latLng(center.lat, center.lng + radiusLng);
}

// Function to draw concentric radius circles around a receiver
function drawRadiusCircles(receiverCoords) {
  // Clear any existing circles and labels
  clearRadiusCircles();
  
  const receiverLatLng = L.latLng(receiverCoords[0], receiverCoords[1]);
  
  // Calculate maximum distance from receiver to any vessel
  const maxDistanceKm = calculateMaxDistance(receiverLatLng);
  if (maxDistanceKm <= 0) return;
  
  // Create 3 evenly spaced circles
  for (let i = 1; i <= 3; i++) {
    const radiusKm = maxDistanceKm * i / 3;
    const radiusMeters = radiusKm * 1000; // Leaflet uses meters for circle radius
    
    // Create circle
    const circle = L.circle(receiverLatLng, {
      radius: radiusMeters,
      color: 'grey',
      fillColor: 'transparent',
      weight: 1.5,
      opacity: 0.7,
      dashArray: '5, 5'  // Makes the line dashed
    }).addTo(map);
    
    radiusCircles.push(circle);
    
    // Convert to nautical miles for the label
    const radiusNM = kmToNM(radiusKm).toFixed(1);
    
    // Calculate position for the label (east of the center)
    const labelLatLng = calculateLabelPosition(receiverLatLng, radiusKm);
    
    // Only create label if we have valid coordinates
    if (labelLatLng) {
      // Create label
      const label = L.tooltip({
        permanent: true,
        direction: 'center',
        className: 'distance-tooltip'
      })
      .setLatLng(labelLatLng)
      .setContent(`${radiusNM} NM`)
      .addTo(map);
      
      radiusLabels.push(label);
    }
  }
}

function getColorForVesselTypeConsistent(type) {
  if (!type) return "blue";
  
  // Find which group this vessel type belongs to
  for (const [groupName, typeArray] of Object.entries(vesselTypeGroups)) {
    if (typeArray.includes(type)) {
      return vesselGroupColors[groupName];
    }
  }
  
  // If not found in any group, fall back to the original hash method
  const description = staticTypeMapping[type] || type;
  const index = hashStringToIndex(description, vesselColorPalette.length);
  return vesselColorPalette[index];
}

// Create a custom boat icon using your existing SVG, but with the stroke and fill set to the vessel type's color.
function createBoatIcon(type, heading = 0, fillOpacity = 0.5) {
  const color = getColorForVesselTypeConsistent(type);
  const svgHtml = `
    <svg width="20" height="50" viewBox="0 0 20 50"
         style="transform: rotate(${heading}deg); transform-origin: center;">
      <path
        d="M5 45 L15 45 L15 30 Q10 5,5 30 Z"
        stroke="${color}"
        stroke-width="2"
        fill="${color}"
        fill-opacity="${fillOpacity}"
      />
    </svg>
  `;
  return L.divIcon({
    html: svgHtml,
    className: 'boat-icon',
    iconSize: [20, 50],
    iconAnchor: [10, 25],
    popupAnchor: [0, -25],
  });
}

function getCustomIcon(vesselState, iconUrl) {
  // Determine the heading as before
  const heading = (typeof vesselState.TrueHeading === 'number' && vesselState.TrueHeading < 360)
      ? vesselState.TrueHeading
      : (typeof vesselState.Cog === 'number' && vesselState.Cog >= 0 && vesselState.Cog < 360)
        ? vesselState.Cog
        : 0;
  
  return L.divIcon({
    html: `<div class="non-vessel-icon-image" style="
              width: 30px;
              height: 30px;
              background-image: url('${iconUrl}');
              background-size: contain;
              background-repeat: no-repeat;
              transform: rotate(${heading}deg);
            "></div>`,
    className: 'non-vessel-icon', // still used for container styling if needed
    iconSize: [30, 30],
    iconAnchor: [15, 15], // center of the 30x30 div
    popupAnchor: [0, -15]
  });
}


function getVesselIcon(vesselState) {
  // For lower zoom levels, show a simple circle marker.
  if (map.getZoom() < 10) {
    return createCircleIcon(vesselState);
  }
  
  // Check the AISClass value for special cases.
  if (vesselState.AISClass) {
    const aisClass = vesselState.AISClass.trim();
    if (aisClass === "AtoN") {
      return getCustomIcon(vesselState, 'images/aids-to-navigation.png');
    } else if (aisClass === "BASE") {
      return getCustomIcon(vesselState, 'images/base-station.png');
    } else if (aisClass === "SAR") {
      return getCustomIcon(vesselState, 'images/sar-aircraft.png');
    }
  }
  
  // Default: compute the vessel's heading and create a boat icon.
  const heading = (typeof vesselState.TrueHeading === 'number' && vesselState.TrueHeading < 360)
                    ? vesselState.TrueHeading
                    : (typeof vesselState.Cog === 'number' && vesselState.Cog >= 0 && vesselState.Cog < 360)
                      ? vesselState.Cog
                      : 0;
  return createBoatIcon(vesselState.Type, heading);
}

function attachImageClick(imgElem) {
  imgElem.addEventListener('click', function(e) {
    e.stopPropagation(); // Prevent the click from bubbling up if needed.
    openImageModal(this.src);
  });
}

// Preload the vessel image before inserting it into the container.
function loadVesselImage(url, container) {
  url = url.trim();
  // Create the image element.
  const img = document.createElement('img');
  img.id = 'vessel-image';
  img.style.maxWidth = '100%';
  img.style.margin = '5px 0';
  img.style.height = 'auto';
  img.style.cursor = 'pointer';
  img.alt = 'Vessel Image';

  // Attach the click event immediately.
  img.addEventListener('click', function(e) {
    e.stopPropagation();
    // Use the current src of the image when clicked.
    openImageModal(img.src);
  });

  // When the image loads, append it to the container.
  img.onload = function() {
    // Remove any previously appended image with the same id.
    const existingImg = container.querySelector('#vessel-image');
    if (existingImg) {
      existingImg.remove();
    }
    container.appendChild(img);
  };

  // Handle loading errors.
  img.onerror = function() {
    console.error("Image failed to load:", url);
    // Optionally, retry loading after a delay or show a fallback image.
  };

  // Set the image source (this starts the asynchronous load).
  img.src = url;
}

function updateVesselDetailHeader(UserID) {
  const textContainer = document.getElementById('vessel-header-text');

  // Build header HTML: Name, Lookup, Link
  let headerHtml = `
    <h4 style="margin:0;padding:0;">
      ${vesselData[UserID].AISClass === 'A' || vesselData[UserID].AISClass === 'B'
        ? `<a href="/vesselhistory.html?UserID=${UserID}" target="_blank" style="text-decoration: underline; color: inherit; font-size:1.2em;">${vesselData[UserID].Name}</a>`
        : `<span style="font-size:1.2em;">${vesselData[UserID].Name}</span>`}<br>
      ${vesselData[UserID].AISClass === 'A' || vesselData[UserID].AISClass === 'B'
        ? `<a href="https://www.vesselfinder.com/vessels/details/${vesselData[UserID].UserID}"
         target="_blank">VesselFinder</a>
      |`
        : ``}
      <span id="copy-link" style="cursor:pointer; color:blue;">Link</span>
  `;

  // Add Messages popup link if DecodedBinary exists
  if (vesselData[UserID].DecodedBinary) {
    headerHtml += `
      |
      <span id="show-binary-messages" style="cursor:pointer; color:blue;">
        Messages
      </span>
    `;
  }

  headerHtml += `</h4>`;
  textContainer.innerHTML = headerHtml;


  // --- now restore the image logic ---
  const imageContainer = document.getElementById('vessel-header-image');
  if (vesselData[UserID].ImageURL) {
    // only reload if the URL changed (optional optimization)
    loadVesselImage(vesselData[UserID].ImageURL, imageContainer);
  } else {
    imageContainer.innerHTML = '';
  }

  // Attach copy-link behavior
  const copyLinkEl = document.getElementById('copy-link');
  if (copyLinkEl) {
    copyLinkEl.onclick = (e) => {
      e.stopPropagation();
      const currentUrl = `${window.location.origin}${window.location.pathname}?UserID=${UserID}`;
      navigator.clipboard.writeText(currentUrl).then(() => {
        copyLinkEl.textContent = 'Link Copied';
        setTimeout(() => { copyLinkEl.textContent = 'Link'; }, 2000);
      });
    };
  }

  // Attach Messages popup behavior
  const msgBtn = document.getElementById('show-binary-messages');
  if (msgBtn) {
    msgBtn.onclick = (e) => {
      e.stopPropagation();
      window.open(
        `/binarymessages.html?UserID=${UserID}`,
        '_blank',
        'width=600,height=800'
      );
    };
  }
}

function updateLatLongDisplay() {
  const latlongDisplay = document.getElementById('latlong-display');
  if (focusedVessel && vesselData[focusedVessel]) {
    const lat = vesselData[focusedVessel].Latitude;
    const lon = vesselData[focusedVessel].Longitude;
    if (typeof lat === 'number' && typeof lon === 'number') {
      latlongDisplay.innerHTML = `<strong>${lat.toFixed(5)}, ${lon.toFixed(5)}</strong>`;
    }
  }
}

function debounce(func, wait) {
  let timeout;
  return function(...args) {
    const context = this;
    clearTimeout(timeout);
    timeout = setTimeout(() => {
      func.apply(context, args);
    }, wait);
  };
}

const debouncedAdjustMapBounds = debounce(adjustMapBounds, 500);


// Function to open the modal with the clicked image
function openImageModal(imageSrc) {
  const modalOverlay = document.getElementById('image-modal-overlay');
  const modalImage = document.getElementById('modal-image');
  modalImage.src = imageSrc;
  modalOverlay.style.display = 'flex';
}

// Function to close the modal
function closeImageModal() {
  const modalOverlay = document.getElementById('image-modal-overlay');
  modalOverlay.style.display = 'none';
}

// Attach click listener to the vessel image when vessel details are shown.
function attachImageClick() {
  const vesselImage = document.getElementById('vessel-image');
  if (vesselImage) {
    vesselImage.addEventListener('click', function(e) {
      e.stopPropagation();
      openImageModal(this.src);
    });
  }
}

function attachPolylineEvents(layerGroup, UserID) {
  // Iterate over each polyline in the layer group.
  layerGroup.eachLayer(function(polylineSegment) {
    polylineSegment.on('mousemove', function(e) {
      const nearest = getNearestTrackPoint(e, vesselData[UserID].track);
      if (nearest) {
        const [timestamp, lat, lon, sog, cog, trueHeading] = nearest.info;
        const localTime = new Date(timestamp).toLocaleString();
        const vessel = vesselData[UserID];
        const name = vessel.Name || "Unknown Vessel";
        const callsign = vessel.CallSign || "N/A";
        
        let popupContent = `<strong>${name} (${callsign})</strong><br>
                            ${localTime}<br>
                            ${lat.toFixed(5)}, ${lon.toFixed(5)}<br>`;
        if (sog !== null) {
          popupContent += `Speed: ${sog} kn<br>`;
        }
        if (cog !== null) {
          popupContent += `Course: ${cog}°<br>`;
        }
        if (trueHeading !== null) {
          popupContent += `Heading: ${trueHeading}°<br>`;
        }
        
        L.popup({ closeButton: false, autoPan: false })
          .setLatLng(nearest.ptLatLng)
          .setContent(popupContent)
          .openOn(map);
      }
    });
    polylineSegment.on('mouseout', function() {
      map.closePopup();
    });
  });
}

// Store the checkbox states separately from the legend update
const typeGroupCheckboxStates = {};

// Initialize all type groups as checked by default
for (const groupName in vesselTypeGroups) {
  typeGroupCheckboxStates[groupName] = true;
}

function updateLegend() {
  const legend = document.getElementById('vessel-legend');
  const currentDisplay = window.getComputedStyle(legend).display;
  
  if (currentDisplay === 'none') {
    return; // If the legend is hidden, don't update it
  }

  // Count vessels by type group
  const groupCounts = {};
  
  // Initialize all groups with zero count
  for (const groupName in vesselGroupColors) {
    groupCounts[groupName] = {
      count: 0,
      color: vesselGroupColors[groupName]
    };
  }
  
  // Count vessels in each group
  for (const UserID in vesselData) {
    const vessel = vesselData[UserID];
    if (vessel.Type) {
      // Find which group this vessel type belongs to
      let foundGroup = false;
      for (const [groupName, typeArray] of Object.entries(vesselTypeGroups)) {
        if (typeArray.includes(vessel.Type)) {
          groupCounts[groupName].count += 1;
          foundGroup = true;
          break;
        }
      }
      
      // If not found in any group, count as "Other"
      if (!foundGroup && groupCounts["Other"]) {
        groupCounts["Other"].count += 1;
      }
    }
  }
  
  // Sort groups by count (descending)
  const sortedGroups = Object.keys(groupCounts)
    .filter(group => groupCounts[group].count > 0) // Only show groups with vessels
    .sort((a, b) => groupCounts[b].count - groupCounts[a].count);
  
  // Generate legend HTML
  let legendContent = '';
  sortedGroups.forEach(group => {
    const count = groupCounts[group].count;
    const color = groupCounts[group].color;
    const groupId = group.replace(/\s+/g, '_').toLowerCase();
    
    // Use stored checkbox state or default to checked if not set
    const isChecked = typeGroupCheckboxStates[group] !== undefined ?
                      typeGroupCheckboxStates[group] :
                      true;
    
    const checked = isChecked ? 'checked' : '';
    
    legendContent += `
      <div class="legend-item">
        <input type="checkbox" id="type-group-${groupId}" class="type-group-checkbox" data-group="${group}" ${checked}>
        <svg width="20" height="50" viewBox="0 0 20 50" style="transform: rotate(0deg); transform-origin: center;">
          <path d="M5 45 L15 45 L15 30 Q10 5,5 30 Z" stroke="${color}" fill="${color}" stroke-width="2" />
        </svg>
        <span>${group} (${count})</span>
      </div>
    `;
  });
  
  // Update the legend content
  document.getElementById('legend-content').innerHTML = legendContent;
  
  // Reattach event listeners to checkboxes
  document.querySelectorAll('.type-group-checkbox').forEach(checkbox => {
    checkbox.addEventListener('change', function() {
      // Store the checkbox state when it changes
      typeGroupCheckboxStates[this.dataset.group] = this.checked;
      console.log(`Checkbox ${this.dataset.group} changed to ${this.checked}`);
      
      // Update the legend immediately when a checkbox changes
      updateLegend();
    });
  });
  
  // Display the legend
  document.getElementById('vessel-legend').style.display = 'block';
}

function getColorForSpeed(speed) {
  const maxSpeed = 40;  // maximum expected speed in knots
  // Clamp the speed value between 0 and maxSpeed
  const clampedSpeed = Math.max(0, Math.min(maxSpeed, speed));
  // Compute a ratio (0 = 0 knots, 1 = maxSpeed)
  const ratio = clampedSpeed / maxSpeed;
  // Calculate hue: 120 (green) at 0 knots to 0 (red) at 20 knots.
  // Here, a higher ratio gives a lower hue value.
  const hue = (1 - ratio) * 120;
  // Return a string with full saturation and 50% lightness.
  return `hsl(${hue}, 100%, 50%)`;
}


function createColoredTrack(track) {
  const segments = [];
  // Loop through the track segments
  for (let i = 0; i < track.length - 1; i++) {
    const pt1 = track[i];
    const pt2 = track[i + 1];
    // Use the speed of the first point (or average of pt1 and pt2) for the color
    const speed = (pt1[3] != null ? pt1[3] : 0);
    const color = getColorForSpeed(speed);
    // Create a polyline segment with this color
    const segment = L.polyline([[pt1[1], pt1[2]], [pt2[1], pt2[2]]], {
      color: color,
      weight: 3,
      opacity: 0.8
    });
    segments.push(segment);
  }
  // Group the segments so you can treat them as one layer
  return L.layerGroup(segments);
}

function updateFocusedVesselTrack(UserID) {
  if (focusedVessel === UserID && vesselData[UserID] && vesselData[UserID].track) {
    if (vesselColoredTracks[UserID]) {
      map.removeLayer(vesselColoredTracks[UserID]);
    }
    const newColoredTrack = createColoredTrack(vesselData[UserID].track);
    vesselColoredTracks[UserID] = newColoredTrack;
    map.addLayer(newColoredTrack);
  }
}

function createReceiverIcon(color = 'red') {
  const svgHtml = `
    <svg style="pointer-events: none;" width="20" height="20" viewBox="0 0 20 20">
      <polygon points="10,0 20,10 10,20 0,10" fill="${color}" />
    </svg>
  `;
  return L.divIcon({
    html: svgHtml,
    className: '',
    iconSize: [20, 20],
    iconAnchor: [10, 10]
  });
}

function hydrateTrackHistory(UserID) {
  const historySlider = document.getElementById('history-slider');
  const maxHistory = historySlider.value;
  fetch(`/history/${UserID}?maxAge=${maxHistory}&format=csv`)
    .then(response => {
      if (!response.ok) {
        throw new Error(`History fetch failed with status: ${response.status}`);
      }
      return response.text();
    })
    .then(csvData => {
      // Parse the CSV formatted history into an array of points.
      // Each point is an array: [timestamp, latitude, longitude, sog, cog, trueHeading]
      const newPoints = csvData.trim().split('\n').map(line => {
        const parts = line.split(',');
        const lat = parseFloat(parts[1]);
        const lon = parseFloat(parts[2]);
        // Only return the point if both lat and lon are valid numbers.
        if (isNaN(lat) || isNaN(lon)) {
          return null;
        }
        // Parse extra fields; if empty, use null.
        const sog = parts[3] && parts[3].trim() !== "" ? parseFloat(parts[3]) : null;
        const cog = parts[4] && parts[4].trim() !== "" ? parseFloat(parts[4]) : null;
        const trueHeading = parts[5] && parts[5].trim() !== "" ? parseFloat(parts[5]) : null;
        return [parts[0], lat, lon, sog, cog, trueHeading];
      }).filter(point => point !== null);

      // Retrieve the current track history (or start with an empty array).
      const currentTrack = vesselData[UserID].track || [];
      
      // Merge the current track with the new points.
      const mergedTrack = currentTrack.concat(newPoints);
      
      // Sort the merged track by time (assuming the timestamp is ISO formatted).
      mergedTrack.sort((a, b) => new Date(a[0]) - new Date(b[0]));

      // Remove duplicate entries.
      // Two points are considered duplicates if they have identical timestamp, latitude, and longitude.
      const dedupedTrack = [];
      mergedTrack.forEach(point => {
        if (
          dedupedTrack.length === 0 ||
          dedupedTrack[dedupedTrack.length - 1][0] !== point[0] ||
          dedupedTrack[dedupedTrack.length - 1][1] !== point[1] ||
          dedupedTrack[dedupedTrack.length - 1][2] !== point[2]
        ) {
          dedupedTrack.push(point);
        }
      });

      // Update the vessel's track history in your data store.
      vesselData[UserID].track = dedupedTrack;
      
      // Immediately apply the history filter based on the current slider value.
      const now = Date.now();
      const historyHours = parseInt(document.getElementById("history-slider").value, 10);
      const filteredTrack = dedupedTrack.filter(pt => {
        const pointTime = new Date(pt[0]).getTime();
        return (now - pointTime) <= historyHours * 3600000;
      });
      
      // --- Update the polyline on the map using speed-based colors ---
      // Remove any existing track for this vessel.
      if (vesselTracks[UserID]) {
        map.removeLayer(vesselTracks[UserID]);
      }
      // Use createColoredTrack() to generate the new colored track layer.
      vesselTracks[UserID] = createColoredTrack(filteredTrack);
      map.addLayer(vesselTracks[UserID]);
      // Reattach events (e.g., mousemove and mouseout) to the new polyline segments.
      attachPolylineEvents(vesselTracks[UserID], UserID);
      
      // Force re-addition of the polyline in case update functions have removed it.
      if (!map.hasLayer(vesselTracks[UserID])) {
        map.addLayer(vesselTracks[UserID]);
      }
      
      // Save the updated vessel data back into localStorage.
      localStorage.setItem('vesselData', JSON.stringify(vesselData));
      
      // Now update the UI after CSV processing is complete.
      updateOverlay();
    })
    .catch(error => {
      console.error('Error hydrating track history:', error);
      // Optionally, you can call your update functions on error
      updateOverlay();
    });
}

        // Global objects to store markers, vessel data, and track histories.
        const vesselMarkers = {};
        const vesselData = {};   // keyed by UserID/UserID
        const vesselTracks = {}; // keyed by UserID/UserID

        /**
         * Decode the AIS communication state.
         */
        function decodeCommunicationState(state) {
          const intState = Number(state);
          const syncState = intState >> 17;
          const slotTimeout = (intState >> 14) & 0x07;
          const slotOffset = intState & 0x3FFF;
          return { syncState, slotTimeout, slotOffset };
        }

// Global variable to store current port data
let currentPorts = [];

let focussedID = null;

// Create a layer group for port markers
const portLayerGroup = L.layerGroup().addTo(map);

// Create a custom invisible icon
const invisibleIcon = L.divIcon({
  className: 'invisible-icon',
  html: '', // Empty HTML content for an invisible icon
  iconSize: [0, 0]  // No size for the marker
});

// Create and add port markers with tooltips to the portLayerGroup
function addPortMarkers(ports) {
  // Compare new ports with the current ones (using JSON stringify for a basic deep comparison)
  // Depending on your data structure, you may want a more robust comparison.
  if (JSON.stringify(ports) === JSON.stringify(currentPorts)) {
    // If the data is the same, do nothing.
    return;
  }
  
  // Update the current ports cache
  currentPorts = ports;

  // Clear existing port markers
  portLayerGroup.clearLayers();

  ports.forEach(port => {
    const { CITY, LATITUDE, LONGITUDE } = port;

    // Create the marker with the invisible icon
    const portMarker = L.marker([LATITUDE, LONGITUDE], { icon: invisibleIcon });

    const tooltipContent = `<img src="/images/port.png" style="width: 16px; height: 16px; vertical-align: middle; margin-right: 4px;" />${CITY}`;
    portMarker.bindTooltip(tooltipContent, { permanent: true, direction: 'top', className: 'port-marker-tooltip' });

    // Add the marker to the portLayerGroup
    portMarker.addTo(portLayerGroup);
  });
}

let debounceTimeout;

function selectVesselById(UserID) {
  // Check if a marker already exists for the vessel.
  if (!vesselMarkers[UserID]) {
    // If the marker does not exist, fetch the vessel state.
    fetch(`/state?UserID=${UserID}`)
      .then(response => {
        if (!response.ok) {
          throw new Error(`Request failed with status ${response.status}`);
        }
        return response.json();
      })
      .then(stateData => {
        // Ensure that the state has valid position data.
        if (typeof stateData.Latitude === "number" && typeof stateData.Longitude === "number") {
          // Update or add the vessel to your global state.
          vesselData[UserID] = stateData;
	  if (!vesselData[UserID].track) {
  		vesselData[UserID].track = [];
	  }
	  if (!vesselData[UserID].color) {
            vesselData[UserID].color = randomColor();
          }
          // Create a marker using your existing function (e.g., getVesselIcon).
          let marker = L.marker(
            [stateData.Latitude, stateData.Longitude],
            { icon: getVesselIcon(stateData) }
          ).addTo(map);
          vesselMarkers[UserID] = marker;

          // Optionally, bind popups or tooltips.
          marker.bindPopup(createPopupContent(stateData), { autoPan: false });

          // Focus on the vessel (recenter, highlight, etc.)
          focusOnVessel(UserID);

        } else {
          console.error("Invalid location data received for vessel:", UserID);
        }
      })
      .catch(error => {
        console.error("Error fetching vessel state:", error);
      });
  } else {
    // If the marker already exists, update its position.
    fetch(`/state?UserID=${UserID}`)
      .then(response => response.json())
      .then(stateData => {
        // Update global state and marker position.
        vesselData[UserID] = stateData;
	if (!vesselData[UserID].track) {
  	   vesselData[UserID].track = [];
	}
        if (!vesselData[UserID].color) {
          vesselData[UserID].color = randomColor();
       }
        vesselMarkers[UserID].setLatLng([stateData.Latitude, stateData.Longitude]);
        vesselMarkers[UserID].getPopup().setContent(createPopupContent(stateData));

        focusOnVessel(UserID);
        hydrateTrackHistory(UserID);
      })
      .catch(error => {
        console.error("Error updating vessel state for marker:", error);
      });
  }
}

function renderSearchResults(data) {
  // Convert the response object to an array.
  if (!Array.isArray(data)) {
    data = Object.values(data);
  }
  
  // Sort by update time (newest first).
  data.sort((a, b) => new Date(b.LastUpdated || Date.now()) - new Date(a.LastUpdated || Date.now()));
  
  let content = "";
  data.forEach(entry => {
    const name = entry.Name;
    const lastSeen = timeAgo(new Date(entry.LastUpdated || Date.now()).getTime());
    const numMessages = entry.NumMessages || 0;
  
    // Use extra info if the entry represents a receiver.
    const extraInfo = entry.isReceiver
      ? `<div class="vessel-callsign">Receiver</div>`
      : `<div class="vessel-callsign">${staticTypeMapping[entry.Type] || entry.Type || "N/A"}</div>`;
  
    content += `<div class="vessel-entry" data-userid="${entry.UserID}">
                      <div class="vessel-name">${name}</div>
                      ${extraInfo}
                      <div class="vessel-timestamp">${lastSeen}</div>
                    </div>`;
  });
  
  document.getElementById('overlay-content').innerHTML = content;
  
  // Update the count to reflect search results.
  document.getElementById('vessel-count').innerHTML =
    `${data.length} of ${data.length} entries`; // or customize based on your needs
  
  // Attach click event listeners for each overlay entry.
  document.querySelectorAll('.vessel-entry').forEach(entry => {
    entry.addEventListener('click', event => {
      event.stopPropagation();
      const UserID = entry.getAttribute('data-userid');
      if (receiverData.hasOwnProperty(UserID)) {
        const marker = receiverMarkers[UserID];
        map.setView(marker.getLatLng(), 10);
        marker.openPopup();
      } else {
        selectVesselById(UserID);
      }
    });
  });
}



        /**
         * Build popup content from vessel data.
         */
function createPopupContent(data) {
  const lines = [];
  // Top line: Always show name, callsign, and class.
  let name = data.Name ? data.Name : "Unknown Vessel";
  if (data.CallSign) {
    name += ` (${data.CallSign})`;
  }
  if (data.AISClass) {
    name += ` | ${data.AISClass}`;
  }
  lines.push(`<strong>${name}</strong>`);

  // Add subsequent lines only if they have valid (non-null/non-empty) values.
  addLine(lines, "Last Update", data.lastUpdate ? timeAgo(data.lastUpdate) : null);
  addLine(lines, "MMSI", data.UserID);

  if (data.UserID) {
    const midData = lookupMidByUserID(data.UserID);
    addLine(lines, "Flag", midData.country);
  }

  addLine(lines, "Destination", data.Destination && data.Destination.trim() !== "" ? data.Destination : null);
  addLine(lines, "Speed", (data.Sog != null ? `${data.Sog} kn` : null));
  if (data.Altitude != null) {
    addLine(lines, "Altitude", `${data.Altitude} m`);
  } 
  if (data.Type !== undefined) {
    // choose AtoN mapping if this is an aid-to-navigation station
    const mapping = (data.AISClass === "AtoN")
      ? staticAtoNTypeMapping
      : staticTypeMapping;
    const typeDescription = mapping[data.Type] || data.Type;
    addLine(lines, "Type", typeDescription);
  }

  addLine(lines, "Maximum Draught", (data.MaximumStaticDraught != null ? `${data.MaximumStaticDraught} m` : null));

  if (data.NavigationalStatus !== undefined) {
    const navStatusDescription = navigationalStatusMapping[data.NavigationalStatus] || data.NavigationalStatus;
    addLine(lines, "Nav Status", navStatusDescription);
  }

  return `<div class="popup-content">${lines.join('<br>')}</div>`;
}

function lookupMidByUserID(userID) {
  // Extract the first 3 characters to form the MID
  const mid = String(userID).substring(0, 3);

  if (mids.hasOwnProperty(mid)) {
    return {
      shortcode: mids[mid][0] || null,   // Country short code
      country:   mids[mid][3] || null    // Country name
    };
  }

  // Fallback if MID not found
  return {
    shortcode: "ZZ",
    country:   "Unknown"
  };
}

function buildTooltipLine(...values) {
  return values
    .filter(val => val !== null && val !== undefined && (typeof val === "string" ? val.trim() !== "" : true))
    .join(" | ");
}

// Helper to add a line if the value is valid
function addLine(lines, label, value, formatFn) {
  if (value !== null && value !== undefined && value !== "") {
    lines.push(`${label}: ${formatFn ? formatFn(value) : value}`);
  }
}

function getLatLngs(track) {
  return track.map(pt => [pt[1], pt[2]]);
}

function filterTrackPoints(track) {
  const historyHours = parseInt(document.getElementById("history-slider").value, 10);
  const now = Date.now();
  return track.filter(pt => {
    // Convert the point's timestamp to milliseconds.
    const pointTime = new Date(pt[0]).getTime();
    return (now - pointTime) <= historyHours * 3600000;
  });
}

function createCircleIcon(vesselState) {
  // Get a color that is consistent for the vessel type
  const color = getColorForVesselTypeConsistent(vesselState.Type);
  // Return a divIcon with circular styling
  return L.divIcon({
    html: `<div style="
              width: 12px;
              height: 12px;
              background: ${color};
              border: 0px;
              border-radius: 50%;
           "></div>`,
    className: '', // Optionally leave className empty to prevent extra styling
    iconSize: [12, 12],
    iconAnchor: [6, 6]
  });
}

function createDetailContent(data) {
  const lines = [];
  const lastSeen = data.lastUpdate ? timeAgo(data.lastUpdate) : null;
  addLine(lines, "Last Update", lastSeen);
  addLine(lines, "Messages", data.NumMessages);
  addLine(lines, "MMSI", data.UserID);
  addLine(lines, "AIS Class", data.AISClass);

  if (data.Type != null) {
    // If it’s an AtoN report, use the special AtoN mapping; otherwise the normal one
    const mapping = (data.AISClass === "AtoN")
      ? staticAtoNTypeMapping
      : staticTypeMapping;
    const typeDescription = mapping[data.Type] || data.Type;
    addLine(lines, "Type", typeDescription);
  }

  if (
    data.UserID &&
    (data.AISClass === 'A' || data.AISClass === 'B')
  ) {
    const midData = lookupMidByUserID(data.UserID);
    const countryFlag = `
      <div style="display: inline-flex; align-items: center; margin: 0;">
        <span style="line-height: 20px; margin-right: 8px;">Flag:</span>
        <img
          src="/flags/${midData.shortcode.toLowerCase()}.svg"
          alt="${midData.country} Flag"
          style="width: 30px; height: 20px; border: 1px solid black; object-fit: cover;"
          title="${midData.country}"
        >
      </div>
    `;
    lines.push(countryFlag);
  }

  addLine(lines, "Call Sign", data.CallSign);
  addLine(lines, "IMO Number", data.ImoNumber);

  // Destination: show a default text if it's empty
  if (data.Destination && data.Destination.trim() !== "") {
    addLine(lines, "Destination", data.Destination);
  }

  addLine(lines, "Speed", (data.Sog != null ? `${data.Sog} kn` : null));
  if (data.Altitude != null) {
    addLine(lines, "Altitude", `${data.Altitude} m`);
  }
  addLine(lines, "Course", (data.Cog != null ? `${data.Cog}°` : null));

  if (data.TrueHeading != null && data.TrueHeading < 360) {
    addLine(lines, "Heading", `${data.TrueHeading}°`);
  }

  if (data.Dimension) {
    const d = data.Dimension;
    // Calculate overall length and width, but only add if non-zero.
    const totalLength = (Number(d.A) || 0) + (Number(d.B) || 0);
    const totalWidth = (Number(d.C) || 0) + (Number(d.D) || 0);
    if (totalLength > 0 && totalWidth > 0) {
      lines.push(`Dimensions: ${totalLength}m x ${totalWidth}m`);
    }
  }

  if (data.Eta) {
    const e = data.Eta;
    const now = new Date();
    const etaDate = new Date(now.getFullYear(), e.Month - 1, e.Day, e.Hour, e.Minute);
    const etaFormatted = etaDate.toLocaleString('ja-JP', {
      year: 'numeric',
      month: '2-digit',
      day: '2-digit',
      hour: '2-digit',
      minute: '2-digit',
      hour12: false
    });
    lines.push(`ETA: ${etaFormatted}`);
  }

  addLine(lines, "Max Draught", (data.MaximumStaticDraught != null ? `${data.MaximumStaticDraught} m` : null));

  if (data.NavigationalStatus != null) {
    const navStatusDescription = navigationalStatusMapping[data.NavigationalStatus] || data.NavigationalStatus;
    addLine(lines, "Nav Status", navStatusDescription);
  }

  addLine(lines, "Rate Of Turn", (data.RateOfTurn != null ? `${data.RateOfTurn}°/min` : null));

if (data.MessageTypes && Array.isArray(data.MessageTypes)) {
  // Wrap each numeric code in a clickable span
  const codeSpans = data.MessageTypes.map(type =>
    `<span class="msg-type" data-type="${type}" style="cursor:pointer; text-decoration:underline;">${type}</span>`
  );
  lines.push(`Message Types: ${codeSpans.join(', ')}`);
}

// Add the list of receivers that have reported this vessel
if (data.ReceiverIDs && Array.isArray(data.ReceiverIDs) && data.ReceiverIDs.length > 0) {
  // Filter out receivers that aren't in the current receiver list
  const validReceiverIds = data.ReceiverIDs.filter(id => receiverData[id]);
  
  if (validReceiverIds.length > 0) {
    // Create links for each valid receiver ID
    const receiverLinks = validReceiverIds.map(id => {
      if (receiverData[id] && receiverData[id].Name) {
        return `<a href="/metrics/receiver.html?receiver=${id}" target="_blank">${receiverData[id].Name}</a>`;
      } else {
        return `<a href="/metrics/receiver.html?receiver=${id}" target="_blank">ID: ${id}</a>`;
      }
    });
    
    // Join the links with commas
    lines.push(`Receivers: ${receiverLinks.join(', ')}`);
  } else {
    // No valid receivers available
    lines.push(`Receivers: None`);
  }
} else {
  // No receivers available
  lines.push(`Receivers: None`);
}

  return `<div class="popup-content">${lines.join('<br>')}</div>`;
}

function adjustMapBounds() {
  if (focusedVessel) {
    // When a vessel is focused, center solely on that vessel.
    map.setView(vesselMarkers[focusedVessel].getLatLng(), 13);
    return;
  }

  if (userLatLng) {
    // When no vessel is focused, find the vessel marker nearest to the user.
    let closestMarker = null;
    let closestDistance = Infinity;
    for (const key in vesselMarkers) {
      if (vesselMarkers.hasOwnProperty(key) && map.hasLayer(vesselMarkers[key])) {
        let markerLatLng = vesselMarkers[key].getLatLng();
        let distance = L.latLng(userLatLng).distanceTo(markerLatLng);
        if (distance < closestDistance) {
          closestDistance = distance;
          closestMarker = vesselMarkers[key];
        }
      }
    }
    if (closestMarker) {
      // Define a threshold distance in meters (adjust this value as needed)
      const threshold = 5000; // e.g. 5 km
      if (closestDistance < threshold) {
        // If the closest vessel is really close, use the default zoom (like on page load).
        map.setView(userLatLng, 10);
      } else {
        // Otherwise, fit bounds to include both the user and the closest vessel.
        let bounds = L.latLngBounds([userLatLng, closestMarker.getLatLng()]);
        map.fitBounds(bounds, { padding: [50, 50], maxZoom: 10 });
      }
    } else {
      // If no vessel markers exist, center on the user.
      map.setView(userLatLng, 10);
    }
  } else {
    // Fallback: if the user's location is unknown, use all vessel markers.
    let bounds = L.latLngBounds([]);
    for (const key in vesselMarkers) {
      if (vesselMarkers.hasOwnProperty(key) && map.hasLayer(vesselMarkers[key])) {
        bounds.extend(vesselMarkers[key].getLatLng());
      }
    }
    if (bounds.isValid()) {
      map.fitBounds(bounds, { padding: [50, 50] });
    }
  }
}

        // Utility: Compute a time elapsed string.
        function timeAgo(timestamp) {
          const seconds = Math.floor((Date.now() - timestamp) / 1000);
          if (seconds < 60) return seconds + " sec ago";
          const minutes = Math.floor(seconds / 60);
          if (minutes < 60) return minutes + " min ago";
          const hours = Math.floor(minutes / 60);
          if (hours < 24) return hours + " hrs ago";
          const days = Math.floor(hours / 24);
          return days + " days ago";
        }

function updateStationaryMarkers() {
  const showPaths   = document.getElementById('show-paths').checked;
  const onlyFocused = document.getElementById('only-focussed').checked;

  // 1) Always ensure all vessel markers remain on the map
  for (const userid in vesselMarkers) {
    const marker = vesselMarkers[userid];
    if (marker && !map.hasLayer(marker)) {
      map.addLayer(marker);
    }
  }

  // 2) Remove every existing track layer
  for (const userid in vesselTracks) {
    const trackLayer = vesselTracks[userid];
    if (trackLayer && map.hasLayer(trackLayer)) {
      map.removeLayer(trackLayer);
    }
  }

  // 3) If “Show Paths” is not checked, don’t add any tracks
  if (!showPaths) {
    updateOverlay();
    return;
  }

  // 4) Only draw the focused vessel’s track (if one is focused)
  if (focusedVessel && vesselTracks[focusedVessel]) {
    map.addLayer(vesselTracks[focusedVessel]);
  }

  updateOverlay();
}




        // Update the known vessels overlay.
function updateOverlay() {
  const filterText = document.getElementById('vessel-filter').value.trim().toLowerCase();
  // Removed: Do not skip updates when searching; allow showing receivers on search

  const maxAgeHours = parseInt(document.getElementById('age-slider').value, 10);
  const now = Date.now();

  // Get arrays of vessels and receivers.
  const vesselArray = Object.values(vesselData);
  const receiverArray = Object.values(receiverData);

  // Merge the two arrays.
  const combinedEntries = filterText.length >= 3
    ? vesselArray.concat(receiverArray)
    : vesselArray;

  // Filter entries that have a name and valid update time.
  const validEntries = combinedEntries.filter(entry => entry.Name && entry.LastUpdated);

  // Filter the entries by the filter text (if any) and age.
  const filteredEntries = validEntries.filter(entry => {
    const textMatch =
      entry.Name.toLowerCase().includes(filterText) ||
      (entry.CallSign && entry.CallSign.toLowerCase().includes(filterText)) ||
      entry.UserID.toString().includes(filterText);
    const entryTime = new Date(entry.LastUpdated).getTime();
    const withinAge = (now - entryTime) <= maxAgeHours * 3600000;
    return textMatch && withinAge;
  });

  // Sort by update time (newest first).
  filteredEntries.sort((a, b) => new Date(b.LastUpdated) - new Date(a.LastUpdated));
  const topEntries = filteredEntries.slice(0, 100);

  const bounds = map.getBounds();
  let visibleCount = 0;
  for (const id in vesselMarkers) {
    if (map.hasLayer(vesselMarkers[id])) visibleCount++;
  }

  // Update the overlay count text.
  document.getElementById('vessel-count').innerHTML =
    `${topEntries.length} of ${filteredEntries.length} entries`;

  // Build the HTML content for the overlay.
  let content = "";
  topEntries.forEach(entry => {
    const name = entry.Name;
    const lastSeen = timeAgo(new Date(entry.LastUpdated).getTime());
    const numMessages = entry.NumMessages || 0;
    const extraInfo = entry.isReceiver
      ? `<div class="vessel-callsign">Receiver</div>`
      : `<div class="vessel-callsign">${staticTypeMapping[entry.Type] || entry.Type || "N/A"}</div>`;
    content += `<div class="vessel-entry" data-userid="${entry.UserID}">
                      <div class="vessel-name">${name}</div>
                      ${extraInfo}
                      <div class="vessel-timestamp">${lastSeen}</div>
                    </div>`;
  });

  document.getElementById('overlay-content').innerHTML = content;

  // Attach click events for the overlay entries.
  document.querySelectorAll('.vessel-entry').forEach(entry => {
    entry.addEventListener('click', event => {
      event.stopPropagation();
      const UserID = entry.getAttribute('data-userid');
      if (receiverData.hasOwnProperty(UserID)) {
        const marker = receiverMarkers[UserID];
        map.setView(marker.getLatLng(), 10);
        marker.openPopup();
      } else {
        document.getElementById('stationary').checked = true;
        updateStationaryMarkers();
        focusOnVessel(UserID);
      }
    });
  });
}

// Helper function to check if the vessel is visible by the current age filter
function isVesselVisibleByAge(vessel, maxAgeHours, now) {
    const ageMilliseconds = now - vessel.lastUpdate;
    return ageMilliseconds <= maxAgeHours * 3600000; // Convert to milliseconds
}

// Helper function to check if the vessel is visible by the current age filter
function isVesselVisibleByAge(vessel) {
  const maxAgeHours = parseInt(document.getElementById("age-slider").value, 10);
  const now = Date.now();
  const ageMilliseconds = now - vessel.lastUpdate;
  return ageMilliseconds <= maxAgeHours * 3600000; // Convert to milliseconds
}

function attachMessageTypeClicks() {
  document.querySelectorAll('#detail-content .msg-type').forEach(el => {
    el.addEventListener('click', e => {
      e.stopPropagation();
      const rawType = el.dataset.type;
      // Open new page instead of inline overlay
      window.open(
        `/latestmessages.html?UserID=${focusedVessel}&MessageID=${rawType}`,
        '_blank',
        'width=600,height=800'
      );
    });
  });
}
        // Periodically update the vessel detail overlay.
	function updateVesselDetailOverlay() {
	  if (!detailsOverlayHidden && focusedVessel && vesselData[focusedVessel]) {
	    const html = createDetailContent(vesselData[focusedVessel]);
	    const container = document.getElementById('detail-content');
	    container.innerHTML = html;
	    attachMessageTypeClicks();
	  }
	}
        setInterval(updateVesselDetailOverlay, 1000);
        setInterval(updateOverlay, 1000);

        // Update marker and track visibility based on the "Only Tracked" checkbox.
function updateFocussedVisibility() {
  if (focusedVessel) {
    if (!map.hasLayer(vesselMarkers[focusedVessel])) {
      map.addLayer(vesselMarkers[focusedVessel]);
    }
    const showPaths = document.getElementById('show-paths').checked;
    if (vesselTracks[focusedVessel]) {
      if (showPaths && !map.hasLayer(vesselTracks[focusedVessel])) {
        map.addLayer(vesselTracks[focusedVessel]);
      } else if (!showPaths && map.hasLayer(vesselTracks[focusedVessel])) {
        map.removeLayer(vesselTracks[focusedVessel]);
      }
    }
  }
  updateOverlay();
}


        // --- Live Logs functionality ---
        const maxLogMessages = 250;
        const liveLogsContent = document.getElementById('live-logs-content');

        // Helper function to recursively format nested objects with indentation.
        function formatLogField(key, value, indentLevel = 0) {
          const indentStyle = `style="padding-left: ${indentLevel * 15}px"`;
          let html = `<div ${indentStyle}><span class="log-field">${key}:</span> `;
          if (value !== null && typeof value === 'object') {
            html += `<br>`;
            for (const subKey in value) {
              html += formatLogField(subKey, value[subKey], indentLevel + 1);
            }
          } else {
            html += `${value}`;
          }
          html += `</div>`;
          return html;
        }

function renderLogMessageNode(msg) {
  const entry = document.createElement('div');
  entry.className = 'log-entry';
  entry.dataset.type = msg.type;

  // Helper to render a field, recursing into nested objects
  function renderField(container, key, val, indent = 0) {
    if (val !== null && typeof val === 'object') {
      // Render the key
      const label = document.createElement('div');
      label.className = 'log-field';
      label.style.paddingLeft = `${15 * indent}px`;
      label.textContent = `${key}:`;
      container.appendChild(label);
      // Recurse for each sub-property
      for (const [subKey, subVal] of Object.entries(val)) {
        renderField(container, subKey, subVal, indent + 1);
      }
    } else {
      // Primitive value: render on one line
      const row = document.createElement('div');
      row.className = 'log-field';
      row.style.paddingLeft = `${15 * indent}px`;
      row.textContent = `${key}: ${val}`;
      container.appendChild(row);
    }
  }

  // Timestamp
  const tsDiv = document.createElement('div');
  tsDiv.className = 'log-timestamp';
  tsDiv.style.cssText = 'font-size:10px;color:#888;margin-bottom:2px;';
  tsDiv.textContent = msg.timestamp
    ? new Date(msg.timestamp).toLocaleTimeString()
    : new Date().toLocaleTimeString();
  entry.appendChild(tsDiv);

  // Message Type
  const typeNum   = String(msg.type);
  const typeLabel = messageTypeNames[typeNum] || `Unknown (${typeNum})`;
  renderField(entry, 'Message Type', `${typeNum}: ${typeLabel}`, 0);

  // Other data fields (handles nested objects)
  for (const [field, val] of Object.entries(msg.data)) {
    renderField(entry, field, val, 0);
  }

  // Raw Sentence (label + content block)
  if (msg.raw_sentence) {
    renderField(entry, 'Raw Sentence', msg.raw_sentence, 0);
  }

  return entry;
}

function subscribeInstantUpdates(UserID) {
  focussedID = UserID
  const channelName = "ais_sub/:userID";
  instantChannel = channelName;
  socket.emit(channelName, UserID);
  console.log("[AIS_SUBSCRIBE]", channelName, UserID);

  // Allowed AIS message types as numbers
  //const allowedTypes = new Set([1,2,3,8,9,18,19]);

  instantHandler = function(rawMessage) {
    let message = rawMessage;
    // If you ever get a JSON string, parse it
    if (typeof rawMessage === "string") {
      try {
        message = JSON.parse(rawMessage);
        console.log("[AIS_DATA] parsed JSON →", message);
      } catch (e) {
        console.error("[AIS_DATA] JSON.parse failed:", e, rawMessage);
        return;
      }
    }

    // Ensure `type` is a number
    const msgType = Number(message.type);
    if (Number.isNaN(msgType)) {
      console.warn("[AIS_DATA] bad message.type (not a number):", message.type);
      return;
    }
    console.log("[AIS_DATA] type =", msgType);

    // Filter out unwanted types
    //if (!allowedTypes.has(msgType)) {
    //  console.log("[AIS_DATA] filtered out type", msgType);
    //  return;
    //}

    // Ensure we have a data payload
    if (!message.data || typeof message.data !== "object") {
      console.warn("[AIS_DATA] missing .data payload:", message);
      return;
    }

    // Update vesselData
    if (!vesselData[UserID]) {
      console.warn("[AIS_DATA] no vesselData entry for", UserID);
      return;
    }

    // Copy fields over
    Object.entries(message.data).forEach(([k,v]) => {
      vesselData[UserID][k] = v;
    });

    // Store receiver_id if present
    if (message.receiver_id !== null && message.receiver_id !== undefined) {
      vesselData[UserID].receiver_id = message.receiver_id;
      
      // Update the vessel-receiver connection if this vessel is focused
      if (focusedVessel === UserID) {
        updateVesselReceiverConnection(UserID);
      }
    }

    // Timestamp handling
    if (message.timestamp) {
      const ts = new Date(message.timestamp).getTime();
      vesselData[UserID].lastUpdate = ts;
      console.log("[AIS_DATA] timestamp =>", message.timestamp);
    }

    // Position update
    const lat = message.data.Latitude;
    const lon = message.data.Longitude;
    if (typeof lat === "number" && typeof lon === "number") {
      console.log(`[AIS_DATA] updating position to (${lat}, ${lon})`);

      // Move marker
      if (vesselMarkers[UserID]) {
        vesselMarkers[UserID].setLatLng([lat, lon]);
        vesselMarkers[UserID].setIcon(getVesselIcon(vesselData[UserID]));
        vesselMarkers[UserID].getPopup().setContent(createPopupContent(vesselData[UserID]));
      }

      // Track history
      vesselData[UserID].track = vesselData[UserID].track || [];
      vesselData[UserID].track.push([
        message.timestamp, lat, lon,
        message.data.Sog ?? null,
        message.data.Cog ?? null,
        message.data.TrueHeading ?? null
      ]);

      // Rebuild polyline
      if (vesselTracks[UserID]) map.removeLayer(vesselTracks[UserID]);
      vesselTracks[UserID] = createColoredTrack(filterTrackPoints(vesselData[UserID].track));
      if (document.getElementById('show-paths').checked) {
          map.addLayer(vesselTracks[UserID]);
      }
      attachPolylineEvents(vesselTracks[UserID], UserID);
    }

    // Finally, update overlays/logs
    updateVesselDetailOverlay();
    addLiveLogEntry(message);
  };

  // Attach to the socket
  socket.on("ais_data", instantHandler);
}


    function unsubscribeInstantUpdates() {
      if (instantHandler) {
	console.log("ais_unsub/:userID", focussedID);
        socket.emit("ais_unsub/:userID", focussedID);
        socket.off("ais_data", instantHandler);
      }
      instantChannel = null;
      instantHandler = null;
    }

function addLiveLogEntry(message) {
  // Remove placeholder if present
  const placeholder = liveLogsContent.querySelector('.placeholder');
  if (placeholder) placeholder.remove();

  // Declare node first
  let node;
  // Render the log entry node
  node = renderLogMessageNode(message);
  // Save original message on the node for filtering
  node.originalMessage = message;

  // Prepend to the live logs container
  liveLogsContent.insertBefore(node, liveLogsContent.firstChild);

  // Apply filters immediately
  applyLogFilters();

  // Limit total entries
  while (liveLogsContent.childElementCount > maxLogMessages) {
    liveLogsContent.removeChild(liveLogsContent.lastChild);
  }
}




function applyLogFilters() {
  const entries     = liveLogsContent.querySelectorAll('.log-entry');
  const query       = document.getElementById('live-log-search').value.toLowerCase().trim();
  const showAll     = document.getElementById('log-filter-all').checked;
  // Build a set of allowed types if not showing all
  let allowedTypes = null;
  if (!showAll) {
    allowedTypes = new Set();
    document.querySelectorAll('.log-filter:checked').forEach(cb => {
      cb.value.split(',').forEach(code => allowedTypes.add(code.trim()));
    });
  }

  entries.forEach(entry => {
    const msgType = entry.dataset.type;
    // 1) Filter by message type checkboxes
    if (!showAll && !allowedTypes.has(msgType)) {
      entry.style.display = 'none';
      return;
    }

    // 2) Text‐search filter: always keep timestamp
    const timestamp = entry.querySelector('.log-timestamp');
    if (timestamp) timestamp.style.display = '';

    // Check each .log-field (label + content)
    let anyMatch = false;
    entry.querySelectorAll('.log-field').forEach(fieldDiv => {
      const text = fieldDiv.textContent.toLowerCase();
      if (!query || text.includes(query)) {
        fieldDiv.style.display = '';
        anyMatch = anyMatch || Boolean(query); // if query empty, we'll keep them all anyway
      } else {
        fieldDiv.style.display = 'none';
      }
    });

    // If there's a search query and no fields matched, hide the whole entry
    if (query && !anyMatch) {
      entry.style.display = 'none';
    } else {
      entry.style.display = '';
    }
  });
}


	document.getElementById('log-filter-all').addEventListener('change', applyLogFilters);

        // When the Live Logs button is clicked.
        document.getElementById('live-logs').addEventListener('click', () => {
          const overlay = document.getElementById('live-logs-overlay');
          overlay.style.display = 'block';
          clearLiveLogs();
        });

        // When the close button on the Live Logs overlay is clicked.
        document.getElementById('close-live-logs').addEventListener('click', () => {
          const overlay = document.getElementById('live-logs-overlay');
          overlay.style.display = 'none';
          clearLiveLogs();
        });

        // Make the Live Logs overlay draggable.
        (function makeDraggable() {
          const overlay = document.getElementById('live-logs-overlay');
          const header = document.getElementById('live-logs-header');
          let offsetX = 0, offsetY = 0, isDragging = false;

          header.addEventListener('mousedown', (e) => {
            isDragging = true;
            offsetX = e.clientX - overlay.offsetLeft;
            offsetY = e.clientY - overlay.offsetTop;
          });

          document.addEventListener('mousemove', (e) => {
            if (isDragging) {
              overlay.style.left = (e.clientX - offsetX) + 'px';
              overlay.style.top = (e.clientY - offsetY) + 'px';
            }
          });

          document.addEventListener('mouseup', () => {
            isDragging = false;
          });
        })();

        // Load saved vessel data from localStorage if available.
        const storedData = localStorage.getItem('vesselData');
        if (storedData) {
          try {
            const parsedData = JSON.parse(storedData);
            Object.keys(parsedData).forEach(UserID => {
              vesselData[UserID] = parsedData[UserID];
              if (
                vesselData[UserID].Latitude !== undefined &&
                vesselData[UserID].Longitude !== undefined
              ) {
                const lat = vesselData[UserID].Latitude;
                const lon = vesselData[UserID].Longitude;
                const popupContent = createPopupContent(vesselData[UserID]);
		const marker = L.marker(
		  [vesselData[UserID].Latitude, vesselData[UserID].Longitude],
		  { icon: getVesselIcon(vesselData[UserID]) }
		).addTo(map);

		marker.on('add', function() {
		  const markerElem = marker.getElement();
		  if (markerElem) {
		    const svg = markerElem.querySelector('svg');
		    if (svg) {
		      const heading = 
 			 (typeof vesselData[UserID].TrueHeading === 'number' && vesselData[UserID].TrueHeading < 360)
			    ? vesselData[UserID].TrueHeading
			    : (typeof vesselData[UserID].Cog === 'number' && vesselData[UserID].Cog >= 0 && vesselData[UserID].Cog < 360)
			      ? vesselData[UserID].Cog
			      : 0;  // Default to 0° if neither TrueHeading nor Cog is valid
		      if (heading !== undefined) {
		        svg.style.transform = `rotate(${heading}deg)`;
		      }
		    }
		  }
    	      if (markerElem) {
    	       const svg = markerElem.querySelector('svg');
    		 if (svg) {
    		    svg.addEventListener('click', (e) => {
    		      if (e && typeof e.stopPropagation === 'function') {
    		        e.stopPropagation();
    		      }
    		      focusOnVessel(UserID);
    		    });
    		  }
    	       }
    	    });
                marker.bindPopup(popupContent, { autoPan: false });
                if (vesselData[UserID].Name) {
                  marker.bindTooltip(vesselData[UserID].Name, {
                    permanent: true,
                    direction: 'top',
                    className: 'vessel-tooltip',
                    interactive: true
                  }).openTooltip();
                  attachTooltipClick(marker, UserID);
                }
                marker.on('click', function(e) {
      	      if (e && typeof e.stopPropagation === 'function') {
    	        e.stopPropagation();
    	      }
    	      if (e && typeof e.preventDefault === 'function') {
    	        e.preventDefault();
    	      }
    	      focusOnVessel(UserID);
    	    });
    	    const markerElem = marker.getElement() || marker._icon;
    	    if (markerElem) {
    	      markerElem.addEventListener('click', (e) => {
    	        if (e && typeof e.stopPropagation === 'function') {
    	          e.stopPropagation();
    	        }
       	    focusOnVessel(UserID);
    	      });
    	    }
                if (!isMobile) {
                  marker.on('mouseover', function() { this.openPopup(); });
                  marker.on('mouseout', function() { this.closePopup(); });
                }
                vesselMarkers[UserID] = marker;
              }
		if (vesselData[UserID].track && vesselData[UserID].track.length > 0) {
		  vesselTracks[UserID] = L.polyline(getLatLngs(vesselData[UserID].track), {
		    color: vesselData[UserID].color,
		    weight: 3,
		    opacity: 0.8,
		    interactive: true
		  }).addTo(map);
		  attachPolylineEvents(vesselTracks[UserID], UserID);
		}
            });
            debouncedAdjustMapBounds();
            updateOverlay();
	    updateStationaryMarkers();
          } catch (e) {
            console.error("Error loading stored vessel data", e);
          }
        }

        // Listen for changes to the "Only Tracked" and "OpenSeaMap Overlay" checkboxes.
        document.getElementById('only-focussed').addEventListener('change', () => {
  	    updateFocussedVisibility();
	    updateStationaryMarkers();
	    sendSummaryRequest();
            updateOverlay();
	});
	document.getElementById('openseamap-overlay').addEventListener('change', () => {
	  const overlayEnabled = document.getElementById('openseamap-overlay').checked;
	  if (overlayEnabled) {
	    if (!map.hasLayer(openSeaMapLayer)) {
	      map.addLayer(openSeaMapLayer);
	    }
	    // Bring it to the front after it’s added.
	    openSeaMapLayer.bringToFront();
	  } else {
	    if (map.hasLayer(openSeaMapLayer)) {
	      map.removeLayer(openSeaMapLayer);
	    }
	  }
	});

        // Connect to the Socket.IO server.
        const socket = io();
        let instantChannel = null;
        let instantHandler = null;

        // Listen for the socket connection event.
        socket.on('connect', () => {
          document.getElementById('status-dot').style.background = 'green';
          document.getElementById('status-text').textContent = 'Connected';
	  socket.emit("subscribe", "summaryData");
	  // If a vessel is focused, resubscribe to its channel.
	  if (focusedVessel) {
	    subscribeInstantUpdates(focusedVessel);
  	}
        });

        // Listen for the socket disconnection event.
        socket.on('disconnect', () => {
          document.getElementById('status-dot').style.background = 'red';
          document.getElementById('status-text').textContent = 'Disconnected';
        });

socket.on('metricsData', (data) => {
  // Extract the values from the received data
  const { window_messages, window_ratio_forwarded_to_received } = data;

  // Calculate messages per second
  const msgPerSec = window_messages;

  // Calculate ratio as percentage
  const forwardedRatioPercent = (window_ratio_forwarded_to_received * 100).toFixed(0);

  // Update the DOM with the new values
  document.getElementById('msg-per-sec').textContent = `${msgPerSec}/sec`;
  document.getElementById('forwarded-ratio').textContent = `${forwardedRatioPercent}%`;
});

socket.on("summaryData", (data) => {
  const ageSlider = document.getElementById('age-slider');
  const maxAgeHours = parseInt(ageSlider.value, 10); // Get max-age from the slider
  const now = Date.now();
  const maxAgeMilliseconds = maxAgeHours * 3600000;  // Convert hours to milliseconds

  if (typeof data === "string") {
    try {
      data = JSON.parse(data);
    } catch (e) {
      console.error("Failed to parse JSON:", e);
      return;
    }
  }
  if (typeof data !== "object" || Array.isArray(data)) {
    console.error("Received invalid data format:", data);
    return;
  }

  // Remove vessels that no longer appear in the summary data.
  const newIDs = new Set(Object.keys(data));
  for (const userid in vesselData) {
    // Only remove if the vessel is not in the latest summary AND is not manually focused
    if (!newIDs.has(userid) && userid !== focusedVessel) {
      if (vesselMarkers[userid]) map.removeLayer(vesselMarkers[userid]);
      if (vesselTracks[userid]) map.removeLayer(vesselTracks[userid]);
      delete vesselData[userid];
      delete vesselMarkers[userid];
      delete vesselTracks[userid];
    }
  }

  for (const userid in data) {
    const vesselState = data[userid];
    const vesselTimestamp = new Date(vesselState.LastUpdated).getTime();

    // Create new vessel data if not already present.
    if (!vesselData[userid]) {
      vesselData[userid] = Object.assign({}, vesselState);
      vesselData[userid].track = [];
      vesselData[userid].color = randomColor();
    } else {
      // For a focused vessel, update only non-location/movement fields.
      if (userid === focusedVessel) {
        // Save the current receiver information
        const currentReceiverId = vesselData[userid].receiver_id;
        const currentReceiverID = vesselData[userid].ReceiverID;
        
        // Destructure to remove the location/movement fields.
        const { Latitude, Longitude, Sog, Cog, TrueHeading, ReceiverID, ...nonLocationData } = vesselState;
        Object.assign(vesselData[userid], nonLocationData);
        
        // Restore the receiver IDs to prevent flickering
        if (currentReceiverId !== undefined) vesselData[userid].receiver_id = currentReceiverId;
        if (currentReceiverID !== undefined) vesselData[userid].ReceiverID = currentReceiverID;
      } else {
        // Not in focus, so merge all fields.
        Object.assign(vesselData[userid], vesselState);
      }
    }
    // Always update these timestamp fields.
    vesselData[userid].LastUpdated = vesselState.LastUpdated;
    vesselData[userid].lastUpdate = vesselTimestamp;

    if (!Array.isArray(vesselData[userid].track)) {
      vesselData[userid].track = [];
    }
    // append the new summary point
    vesselData[userid].track.push([
      vesselState.LastUpdated,           // ISO timestamp
      vesselState.Latitude,              // lat
      vesselState.Longitude,             // lon
      vesselState.Sog  ?? null,          // speed
      vesselState.Cog  ?? null,          // course
      vesselState.TrueHeading ?? null    // heading
    ]);

    const popupContent = createPopupContent(vesselData[userid]);

    // Update marker/track if location data exists…
    if (typeof vesselState.Latitude === "number" && typeof vesselState.Longitude === "number") {
      if (userid !== focusedVessel) {
        // For vessels not in focus, update location and movement fields.
        const lat = vesselState.Latitude;
        const lon = vesselState.Longitude;
        if (vesselMarkers[userid]) {
          vesselMarkers[userid].setLatLng([lat, lon]);
          vesselMarkers[userid].getPopup().setContent(popupContent);
          const markerElem = vesselMarkers[userid].getElement() || vesselMarkers[userid]._icon;
          if (markerElem) {
            const svg = markerElem.querySelector('svg');
            if (svg) {
              const heading =
                (typeof vesselState.TrueHeading === 'number' && vesselState.TrueHeading < 360)
                  ? vesselState.TrueHeading
                  : (typeof vesselState.Cog === 'number' && vesselState.Cog >= 0 && vesselState.Cog < 360)
                    ? vesselState.Cog
                    : 0;
              svg.style.transform = `rotate(${heading}deg)`;
            }
          }
          if (vesselState.Name && userid !== focusedVessel) {
            vesselMarkers[userid].unbindTooltip();
            if (map.getZoom() >= TOOLTIP_ZOOM_THRESHOLD) {
              vesselMarkers[userid].bindTooltip(vesselState.Name, {
                permanent: true,
                direction: 'top',
                className: 'vessel-tooltip',
                interactive: true
              }).openTooltip();
              attachTooltipClick(vesselMarkers[userid], userid);
            }
          }
          vesselMarkers[userid].off('click');
          vesselMarkers[userid].on('click', function(e) {
            if (e && typeof e.stopPropagation === 'function') { e.stopPropagation(); }
            if (e && typeof e.preventDefault === 'function') { e.preventDefault(); }
            focusOnVessel(userid);
          });
          const markerElem2 = vesselMarkers[userid].getElement() || vesselMarkers[userid]._icon;
          if (markerElem2) {
            markerElem2.classList.add('enlarge');
            setTimeout(() => markerElem2.classList.remove('enlarge'), 500);
          }
        } else {
          const marker = L.marker(
            [vesselState.Latitude, vesselState.Longitude],
            { icon: getVesselIcon(vesselData[userid]) }
          ).addTo(map);
          marker.bindPopup(popupContent, { autoPan: false });
          const currentZoom = map.getZoom();
          if (currentZoom >= TOOLTIP_ZOOM_THRESHOLD && vesselState.Name) {
            marker.bindTooltip(vesselState.Name, {
              permanent: true,
              direction: 'top',
              className: 'vessel-tooltip',
              interactive: true
            }).openTooltip();
            attachTooltipClick(marker, userid);
          }
          marker.on('click', function(e) {
            if (e && typeof e.stopPropagation === 'function') { e.stopPropagation(); }
            if (e && typeof e.preventDefault === 'function') { e.preventDefault(); }
            focusOnVessel(userid);
          });
          if (!isMobile) {
            marker.on('mouseover', function() { this.openPopup(); });
            marker.on('mouseout', function() { this.closePopup(); });
          }
          vesselMarkers[userid] = marker;
        }
       if (userid === focusedVessel) {
         const filteredTrack = filterTrackPoints(vesselData[userid].track);
         if (vesselTracks[userid]) map.removeLayer(vesselTracks[userid]);
         vesselTracks[userid] = createColoredTrack(filteredTrack);
         map.addLayer(vesselTracks[userid]);
         attachPolylineEvents(vesselTracks[userid], userid);
       }
      } else {
        // For a focused vessel, skip location updates—only update its popup.
        if (vesselMarkers[userid]) {
          vesselMarkers[userid].getPopup().setContent(popupContent);
        }
      }
    } else {
      if (vesselMarkers[userid]) {
        vesselMarkers[userid].getPopup().setContent(popupContent);
        vesselMarkers[userid].unbindTooltip();
        vesselMarkers[userid].bindTooltip(popupContent, {
          direction: 'top',
          className: 'vessel-tooltip'
        });
      }
    }

    if (focusedVessel && focusedVessel == userid && !detailsOverlayHidden) {
      if (isMobile) {
        map.panTo(vesselMarkers[userid].getLatLng());
      } else {
        focusOnVessel(userid, false);
      }
    }
  }
  // Update UI elements but avoid triggering vessel-receiver connection updates
  // This helps prevent flickering when summary data arrives
  updateOverlay();
  
  // Don't call these functions as they might trigger vessel-receiver connection updates
  // updateFocussedVisibility();
  // updateStationaryMarkers();
  
  // Instead, just ensure the focused vessel's marker and track are visible
  if (focusedVessel && vesselMarkers[focusedVessel]) {
    if (!map.hasLayer(vesselMarkers[focusedVessel])) {
      map.addLayer(vesselMarkers[focusedVessel]);
    }
    
    const showPaths = document.getElementById('show-paths').checked;
    if (vesselTracks[focusedVessel]) {
      if (showPaths && !map.hasLayer(vesselTracks[focusedVessel])) {
        map.addLayer(vesselTracks[focusedVessel]);
      }
    }
  }
  
  // Redraw radius circles after receiving new data if a receiver is selected
  if (selectedReceiverId && selectedReceiverCoords) {
    const receiverLatLng = L.latLng(selectedReceiverCoords[0], selectedReceiverCoords[1]);
    drawRadiusCircles(selectedReceiverCoords);
  }
  
  localStorage.setItem('vesselData', JSON.stringify(vesselData));
});

// Use a debounced function to limit the frequency of requests:
// Global variables to store the current search query and the interval timer.
let currentSearchQuery = '';
let searchInterval = null;

document.getElementById('vessel-filter').addEventListener('input', function(event) {
  // Update current search query with trimmed value.
  currentSearchQuery = event.target.value.trim();

  // Check if the query meets the length threshold.
  if (currentSearchQuery.length < 3) {
    // If below threshold, clear any active search interval.
    if (searchInterval) {
      clearInterval(searchInterval);
      searchInterval = null;
    }
    // Update the overlay normally.
    updateOverlay();
    return;
  }

  // If the query length is 3 or more:
  // Call the search function immediately.
  performSearch(currentSearchQuery);

  // If no interval is already running, set one up for every 5 seconds.
  if (!searchInterval) {
    searchInterval = setInterval(() => {
      // Use the latest query value in case the user modifies it.
      performSearch(currentSearchQuery);
    }, 10000);
  }
});

// Function that performs the search fetch.
function performSearch(query) {
  // Get the current max-age value from the age slider (in hours)
  const ageSlider = document.getElementById("age-slider");
  const maxAge = parseInt(ageSlider.value, 10); // Convert the value to an integer

  // Include both the query and the max-age (with field name "maxAge") in the request body.
  fetch('/search', {
    method: 'POST',
    headers: { 'Content-Type': 'application/json' },
    body: JSON.stringify({ query: query, maxAge: maxAge })
  })
  .then(response => {
    if (!response.ok) {
      throw new Error(`Server error: ${response.status}`);
    }
    return response.json();
  })
  .then(searchResults => {
    const receiverResults = Object.values(receiverData).filter(receiver => {
      // First check if the receiver is within the max age limit
      const maxAgeHours = parseInt(document.getElementById("age-slider").value, 10);
      const now = Date.now();
      let lastUpdated;
      
      try {
        lastUpdated = new Date(receiver.LastUpdated).getTime();
        if (isNaN(lastUpdated)) {
          return false; // Skip receivers with invalid dates
        }
      } catch (error) {
        return false; // Skip receivers with dates that cause errors
      }
      
      const ageMilliseconds = now - lastUpdated;
      if (ageMilliseconds > maxAgeHours * 3600000) {
        return false; // Skip receivers older than max age
      }
      
      // Then check if it matches the search query
      const q = query.toLowerCase();
      return (
        receiver.Name.toLowerCase().includes(q) ||
        (receiver.CallSign && receiver.CallSign.toLowerCase().includes(q)) ||
        receiver.UserID.toString().includes(q)
      );
    });

    // Merge the two arrays and render the results.
    const combinedResults = searchResults.concat(receiverResults);
    renderSearchResults(combinedResults);
  })
  .catch(err => {
    console.error('Search request failed:', err);
    updateOverlay();
  });
}


 document.getElementById('stationary').addEventListener('change', () => {
  	  sendSummaryRequest();
    	  updateStationaryMarkers();
	});

        // Attach tooltip click listener.
        function attachTooltipClick(marker, UserID) {
          setTimeout(() => {
            const tooltip = marker.getTooltip();
            if (tooltip) {
              const ttEl = tooltip.getElement();
              if (ttEl) {
                ttEl.addEventListener('click', (e) => {
                  if (e && typeof e.stopPropagation === 'function') {
 		     e.stopPropagation();
		   }
                  focusOnVessel(UserID);
                });
              }
            }
          }, 0);
        }

	let lastFetchedUserID = null;

	function fetchMissingData(UserID) {
	  // Only fetch if this vessel hasn't already had its missing data fetched this selection.
	  if (lastFetchedUserID === UserID) return;

	  fetch(`/state?UserID=${UserID}`)
	    .then(response => {
	      if (!response.ok) {
	        throw new Error(`Network response was not ok (${response.status})`);
	      }
	      return response.json();
	    })
	    .then(data => {
	      Object.assign(vesselData[UserID], data);
	      updateVesselDetailOverlay();
	      lastFetchedUserID = UserID;
	    })
	    .catch(err => {
	      console.error("Error fetching missing vessel data:", err);
	    });
	}

// Function to find the nearest point on the polyline track to the mouse event latlng.
function getNearestTrackPoint(e, track) {
  const mouseLatLng = e.latlng;
  let minDistance = Infinity;
  let nearestPoint = null;
  
  // Iterate over each point in the track (each point is [timestamp, lat, lon])
  track.forEach(pt => {
    // Create a Leaflet LatLng object for comparison.
    const ptLatLng = L.latLng(pt[1], pt[2]);
    const distance = mouseLatLng.distanceTo(ptLatLng);
    if (distance < minDistance) {
      minDistance = distance;
      nearestPoint = { ptLatLng, info: pt };
    }
  });
  return nearestPoint;
}




// Function to calculate distance between two points in kilometers
function calculateDistanceInKm(lat1, lon1, lat2, lon2) {
  const R = 6371; // Earth's radius in km
  const dLat = (lat2 - lat1) * Math.PI / 180;
  const dLon = (lon2 - lon1) * Math.PI / 180;
  const a =
    Math.sin(dLat/2) * Math.sin(dLat/2) +
    Math.cos(lat1 * Math.PI / 180) * Math.cos(lat2 * Math.PI / 180) *
    Math.sin(dLon/2) * Math.sin(dLon/2);
  const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1-a));
  return R * c;
}

// Function to calculate bearing (angle) from point 1 to point 2 in degrees
function calculateBearing(lat1, lon1, lat2, lon2) {
  // Convert to radians
  const lat1Rad = lat1 * Math.PI / 180;
  const lat2Rad = lat2 * Math.PI / 180;
  const lonDiff = (lon2 - lon1) * Math.PI / 180;
  
  // Calculate bearing
  const y = Math.sin(lonDiff) * Math.cos(lat2Rad);
  const x = Math.cos(lat1Rad) * Math.sin(lat2Rad) -
            Math.sin(lat1Rad) * Math.cos(lat2Rad) * Math.cos(lonDiff);
  let bearing = Math.atan2(y, x) * 180 / Math.PI;
  
  // Normalize to 0-360
  bearing = (bearing + 360) % 360;
  
  return bearing;
}

// Global variable to track the current receiver ID being used for the connection
let currentConnectionReceiverId = null;

// Function to update the vessel-receiver connection
function updateVesselReceiverConnection(UserID) {
  // Throttle updates to prevent flickering
  const now = Date.now();
  if (now - lastReceiverUpdateTime < RECEIVER_UPDATE_THROTTLE) {
    return; // Skip this update if it's too soon after the last one
  }
  lastReceiverUpdateTime = now;
  
  // Debug log to track when this function is called
  console.log("[updateVesselReceiverConnection] called at", new Date().toISOString());
  
  // Ensure we're still working with the focused vessel
  if (focusedVessel !== UserID) {
    return; // Don't update if this is no longer the focused vessel
  }
  
  const vessel = vesselData[UserID];
  if (!vessel) return;
  
  // Ensure vessel has valid coordinates
  if (typeof vessel.Latitude !== 'number' || typeof vessel.Longitude !== 'number') {
    return; // Skip if vessel doesn't have valid coordinates
  }
  
  // Check for receiver ID in different possible fields
  // First try receiver_id from ais_data events
  let receiverId = vessel.receiver_id;
  
  // If not found, try ReceiverID from state JSON
  if (receiverId === null || receiverId === undefined) {
    receiverId = vessel.ReceiverID;
  }
  
  // If we already have a connection established, keep using the same receiver
  // This prevents flickering when summary data arrives with different receiver info
  if (currentConnectionReceiverId && receiverMarkers[currentConnectionReceiverId]) {
    console.log("[updateVesselReceiverConnection] Using existing receiver:", currentConnectionReceiverId);
    receiverId = currentConnectionReceiverId;
  } else {
    // First time or previous receiver no longer exists
    currentConnectionReceiverId = receiverId;
    console.log("[updateVesselReceiverConnection] Setting new receiver:", receiverId);
  }
  
  // Check if we have a valid receiver ID and if that receiver exists
  if (receiverId !== null && receiverId !== undefined && receiverMarkers[receiverId]) {
    const vesselLatLng = [vessel.Latitude, vessel.Longitude];
    const receiverLatLng = receiverMarkers[receiverId].getLatLng();
    
    // Double-check that both coordinates are valid
    if (!vesselLatLng[0] || !vesselLatLng[1] || !receiverLatLng.lat || !receiverLatLng.lng) {
      console.warn("Invalid coordinates for vessel-receiver connection");
      return;
    }
    
    // Calculate the midpoint for the label
    const midLat = (vesselLatLng[0] + receiverLatLng.lat) / 2;
    const midLng = (vesselLatLng[1] + receiverLatLng.lng) / 2;
    
    // Calculate distance in kilometers
    const distance = calculateDistanceInKm(
      vesselLatLng[0], vesselLatLng[1],
      receiverLatLng.lat, receiverLatLng.lng
    ).toFixed(1);
    
    // Calculate bearing from receiver to vessel
    const bearing = calculateBearing(
      receiverLatLng.lat, receiverLatLng.lng,
      vesselLatLng[0], vesselLatLng[1]
    ).toFixed(0);
    
    // Create or update the polyline with a single operation
    try {
      if (!receiverPolyline || !map.hasLayer(receiverPolyline)) {
        console.log("[updateVesselReceiverConnection] Creating new polyline");
        // First creation or polyline was removed
        if (receiverPolyline) {
          // Try to clean up any existing polyline
          try {
            map.removeLayer(receiverPolyline);
          } catch (e) {
            // Ignore errors
          }
        }
        
        // Create a new polyline
        receiverPolyline = L.polyline([vesselLatLng, receiverLatLng], {
          color: 'grey',
          weight: 2,
          opacity: 0.7,
          dashArray: '5, 5',
          renderer: L.canvas(), // Use canvas renderer for better performance
          interactive: false, // Disable mouse events for better performance
          bubblingMouseEvents: false // Prevent event bubbling
        });
        
        // Add to map in a separate step to catch any errors
        try {
          receiverPolyline.addTo(map);
        } catch (e) {
          console.warn("Error adding polyline to map:", e);
          receiverPolyline = null; // Reset so we'll try again next time
          return;
        }
      } else {
        // Just update coordinates - no DOM changes
        receiverPolyline.setLatLngs([vesselLatLng, receiverLatLng]);
      }
    } catch (e) {
      console.warn("Error handling polyline:", e);
      // Don't try to recreate immediately - wait for next update cycle
      receiverPolyline = null;
      return;
    }
    
    // Create or update the label with minimal DOM changes
    const labelContent = `${distance} km<br>${bearing}°`;
    
    try {
      if (!receiverDistanceLabel || !map.hasLayer(receiverDistanceLabel)) {
        console.log("[updateVesselReceiverConnection] Creating new distance label");
        // First creation or label was removed
        if (receiverDistanceLabel) {
          // Try to clean up any existing label
          try {
            map.removeLayer(receiverDistanceLabel);
          } catch (e) {
            // Ignore errors
          }
        }
        
        // Create a new tooltip
        receiverDistanceLabel = L.tooltip({
          permanent: true,
          direction: 'center',
          className: 'distance-label-tooltip',
          opacity: 0.9,
          interactive: false,
          bubblingMouseEvents: false
        });
        
        // Set content and position before adding to map
        receiverDistanceLabel.setLatLng([midLat, midLng]);
        receiverDistanceLabel.setContent(labelContent);
        
        // Add to map in a separate step to catch any errors
        try {
          receiverDistanceLabel.addTo(map);
        } catch (e) {
          console.warn("Error adding distance label to map:", e);
          receiverDistanceLabel = null; // Reset so we'll try again next time
          return;
        }
      } else {
        // Update position first
        receiverDistanceLabel.setLatLng([midLat, midLng]);
        
        // Only update content if it changed significantly
        const currentContent = receiverDistanceLabel.getContent();
        if (currentContent !== labelContent) {
          receiverDistanceLabel.setContent(labelContent);
        }
      }
    } catch (e) {
      console.warn("Error handling distance label:", e);
      // Don't try to recreate immediately - wait for next update cycle
      receiverDistanceLabel = null;
      return;
    }
  }
}

// Focus on a particular vessel.
function focusOnVessel(UserID, initialFocus = true) {
  // Unfocus previously focused vessel
  if (initialFocus) {
	document.getElementById('show-paths').checked = true;
  }
  
  // Only remove vessel-receiver connection if focusing on a different vessel
  // This prevents unnecessary recreation when summary data arrives
  if (focusedVessel !== UserID) {
    console.log("[focusOnVessel] Removing existing vessel-receiver connection");
    
    if (receiverPolyline) {
      map.removeLayer(receiverPolyline);
      receiverPolyline = null;
    }
    
    if (receiverDistanceLabel) {
      map.removeLayer(receiverDistanceLabel);
      receiverDistanceLabel = null;
    }
    
    // Reset the current connection receiver ID when changing vessels
    currentConnectionReceiverId = null;
  }
  
  // Clear any existing update interval
  if (receiverUpdateInterval) {
    clearInterval(receiverUpdateInterval);
    receiverUpdateInterval = null;
  }
  if (focusedVessel && focusedVessel !== UserID) {
    const prevMarker = vesselMarkers[focusedVessel];
    if (prevMarker) {
      // If a tooltip exists, update its content; otherwise, bind a default one.
      let prevTooltip = prevMarker.getTooltip();
      if (!prevTooltip) {
        prevMarker.bindTooltip(vesselData[focusedVessel].Name, {
          permanent: true,
          direction: 'top',
          className: 'vessel-tooltip'
        });
        prevTooltip = prevMarker.getTooltip();
      }
      if (prevTooltip) {
        prevTooltip.setContent(vesselData[focusedVessel].Name);
      }
      prevMarker.closeTooltip();
      prevMarker.setZIndexOffset(0);
      const prevElem = prevMarker.getElement();
      if (prevElem) {
        prevElem.classList.remove('enlarge');
      }
    }
  }
  
  // Update subscriptions if focusing on a new vessel
  if (focusedVessel !== UserID) {
    clearLiveLogs();
    if (instantChannel) {
      unsubscribeInstantUpdates();
    }
    subscribeInstantUpdates(UserID);
    hydrateTrackHistory(UserID);
  }
  

  if (focusedVessel && focusedVessel !== UserID) {
    const prevMarker = vesselMarkers[focusedVessel];
    if (prevMarker) {
      let prevTooltip = prevMarker.getTooltip();
      if (!prevTooltip) {
        prevMarker.bindTooltip(vesselData[focusedVessel].Name, {
          permanent: true,
          direction: 'top',
          className: 'vessel-tooltip'
        });
        prevTooltip = prevMarker.getTooltip();
      }
      if (prevTooltip) {
        prevTooltip.setContent(vesselData[focusedVessel].Name);
      }
      prevMarker.closeTooltip();
      prevMarker.setZIndexOffset(0);
      const prevElem = prevMarker.getElement();
      if (prevElem) {
        prevElem.classList.remove('enlarge');
      }
    }
  }
  
  // Set the new focused vessel.
  focusedVessel = UserID;

  for (const userid in vesselTracks) {
    if (userid !== focusedVessel && map.hasLayer(vesselTracks[userid])) {
      map.removeLayer(vesselTracks[userid]);
    }
  }
  
  // Create vessel-receiver connection if applicable
  // Ensure we call this after a short delay to allow the vessel data to be fully loaded
  setTimeout(() => {
    updateVesselReceiverConnection(UserID);
    
    // Clear any existing update interval
    if (receiverUpdateInterval) {
      clearInterval(receiverUpdateInterval);
    }
    
    // Set up a periodic update to ensure the connection stays visible
    // Use a longer interval to reduce flickering
    receiverUpdateInterval = setInterval(() => {
      if (focusedVessel === UserID) {
        // Only update if the vessel is still focused
        console.log("[receiverUpdateInterval] Updating vessel-receiver connection");
        updateVesselReceiverConnection(UserID);
      } else {
        // Stop updating if this is no longer the focused vessel
        console.log("[receiverUpdateInterval] Stopping interval - vessel no longer focused");
        clearInterval(receiverUpdateInterval);
        receiverUpdateInterval = null;
      }
    }, 5000); // Update every 5 seconds instead of 2 seconds
  }, 100);

  // Now add the focused vessel’s polyline (if it exists) based on the "show-paths" checkbox.
  if (document.getElementById('show-paths').checked && vesselTracks[focusedVessel] && !map.hasLayer(vesselTracks[focusedVessel])) {
    map.addLayer(vesselTracks[focusedVessel]);
  }


  const marker = vesselMarkers[UserID];
  if (!marker) return; // Ensure marker exists
  marker.setZIndexOffset(1000);
  const vessel = vesselData[UserID];
  
  updateLatLongDisplay();
  
  // Build new tooltip content.
  const line1 = buildTooltipLine(
    vessel.Destination,
    (navigationalStatusMapping[vessel.NavigationalStatus] || vessel.NavigationalStatus) !== 'Unknown'
      ? (navigationalStatusMapping[vessel.NavigationalStatus] || vessel.NavigationalStatus)
      : null
  );
  // Tooltip “Type” for live-updates: branch on AtoN
  const utMapping = (vessel.AISClass === "AtoN")
    ? staticAtoNTypeMapping
   : staticTypeMapping;
  const utTypeText = utMapping[vessel.Type] || vessel.Type;
  const line2 = buildTooltipLine(
    utTypeText,
    (vessel.MaximumStaticDraught != null ? `${vessel.MaximumStaticDraught} m` : null),
    (vessel.Sog != null                     ? `${vessel.Sog} kn`                  : null),
    (vessel.TrueHeading != null && vessel.TrueHeading < 360
      ? `${vessel.TrueHeading}°`
      : `${vessel.Cog}°`)
 );

  const tooltipLines = [`${vessel.Name}${vessel.CallSign ? ` (${vessel.CallSign})` : ''}`];

  if (line1.trim()) tooltipLines.push(line1);
  if (line2.trim()) tooltipLines.push(line2);
  tooltipLines.push(timeAgo(vessel.lastUpdate));
  const newTooltipContent = tooltipLines.join('<br>');
  
  // Make sure the marker has a tooltip before updating.
  let tooltip = marker.getTooltip();
  if (!tooltip) {
    marker.bindTooltip(newTooltipContent, {
      permanent: true,
      direction: 'top',
      className: 'vessel-tooltip',
      interactive: true
    }).openTooltip();
    tooltip = marker.getTooltip();
  } else {
    tooltip.setContent(newTooltipContent);
  }
  
  // Set tooltip element's z-index.
  const tooltipEl = tooltip.getElement();
  if (tooltipEl) {
    tooltipEl.style.zIndex = '1200';
  }
  
  // Show detail overlay and related buttons.
  document.getElementById('toggle-detail-overlay').style.display = 'block';
  document.getElementById('live-logs').style.display = 'block';
  document.getElementById('stats-button').style.display = 'block';
  
  const detailOverlay = document.getElementById('vessel-detail');
  if (!detailsOverlayHidden) {
    detailOverlay.style.display = 'block';
    document.getElementById('toggle-detail-overlay').textContent = 'Hide';
  } else {
    detailOverlay.style.display = 'none';
    document.getElementById('toggle-detail-overlay').textContent = 'Show';
  }
  
  if (isMobile) {
    setTimeout(() => {
      updateVesselDetailHeader(UserID);
    }, 300);  // 300 ms delay; adjust as needed
  } else {
    updateVesselDetailHeader(UserID);
  }
  
  // Attach copy link event.
  const copyLinkEl = document.getElementById('copy-link');
  if (copyLinkEl) {
    copyLinkEl.addEventListener('click', (e) => {
      if (e && typeof e.stopPropagation === 'function') {
        e.stopPropagation();
      }
      const currentUrl = window.location.href.split('?')[0];
      const copyUrl = `${currentUrl}?UserID=${vesselData[UserID].UserID}`;
      function updateLinkText(newText) {
        copyLinkEl.textContent = newText;
        setTimeout(() => {
          copyLinkEl.textContent = "Link";
        }, 2000);
      }
      if (navigator.clipboard && navigator.clipboard.writeText) {
        navigator.clipboard.writeText(copyUrl).then(() => {
          updateLinkText("Link Copied");
        }).catch(err => {
          console.error("Failed to copy: ", err);
        });
      } else {
        const textArea = document.createElement("textarea");
        textArea.value = copyUrl;
        document.body.appendChild(textArea);
        textArea.select();
        try {
          document.execCommand('copy');
          updateLinkText("Link Copied");
        } catch (err) {
          console.error("Fallback: Unable to copy", err);
        }
        document.body.removeChild(textArea);
      }
    });
  }
  




// Helper function to show flash message
function showFlashMessage(message, parentEl) {
  const flashMsg = document.createElement('span');
  flashMsg.textContent = ` ${message}`;
  flashMsg.style.color = 'green';
  parentEl.appendChild(flashMsg);
  setTimeout(() => {
    flashMsg.remove();
  }, 1000);
}


         // Update the Live Logs modal title with the vessel name.
         const liveLogsTitle = document.getElementById('live-logs-title');
         if (vesselData[UserID].Name) {
           liveLogsTitle.textContent = `${vesselData[UserID].Name}`;
         } else {
           liveLogsTitle.textContent = 'Live Messages';
         }
          const detailContent = createDetailContent(vesselData[UserID]);
          document.getElementById('detail-content').innerHTML = detailContent;

	  // Fetch missing data from /state?UserID=<UserID> and update overlay.
	  fetchMissingData(UserID);

	if (initialFocus) {
	  const markerLatLng = vesselMarkers[UserID].getLatLng();
	  const currentZoom = map.getZoom();
	  const desiredZoom = 13;
  
	  if (currentZoom >= desiredZoom) {
	    // If already zoomed in enough, just pan to the vessel's location.
	    map.panTo(markerLatLng);
	  } else {
	    // Otherwise, fit bounds and set the zoom to desiredZoom at most.
	    let bounds = L.latLngBounds([]);
	    bounds.extend(markerLatLng);
	    map.fitBounds(bounds, { padding: [50, 50], maxZoom: desiredZoom });
	  }
	}

          updateFocussedVisibility();
        }

// Update the vessel-receiver connection when the map is moved or zoomed
map.on('moveend zoomend', function() {
  if (focusedVessel && vesselData[focusedVessel]) {
    updateVesselReceiverConnection(focusedVessel);
  }
});

        document.getElementById('toggle-known-overlay').addEventListener('click', function() {
          const overlay = document.getElementById('vessel-overlay');
          const currentDisplay = window.getComputedStyle(overlay).display;
          if (currentDisplay === 'none') {
            overlay.style.display = 'block';
            this.textContent = 'Hide Vessels';
	    const filterInput = document.getElementById('vessel-filter');
	    if (filterInput.value.trim().length >= 3) {
	      filterInput.dispatchEvent(new Event('input'));
	    }
          } else {
            overlay.style.display = 'none';
            this.textContent = 'Show Vessels';
          }
        });

        document.getElementById('toggle-detail-overlay').addEventListener('click', function() {
          const detailOverlay = document.getElementById('vessel-detail');
          if (detailOverlay.style.display === 'none' || detailOverlay.style.display === '') {
            detailOverlay.style.display = 'block';
            this.textContent = 'Hide';
            detailsOverlayHidden = false;
          } else {
            detailOverlay.style.display = 'none';
            this.textContent = 'Show';
            detailsOverlayHidden = true;
          }
       });

    const liveLogFilters = {
      "PositionReport": true,
      "ShipStaticData": true,
      "StaticDataReport": true,
      "StandardClassBPositionReport": true,
      "ExtendedClassBPositionReport": true,
      "AidsToNavigationReport": true,
      "BaseStationReport": true,
      "BinaryBroadcastMessage": true,
      "StandardSearchAndRescueAircraftReport": true
    };

    document.querySelectorAll('.log-filter').forEach(checkbox => {
      checkbox.addEventListener('change', function() {
        liveLogFilters[this.value] = this.checked;
        applyLogFilters();  // Use the new filter state in your live logs
      });
    });

       document.getElementById('stats-button').addEventListener('click', () => {
         if (focusedVessel) {
           // Open popup window with the current vessel's UserID.
           window.open('/stats.html?UserID=' + focusedVessel, '_blank', 'width=400,height=700');
         }
       });

window.addEventListener('load', () => {
  // Get URL parameters and check for the UserID parameter.
  const params = new URLSearchParams(window.location.search);
  const UserIDParam = params.get('UserID');
  const skipUserZoom = Boolean(UserIDParam);

  const filterInput = document.getElementById('vessel-filter');
  if (filterInput.value.trim().length >= 3) {
    filterInput.dispatchEvent(new Event('input'));
  }

  // Check for receiver based on user's IP
  const checkForUserReceiver = () => {
    // First get the user's IP
    fetch('/myip')
      .then(response => {
        if (!response.ok) {
          throw new Error(`Failed to get user IP: ${response.status}`);
        }
        return response.json();
      })
      .then(ipData => {
        if (ipData && ipData.ip) {
          // Now query for receivers with this IP
          return fetch(`/receivers?ip_address=${ipData.ip}`);
        } else {
          throw new Error('No IP address returned');
        }
      })
      .then(response => {
        if (!response.ok) {
          throw new Error(`Failed to get receivers: ${response.status}`);
        }
        return response.json();
      })
      .then(receivers => {
        // Check if any receivers were returned and have an ID
        if (Array.isArray(receivers) && receivers.length > 0 && receivers[0].id) {
          const receiver = receivers[0];
          const receiverId = String(receiver.id);
          
          // Wait a moment for receiver markers to be created
          setTimeout(() => {
            if (receiverMarkers[receiverId]) {
              // Zoom to the receiver marker
              map.setView([receiver.latitude, receiver.longitude], 13);
              
              // Open the tooltip for this receiver
              receiverMarkers[receiverId].openTooltip();
              
              // Simulate a click on the marker to ensure tooltip is displayed
              setTimeout(() => {
                // Fire a click event on the marker
                receiverMarkers[receiverId].fire('click');
                
                // If that doesn't work, try to open the popup which might make the tooltip visible
                receiverMarkers[receiverId].openPopup();
              }, 500);
            }
          }, 1000);
        }
      })
      .catch(error => {
        console.error('Error checking for user receiver:', error);
      });
  };

  // If UserID is provided, fetch the state and center the map accordingly.
  if (UserIDParam) {
    fetch(`/state?UserID=${UserIDParam}`)
      .then(response => {
        if (!response.ok) {
          throw new Error(`Network error: ${response.status}`);
        }
        return response.json();
      })
      .then(data => {
        const userSummary = data;

        // Validate that the summary contains valid Latitude and Longitude fields.
        if (userSummary && typeof userSummary.Latitude === 'number' && typeof userSummary.Longitude === 'number') {
          // Center the map on these coordinates; adjust the zoom level as needed.
          map.setView([userSummary.Latitude, userSummary.Longitude], 10);
        } else {
          console.warn('Summary data is missing valid latitude and longitude fields.');
        }
      })
      .catch(error => {
        console.error('Error fetching summary:', error);
      });
  } else {
    // Only check for user receiver if no UserID parameter is provided
    checkForUserReceiver();
  }

  updateStationaryMarkers();
  if (navigator.geolocation) {
    navigator.geolocation.getCurrentPosition(
      (position) => {
        userLatLng = [position.coords.latitude, position.coords.longitude];
        const userMarker = L.marker(userLatLng, { draggable: true })
          .addTo(map)

      userMarker.on('dragend', function(e) {
        const newPos = e.target.getLatLng();
        userLatLng = [newPos.lat, newPos.lng];
        document.getElementById('latlong-display').textContent =
          `${newPos.lat.toFixed(5)}, ${newPos.lng.toFixed(5)}`;
      });        

        if (!skipUserZoom) {
          map.setView(userLatLng, 10);
        }

        // Allow some time for vessel markers to load or update
        setTimeout(() => {
          const bounds = map.getBounds();
          let vesselFound = false;
          let firstVesselLatLng = null;

          // Assume vesselMarkers is a global object containing your vessel markers
          for (const key in vesselMarkers) {
            if (vesselMarkers.hasOwnProperty(key)) {
              const marker = vesselMarkers[key];
              const markerLatLng = marker.getLatLng();
              if (!firstVesselLatLng) {
                firstVesselLatLng = markerLatLng; // store the first vessel position found
              }
              if (bounds.contains(markerLatLng)) {
                vesselFound = true;
                break;
              }
            }
          }

          // If no vessel marker is found in the current viewport and we have at least one vessel marker...
          if (!vesselFound && firstVesselLatLng) {
            // Create a bounds that includes both the user's location and the vessel marker
            const newBounds = L.latLngBounds([userLatLng, firstVesselLatLng]);
            // Fit the map to the new bounds with some padding
            map.fitBounds(newBounds, { padding: [50, 50] });
          }
        }, 1000); // 1 second delay; adjust if necessary
      },
      (error) => {
        debouncedAdjustMapBounds();
        map.fire('moveend');
      }
    );
  } else {
    debouncedAdjustMapBounds();
    map.fire('moveend');
  }

 refreshReceivers();
 setInterval(refreshReceivers, 60000);

  if (UserIDParam) {
    // Delay the focus call to allow vessel markers to load
    setTimeout(() => {
      if (vesselMarkers[UserIDParam]) {
        focusOnVessel(UserIDParam);
      } else {
        console.warn(`Vessel with UserID ${UserIDParam} not found.`);
      }
    }, 1500);
  }
});

document.getElementById('show-paths').addEventListener('change', function() {
  const showPaths    = this.checked;
  const onlyFocused  = document.getElementById('only-focussed').checked;

  // 1) First, remove all existing track layers immediately
  for (const uid in vesselTracks) {
    const layer = vesselTracks[uid];
    if (map.hasLayer(layer)) {
      map.removeLayer(layer);
    }
  }

  // 2) Now re-add only the focused vessel’s track if needed
  if (showPaths && focusedVessel && vesselTracks[focusedVessel]) {
    map.addLayer(vesselTracks[focusedVessel]);
  }

  // 3) Update any remaining visibility logic (tooltips, overlays, etc.)
  updateFocussedVisibility();
});

// Conversion: 1 nautical mile = 1852 meters.
function updateNauticalScale() {
  const scaleLabel = document.getElementById('scale-label');
  const scalePx = 100;
  const center = map.getCenter();
  const point = map.latLngToContainerPoint(center);
  const pointX = L.point(point.x + scalePx, point.y);
  const latLngX = map.containerPointToLatLng(pointX);
  const distanceMeters = center.distanceTo(latLngX);
  const distanceNM = distanceMeters / 1852;
  scaleLabel.textContent = `${distanceNM.toFixed(1)} NM`;
}

// Update the scale whenever the map is zoomed or moved.
map.on('zoomend moveend', updateNauticalScale);
// Call once to set the initial scale.
updateNauticalScale();

function updateFocussedTooltip() {
  if (focusedVessel && vesselData[focusedVessel]) {
    const vessel = vesselData[focusedVessel];
    const line1 = buildTooltipLine(
      vessel.Destination,
      (navigationalStatusMapping[vessel.NavigationalStatus] || vessel.NavigationalStatus) !== 'Unknown'
        ? (navigationalStatusMapping[vessel.NavigationalStatus] || vessel.NavigationalStatus)
        : null
    );
   // Tooltip “Type” field: use AtoN mapping when appropriate
   const ttMapping = (vessel.AISClass === "AtoN")
     ? staticAtoNTypeMapping
     : staticTypeMapping;
   const ttTypeText = ttMapping[vessel.Type] || vessel.Type;
   const line2 = buildTooltipLine(
     ttTypeText,
     (vessel.MaximumStaticDraught != null ? `${vessel.MaximumStaticDraught} m` : null),
     (vessel.Sog != null                     ? `${vessel.Sog} kn`                  : null),
     (vessel.TrueHeading != null && vessel.TrueHeading < 360
       ? `${vessel.TrueHeading}°`
       : `${vessel.Cog}°`)
   );

    const tooltipLines = [`${vessel.Name}${vessel.CallSign ? ` (${vessel.CallSign})` : ''}`];
    if (line1.trim()) tooltipLines.push(line1);
    if (line2.trim()) tooltipLines.push(line2);
    tooltipLines.push(timeAgo(vessel.lastUpdate));
    const newTooltipContent = tooltipLines.join('<br>');
    vesselMarkers[focusedVessel].getTooltip().setContent(newTooltipContent);
  }
}
setInterval(updateFocussedTooltip, 1000);


// Call updateLegend periodically to keep the legend up to date
// Update the legend periodically
setInterval(updateLegend, 2000); // Update every 2 seconds (reduced from 5 seconds)
document.getElementById('toggle-legend').addEventListener('click', function() {
  const legend = document.getElementById('vessel-legend');
  if (window.getComputedStyle(legend).display === 'none') {
    legend.style.display = 'block';  // Make it visible first
    updateLegend();                  // Then update the content immediately
    this.textContent = 'Hide Types';
  } else {
    legend.style.display = 'none';
    this.textContent = 'Show Types';
  }
});

// Add event listener for the "Clear Filter" button
document.getElementById('legend-clear-button').addEventListener('click', function() {
  // Reset all checkbox states to checked
  for (const groupName in vesselTypeGroups) {
    typeGroupCheckboxStates[groupName] = true;
  }
  
  // Update the checkboxes in the UI
  document.querySelectorAll('.type-group-checkbox').forEach(checkbox => {
    checkbox.checked = true;
  });
  
  // Send a new summary request without type group filters
  sendSummaryRequest();
  
  console.log("Filter cleared");
});

// Add event listener for the "Filter" button
document.getElementById('legend-filter-button').addEventListener('click', function() {
  // Get all checked groups
  const checkedGroups = [];
  
  // Find out which groups are checked
  for (const groupName in typeGroupCheckboxStates) {
    if (typeGroupCheckboxStates[groupName] !== false) {
      checkedGroups.push(groupName);
    }
  }
  
  console.log(`Checked groups: ${checkedGroups.join(', ')}`);
  
  // If only one group is checked, filter to show only that group
  if (checkedGroups.length === 1) {
    const groupName = checkedGroups[0];
    const groupId = typeGroupMapping[groupName];
    
    if (groupId !== undefined) {
      console.log(`Filtering by single type group: ${groupId}`);
      
      // Create a custom request with the typeGroups parameter
      const center = map.getCenter();
      const bounds = map.getBounds();
      const radius = center.distanceTo(bounds.getNorthEast()) * 1.5;
      const maxAge = parseInt(document.getElementById("age-slider").value, 10);
      
      const filterParams = {
        latitude: center.lat,
        longitude: center.lng,
        radius: radius,
        maxResults: 500,
        maxAge: maxAge,
        typeGroups: groupId.toString(),
        classes: getSelectedClasses()
      };
      
      // Add receiver filter if a receiver is selected
      if (selectedReceiverId) {
        filterParams.receiver = parseInt(selectedReceiverId, 10);
      }
      
      // Send the request directly WITHOUT stringifying
      console.log("Sending filter request with typeGroups:", filterParams);
      socket.emit("requestSummary", filterParams);
    }
  } else if (checkedGroups.length > 1) {
    // Multiple groups checked - show all of them
    const groupIds = [];
    for (const groupName of checkedGroups) {
      const groupId = typeGroupMapping[groupName];
      if (groupId !== undefined) {
        groupIds.push(groupId);
      }
    }
    
    if (groupIds.length > 0) {
      console.log(`Filtering by multiple type groups: ${groupIds.join(',')}`);
      
      // Create a custom request with the typeGroups parameter
      const center = map.getCenter();
      const bounds = map.getBounds();
      const radius = center.distanceTo(bounds.getNorthEast()) * 1.5;
      const maxAge = parseInt(document.getElementById("age-slider").value, 10);
      
      const filterParams = {
        latitude: center.lat,
        longitude: center.lng,
        radius: radius,
        maxResults: 500,
        maxAge: maxAge,
        typeGroups: groupIds.join(','),
        classes: getSelectedClasses()
      };
      
      // Add receiver filter if a receiver is selected
      if (selectedReceiverId) {
        filterParams.receiver = parseInt(selectedReceiverId, 10);
      }
      
      // Send the request directly WITHOUT stringifying
      console.log("Sending filter request with typeGroups:", filterParams);
      socket.emit("requestSummary", filterParams);
    }
  } else {
    // No groups checked - show all vessels (don't apply any type filtering)
    console.log("No groups checked - showing all vessels");
    
    // Create a custom request without any type filtering
    const center = map.getCenter();
    const bounds = map.getBounds();
    const radius = center.distanceTo(bounds.getNorthEast()) * 1.5;
    const maxAge = parseInt(document.getElementById("age-slider").value, 10);
    
    const filterParams = {
      latitude: center.lat,
      longitude: center.lng,
      radius: radius,
      maxResults: 500,
      maxAge: maxAge,
      classes: getSelectedClasses()
      // No typeGroups parameter - this will show all vessels
    };
    
    // Add receiver filter if a receiver is selected
    if (selectedReceiverId) {
      filterParams.receiver = parseInt(selectedReceiverId, 10);
    }
    
    // Add receiver filter if a receiver is selected
    if (selectedReceiverId) {
      filterParams.receiver = parseInt(selectedReceiverId, 10);
    }
    
    // Send the request directly WITHOUT stringifying
    console.log("Sending filter request without type filtering:", filterParams);
    socket.emit("requestSummary", filterParams);
  }
  
  console.log("Filters applied");
});



    document.getElementById('live-log-search').addEventListener('input', applyLogFilters);

const ageSlider = document.getElementById('age-slider');
const ageValueDisplay = document.getElementById('age-value');
let ageDebounceTimer = null;

const historySlider = document.getElementById('history-slider');
const historyValueDisplay = document.getElementById('history-value');
historySlider.addEventListener('input', () => {
  historyValueDisplay.textContent = historySlider.value;
});

document.addEventListener("DOMContentLoaded", function() {

  const savedBasemap = localStorage.getItem('selectedBasemap');

  if (savedBasemap) {
    // Remove any default layer if needed.
    // (Here googleSat is added as default; you might want to remove it if the saved layer is different.)
    if (savedBasemap === "OSM") {
      // Remove the default Google layer (if it's on the map)
      if (map.hasLayer(googleSat)) {
        map.removeLayer(googleSat);
      }
      // Add the OSM layer.
      osm.addTo(map);
    } else if (savedBasemap === "Google") {
      if (map.hasLayer(osm)) {
        map.removeLayer(osm);
      }
      googleSat.addTo(map);
    }
    if (map.hasLayer(openSeaMapLayer)) {
      openSeaMapLayer.bringToFront();
    }
  }

  // History slider elements
  const historySlider = document.getElementById("history-slider");
  const historyValueDisplay = document.getElementById("history-value");
  
  // Age slider elements
  const ageSlider = document.getElementById("age-slider");
  const ageValueDisplay = document.getElementById("age-value");
  
  // Load saved history slider value if available
  const savedHistory = localStorage.getItem("historySliderValue");
  if (savedHistory !== null) {
    historySlider.value = savedHistory;
    historyValueDisplay.textContent = savedHistory;
  }
  
  // Load saved age slider value if available
  const savedAge = localStorage.getItem("ageSliderValue");
  if (savedAge !== null) {
    ageSlider.value = savedAge;
    ageValueDisplay.textContent = savedAge;
  }
  
  // Save new history slider value on input
  historySlider.addEventListener("input", () => {
    const currentValue = historySlider.value;
    historyValueDisplay.textContent = currentValue;
    localStorage.setItem("historySliderValue", currentValue);
  });
  
  // Save new age slider value on input
  ageSlider.addEventListener("input", () => {
    const currentValue = ageSlider.value;
    ageValueDisplay.textContent = currentValue;
    localStorage.setItem("ageSliderValue", currentValue);
  });
});

let historyDebounceTimer = null;
document.getElementById("history-slider").addEventListener("input", () => {
  const historyHours = parseInt(document.getElementById("history-slider").value, 10);
  historyValueDisplay.textContent = historyHours;
  
  const now = Date.now();

  // Only redraw the focused vessel’s history
  if (focusedVessel && vesselData[focusedVessel].track) {
    // Remove its old path if present
    if (vesselTracks[focusedVessel]) {
      map.removeLayer(vesselTracks[focusedVessel]);
    }
    // Filter by new history window
    const filtered = vesselData[focusedVessel].track.filter(pt => {
      const t = new Date(pt[0]).getTime();
      return (now - t) <= historyHours * 3600000;
    });
    // Draw only the focused vessel’s track
    vesselTracks[focusedVessel] = createColoredTrack(filtered);
    map.addLayer(vesselTracks[focusedVessel]);
    attachPolylineEvents(vesselTracks[focusedVessel], focusedVessel);
  }

  // Debounce any backend history fetch (unchanged)
  clearTimeout(historyDebounceTimer);
  historyDebounceTimer = setTimeout(() => {
    if (focusedVessel) {
      hydrateTrackHistory(focusedVessel);
    }
  }, 500);
});


document.getElementById('modal-close').addEventListener('click', closeImageModal);
document.getElementById('image-modal-overlay').addEventListener('click', function(e) {
  // If the click is on the overlay (not the content), close the modal.
  if (e.target === this) {
    closeImageModal();
  }
});

document.getElementById("age-slider").addEventListener("input", () => {
  const ageHours = parseInt(ageSlider.value, 10);  // Get the value of the age slider in hours.
  ageValueDisplay.textContent = ageHours;  // Display the selected value.

  // Debounce the filtering process to avoid excessive function calls.
  clearTimeout(ageDebounceTimer);
  ageDebounceTimer = setTimeout(() => {
    // Process existing receiver markers based on the new age setting
    const now = Date.now();
    const maxAgeMilliseconds = ageHours * 3600000;
    
    for (const id in receiverData) {
      if (receiverData[id] && receiverData[id].LastUpdated) {
        try {
          const lastUpdated = new Date(receiverData[id].LastUpdated).getTime();
          if (!isNaN(lastUpdated)) {
            const isWithinAge = (now - lastUpdated) <= maxAgeMilliseconds;
            
            // If the receiver exists on the map
            if (receiverMarkers[id]) {
              if (!isWithinAge) {
                // Too old - remove from map
                map.removeLayer(receiverMarkers[id]);
              } else if (!map.hasLayer(receiverMarkers[id])) {
                // Within age but not on map - add it back
                map.addLayer(receiverMarkers[id]);
              }
            }
          }
        } catch (error) {
          console.error("Error processing receiver date for filtering:", error);
        }
      }
    }
    
    sendSummaryRequest();
    updateOverlay();  // Update the vessel overlay count
    refreshReceivers(); // Refresh receivers to apply the age filter
  }, 500);  // Adjust the debounce delay as needed.
});

map.on('zoomend', function() {
  const currentZoom = map.getZoom();
  for (const userid in vesselMarkers) {
    let marker = vesselMarkers[userid];
    // Focused vessel: update icon and tooltip based on the current zoom.
    if (userid === focusedVessel?.toString()) {
      // Always keep tooltip for focused vessel regardless of zoom level
      const tooltipContent = marker.getTooltip() ?
        marker.getTooltip().getContent() :
        vesselData[userid].Name;
      
      marker.bindTooltip(tooltipContent, {
        permanent: true,
        direction: 'top',
        className: 'vessel-tooltip'
      }).openTooltip();
      
      // Always use the detailed icon logic (which itself checks zoom level)
      marker.setIcon(getVesselIcon(vesselData[userid]));
    } else {
      // For non-focused vessels:
      if (currentZoom < 10) {
        // When zoom level is below 10, show simple circle markers and no tooltips.
        marker.unbindTooltip();
        marker.setIcon(createCircleIcon(vesselData[userid]));
      } else if (currentZoom < TOOLTIP_ZOOM_THRESHOLD) {
        // At zoom levels between 10 and 11.99, show the detailed icon but no tooltip.
        marker.unbindTooltip();
        marker.setIcon(getVesselIcon(vesselData[userid]));
      } else {
        // At zoom levels 12 and above, add tooltips and detailed icons.
        marker.bindTooltip(vesselData[userid].Name, {
          permanent: true,
          direction: 'top',
          className: 'vessel-tooltip'
        }).openTooltip();
        marker.setIcon(getVesselIcon(vesselData[userid]));
      }
    }
  }
});


const debouncedSendSummaryRequest = debounce(sendSummaryRequest, 250);
map.on("moveend", debouncedSendSummaryRequest);

        // Utility: Generate a random hex color.
        function randomColor() {
          return '#' + Math.floor(Math.random() * 16777215).toString(16).padStart(6, '0');
        }



    </script>
</body>

</html>
