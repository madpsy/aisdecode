<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>AIS Tracker</title>
    <!-- Leaflet CSS (from CDN, without integrity) -->
    <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.3/dist/leaflet.css" crossorigin="" />
    <style>
        html, body, #map {
          height: 100%;
          margin: 0;
          padding: 0;
        }
        .popup-content {
          font-family: Arial, sans-serif;
          font-size: 14px;
          line-height: 1.3;
        }
        .boat-icon {
          background: transparent;
          border: none;
          transition: transform 0.5s ease-out;
        }
	.leaflet-div-icon.non-vessel-icon {
	  width: 30px !important;
	  height: 30px !important;
	  padding: 0 !important;
	  margin: 0 !important;
	  text-align: center;
	  line-height: 30px;
	}
	#vessel-detail a {
	  text-decoration: none;
	}
	.port-marker-tooltip {
	  border: none;
	  box-shadow: none;
	  background: white;
	  padding: 2px 4px;
	  z-index: 1100;
	}	
        /* CSS for the enlargement animation */
        .boat-icon.enlarge {
          transform: scale(1.5);
        }
        .vessel-tooltip {
          font-family: Arial, sans-serif;
          font-size: 10px;
          font-weight: bold;
          background: rgba(255, 255, 255, 0.9);
          padding: 2px 4px;
          border: 1px solid #aaa;
          border-radius: 3px;
          cursor: pointer;
        }
        .receiver-tooltip {
          font-family: Arial, sans-serif;
          font-size: 10px;
          font-weight: bold;
          background: rgba(255, 255, 255, 0.9);
          padding: 2px 4px;
          border: 1px solid #aaa;
          border-radius: 3px;
          cursor: pointer;
        }
        /* Style for the Clear History button */
        #clear-history {
          position: absolute;
          bottom: 25px;
          left: 10px;
          background: yellow;
          border: none;
          padding: 5px 5px;
          cursor: pointer;
          font-weight: bold;
          z-index: 1000;
        }
        /* Style for the known vessels overlay (bottom left) */
        #vessel-overlay {
          position: absolute;
          bottom: 85px;
          left: 10px;
          background: rgba(255, 255, 255, 0.95);
          border: 1px solid #ccc;
          border-radius: 5px;
          padding: 5px;
          height: 300px;
          width: 150px;
          overflow-y: auto;
          z-index: 1000;
          font-family: Arial, sans-serif;
          font-size: 13px;
          line-height: 1.4;
        }
        #vessel-overlay h4 {
          margin: 5px 0;
          text-align: center;
          font-size: 14px;
        }
        /* Style for the filter input box */
        #vessel-filter {
          width: 90%;
          margin: 5px auto;
          display: block;
          padding: 3px;
          font-size: 13px;
        }
        #vessel-overlay .vessel-entry {
          border-bottom: 1px solid #eee;
          padding: 4px 0;
          cursor: pointer;
        }
        #vessel-overlay .vessel-entry:last-child {
          border-bottom: none;
        }
        #vessel-overlay .vessel-name {
          font-weight: bold;
          text-decoration: underline;
        }
        #vessel-overlay .vessel-callsign {
          color: #555;
        }
        #vessel-overlay .vessel-timestamp {
          color: #888;
          font-size: 12px;
        }
        /* New Style for the vessel detail overlay (bottom right) */
        #vessel-detail {
          position: absolute;
          bottom: 80px;
          right: 10px;
          background: rgba(255, 255, 255, 0.95);
          border: 1px solid #ccc;
          border-radius: 5px;
          padding: 5px;
          max-height: 300px;
          min-width: 200px;
	  max-width: 200px;
          width: auto;
          overflow-y: auto;
          z-index: 1500;
          font-family: Arial, sans-serif;
          font-size: 13px;
          line-height: 1.4;
          display: none;
          white-space: nowrap;
        }
        #vessel-detail h4 {
          margin: 5px 0;
          text-align: center;
          font-size: 14px;
        }
        /* Style for the controls overlay */
        #controls {
          position: absolute;
          top: 10px;
          right: 10px;
          background: rgba(255, 255, 255, 0.95);
          border: 1px solid #ccc;
          border-radius: 5px;
          padding: 10px;
          z-index: 1000;
          font-family: Arial, sans-serif;
          font-size: 14px;
        }
        #controls label {
          cursor: pointer;
          display: block;
          margin-bottom: 5px;
        }
        /* Styles for the new toggle buttons */
        .toggle-button {
          position: absolute;
          background: #f0f0f0;
          border: 1px solid #ccc;
          border-radius: 3px;
          padding: 3px 6px;
          font-family: Arial, sans-serif;
          font-size: 13px;
          cursor: pointer;
          z-index: 1100;
        }
        #toggle-known-overlay {
          bottom: 60px;
          left: 10px;
        }
        #toggle-detail-overlay {
          bottom: 50px;
          right: 10px;
          display: none;
        }
        /* Live Logs button styling (positioned to the left of Show/Hide Details) */
        #live-logs {
          position: absolute;
          bottom: 50px;
          right: 100px;
          background: #f0f0f0;
          border: 1px solid #ccc;
          border-radius: 3px;
          padding: 3px 6px;
          font-family: Arial, sans-serif;
          font-size: 13px;
          cursor: pointer;
          z-index: 1100;
          display: none;
        }
        /* Live Logs overlay styling */
        #live-logs-overlay {
          display: none;
          position: absolute;
          top: 100px;
          left: 50px;
          background: rgba(255,255,255,0.95);
          border: 1px solid #ccc;
          border-radius: 5px;
          padding: 10px;
          width: 290px;
          max-height: 400px;
          overflow-y: auto;
          z-index: 1200;
        }
        #live-logs-header {
          cursor: move;
          font-weight: bold;
          margin-bottom: 5px;
        }
        #live-logs-header button {
          float: right;
          cursor: pointer;
        }
        .log-entry {
          border-bottom: 1px solid #eee;
          padding: 5px 0;
          font-family: monospace;
          font-size: 12px;
        }
        .log-entry:last-child {
          border-bottom: none;
        }
        .log-field {
          font-weight: normal;
        }
        #stats-button {
          position: absolute;
          bottom: 50px;
          right: 175px;  /* Adjust as needed so it appears left of the "Messages" button */
          background: #f0f0f0;
          border: 1px solid #ccc;
          border-radius: 3px;
          padding: 3px 6px;
          font-family: Arial, sans-serif;
          font-size: 13px;
          cursor: pointer;
          z-index: 1100;
          display: none;  /* Hidden by default */
    }

#vessel-legend {
  font-family: Arial, sans-serif;
  font-size: 14px;
  padding: 5px;
  background-color: rgba(255, 255, 255, 0.95);
  border: 1px solid #ccc;
  border-radius: 5px;
  width: 150px;
  height: 200px;
  overflow-y: auto;
  z-index: 1000;
}

#vessel-legend .legend-item {
  display: flex;
  align-items: center;
  margin: 4px 0;  
  padding: 0;
  line-height: 1;
}

#vessel-legend .legend-item svg {
  margin-right: 5px; 
  width: 20px;   
  height: 20px;
}

#vessel-legend .legend-item span {
  flex: 1;
  font-size: 14px;
  line-height: 1;
}


#slider-container {
  position: absolute;
  bottom: 20px;  
  left: 50%;
  transform: translateX(-50%);
  background: rgba(255, 255, 255, 0.8);
  border-radius: 5px;
  padding: 0px;
  z-index: 1000;
  font-family: Arial, sans-serif;
  font-size: 12px;
  text-align: center;
}

#slider-container label {
  display: block;
  margin: 0 5px 0 0;
}

#slider-container input {
  width: 100%;
  margin: 0 10px 0 0;
}
#github-link {
  position: absolute;
  bottom: 5px; 
  left: 50%;
  transform: translateX(-50%);
  color: black;
  text-decoration: none;
  font-size: 12px;
  z-index: 1500;
}

.speed-scale-container {
  margin-bottom: 6px;
  padding: 0 5px;       
  font-family: Arial, sans-serif;
  font-size: 12px;
  line-height: 1;
}

.speed-scale-bar {
  height: 6px;
  border-radius: 3px;
  background: linear-gradient(
    to right,
    hsl(120,100%,50%) 0%,    /* green */
    hsl(60, 100%,50%) 50%,   /* yellow */
    hsl(0,  100%,50%) 100%   /* red */
  );
  margin-bottom: 2px;
}

.speed-scale-labels {
  display: flex;
  justify-content: space-between;
}

.speed-scale-labels span {
}

#latest-message-overlay {
  position: absolute;
  top: 50px;
  right: 50px;
  width: 300px;
  max-height: 400px;
  overflow: auto;
  background: rgba(255, 255, 255, 0.95);
  border: 1px solid #ccc;
  border-radius: 5px;
  padding: 10px;
  z-index: 2000;
  display: none;            /* hidden by default */
  box-shadow: 0 2px 8px rgba(0,0,0,0.3);
  font-family: monospace;
  font-size: 13px;
}
.latest-message-overlay .lm-header {
  display: flex;
  justify-content: space-between;
  align-items: center;
  margin-bottom: 8px;
}
.latest-message-overlay .lm-close {
  background: transparent;
  border: none;
  font-size: 16px;
  cursor: pointer;
}
.latest-message-overlay pre {
  background: #f7f7f7;
  padding: 5px;
  border-radius: 3px;
  overflow-x: auto;
}

#latest-message-overlay .lm-header {
  display: flex;
  justify-content: space-between;  /* push items to ends */
  align-items: center;
  margin-bottom: 8px;
  position: relative;              /* ensure children are positioned relative to this */
}

#latest-message-overlay .lm-close {
  background: transparent;
  border: none;
  font-size: 16px;
  cursor: pointer;
  padding: 0;
  margin: 0;
}

    </style>
</head>

<body>
    <div id="map"></div>
    <div id="latlong-display" style="
	    position: absolute;
	    top: 10px;
	    left: 50%;
	    transform: translateX(-50%);
	    background: rgba(255, 255, 255, 0.8);
	    padding: 5px 10px;
	    border-radius: 5px;
	    z-index: 1100;
	    font-family: Arial, sans-serif;
	    font-size: 14px;
	">
        0, 0
    </div>
    <div id="nm-scale" style="
    position: absolute;
    top: 40px;
    left: 50%;
    transform: translateX(-50%);
    background: rgba(255, 255, 255, 0.8);
    padding: 5px 10px;
    border-radius: 5px;
    z-index: 1100;
    font-family: Arial, sans-serif;
    font-size: 12px;
    text-align: center;
">
        <div id="scale-bar" style="
      position: relative;
      width: 100px;
      height: 4px;
      background: black;
      margin-bottom: 2px;
  ">
            <!-- Left tick -->
            <div style="
        position: absolute;
        left: 0;
        top: -4px;
        width: 2px;
        height: 12px;
        background: black;
    "></div>
            <!-- Right tick -->
            <div style="
        position: absolute;
        right: 0;
        top: -4px;
        width: 2px;
        height: 12px;
        background: black;
    "></div>
        </div>
        <div id="scale-label">0 NM</div>
    </div>

    <!-- Controls Overlay -->
    <div id="controls">
        <label>
  <div id="connection-status" style="display: flex; align-items: center; margin-bottom: 5px; margin-left: 5px;">
    <span id="status-dot" style="width: 10px; height: 10px; border-radius: 50%; background: red; display: inline-block; margin-right: 5px;"></span>
    <span id="status-text">Disconnected</span>
  </div>
        <label>
    <input type="checkbox" id="only-focussed">
    Only Tracked
  </label>
        <label>
    <input type="checkbox" id="openseamap-overlay" checked>
    Map Overlay
  </label>
  <label>
    <input type="checkbox" id="show-paths">
    History
  </label>
        <label>
    <input type="checkbox" id="stationary" checked>
    Stationary
  </label>
        <button id="toggle-legend" class="toggle-button" style="margin-top: 15px;">Show Legend</button>
    </div>

    <div id="vessel-legend" style="display: none; position: absolute; top: 200px; right: 5px; background: rgba(255, 255, 255, 0.9); border: 1px solid #ccc; border-radius: 5px; padding: 5px; z-index: 1000; font-family: Arial, sans-serif; font-size: 13px; max-height: 400px; overflow-y: auto; display: none;">
      <div class="speed-scale-container">
        <div class="speed-scale-bar"></div>
        <div class="speed-scale-labels">
          <span>0 kn</span>
          <span>40 kn</span>
        </div>
      </div>
        <div id="legend-content"></div>
    </div>

    <!-- Known vessels overlay (bottom left) -->
    <div id="vessel-overlay" style="display: none;">
        <!-- Filter input box -->
        <input type="text" id="vessel-filter" placeholder="Search...">
        <div id="vessel-count" style="text-align: left; margin-bottom: 0px;">Total: 0</div>
        <div id="overlay-content"></div>
    </div>

    <!-- Vessel detail overlay (bottom right) -->
    <div id="vessel-detail">
        <div id="vessel-detail-header">
	  <div id="vessel-header-text"></div>
	  <div id="vessel-header-image"></div>
	</div>
        <div id="detail-content"></div>
    </div>

    <div id="image-modal-overlay" style="display:none; position:fixed; top:0; left:0; width:100%; height:100%; background:rgba(0,0,0,0.8); z-index:1500; align-items:center; justify-content:center;">
      <div id="image-modal-content" style="position:relative;">
        <button id="modal-close" style="position:absolute; top:10px; right:10px; font-size:20px; background:transparent; border:none; color:white; cursor:pointer;">X</button>
        <img id="modal-image" src="" alt="Full-size Vessel Image" style="max-width:90vw; max-height:90vh; display:block; margin:0 auto;">
      </div>
    </div>

    <!-- Toggle Buttons -->
    <button id="toggle-known-overlay" class="toggle-button">Show Vessels</button>
    <button id="toggle-detail-overlay" class="toggle-button">Hide Details</button>

    <button id="stats-button">Watch</button>
    <button id="live-logs">Decodes</button>
    <button id="clear-history">Clear History</button>
    <div id="slider-container">
        <label for="history-slider">
  	    History: <span id="history-value">1</span> hrs
 	 </label>
        <input type="range" id="history-slider" min="1" max="24" value="1" step="1">
        <label for="age-slider">
	    Age: <span id="age-value">1</span> hrs
 	</label>
        <input type="range" id="age-slider" min="1" max="24" value="1" step="1">
    </div>
    <a href="https://github.com/madpsy/aisdecode" target="_blank" id="github-link">OpenSource @ GitHub</a>
    <!-- Live Logs Overlay (draggable) -->
    <div id="live-logs-overlay">
        <div id="live-logs-header">
            <span id="live-logs-title">Live Messages</span>
            <button id="close-live-logs">X</button>
        </div>
	<div id="live-logs-filters" style="padding: 2px; border-bottom: 1px solid #ccc; font-size: 12px;">
	  <label style="white-space: nowrap;">
	    <input type="checkbox" id="log-filter-all" checked> All
	  </label>
	  <label style="white-space: nowrap;">
	    <input type="checkbox" class="log-filter" value="1,2,3" checked> Position A
	  </label>
	  <label style="white-space: nowrap;">
	    <input type="checkbox" class="log-filter" value="18,19" checked> Position B
	  </label>
	  <label style="white-space: nowrap;">
	    <input type="checkbox" class="log-filter" value="5" checked> Static A
	  </label>
	  <label style="white-space: nowrap;">
	    <input type="checkbox" class="log-filter" value="24" checked> Static B
	  </label>
	  <label style="white-space: nowrap;">
	    <input type="checkbox" class="log-filter" value="21" checked> AtoN
	  </label>
	  <label style="white-space: nowrap;">
	    <input type="checkbox" class="log-filter" value="4" checked> Base Stn
	  </label>
	  <label style="white-space: nowrap;">
	    <input type="checkbox" class="log-filter" value="8,17,25,26" checked> Binary
	  </label>
	  <label style="white-space: nowrap;">
	    <input type="checkbox" class="log-filter" value="9" checked> SAR
	  </label>
	  <input type="text" id="live-log-search" placeholder="Search logs..." style="width:100%; margin-top:5px; padding:3px; font-size:12px;">
</div>

        <div id="live-logs-content"></div>
    </div>

    <!-- Socket.IO client (local copy) -->
    <script src="socket.io.min.js"></script>
    <!-- Leaflet JS (from CDN, without integrity) -->
    <script src="https://unpkg.com/leaflet@1.9.3/dist/leaflet.js" crossorigin=""></script>
    <script>
	 // Clear vessel data from localStorage immediately
	 localStorage.removeItem('vesselData');
        // Detect if the device is touch capable.
        const isMobile = ('ontouchstart' in window || navigator.maxTouchPoints > 0);

	const TOOLTIP_ZOOM_THRESHOLD = 12;

	let currentLoadedImageUrl = '';

	const vesselSolidTracks = {};
	const vesselColoredTracks = {};

        // Flag to track if the user manually hid the details overlay.
        let detailsOverlayHidden = false;
	let userLatLng = null;

	let messageTypeNames = {};

	fetch('/message_types.json')
	  .then(res => {
	    if (!res.ok) throw new Error(`Failed to load message types: ${res.status}`);
	    return res.json();
	  })
	  .then(json => {
	    messageTypeNames = json;
	  })
	  .catch(err => console.error(err));

	let mids = {};
	fetch('mids.json')
	  .then(response => {
	    if (!response.ok) {
	      throw new Error(`Network error: ${response.status}`);
	    }
	    return response.json();
	  })
	  .then(data => {
	    mids = data;
	  })
	  .catch(error => {
	    console.error('Error loading mids.json:', error);
	  });

        // Global variable to store the currently focused vessel (if any).
        let focusedVessel = null;

	const receiverData = {};    // Stores receiver info keyed by receiver ID.

	// Create the base layers
	const googleSat = L.tileLayer('https://{s}.google.com/vt/lyrs=s,h&x={x}&y={y}&z={z}', {
	  maxZoom: 20,
	  subdomains: ['mt0', 'mt1', 'mt2', 'mt3'],
	  attribution: '&copy; Google'
	});

	const osm = L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
	  attribution: '&copy; OpenStreetMap'
	});

	// Object to hold your base layers.
	const baseLayers = {
	  "Google": googleSat,
	  "OSM": osm
	};

	// Initialize the map with a default base layer
	const map = L.map('map').setView([55.0, -3.0], 5);
	osm.addTo(map);

	// Add the layers control.
	L.control.layers(baseLayers, null, { position: 'topleft' }).addTo(map);

	// Listen for the base layer change event.
	map.on('baselayerchange', function(e) {
	  // 'e.name' holds the key ("Google" or "OSM")
	  localStorage.setItem('selectedBasemap', e.name);
	  if (map.hasLayer(openSeaMapLayer)) {
	    openSeaMapLayer.bringToFront();
	  }
	});

        // OpenSeaMap overlay layer (enabled by default).
        const openSeaMapLayer = L.tileLayer('https://tiles.openseamap.org/seamark/{z}/{x}/{y}.png', {
          attribution: 'Map data: &copy; OpenSeaMap'
        }).addTo(map);
	openSeaMapLayer.bringToFront();

    const allowedMessageTypes = {
      "PositionReport": true,
      "ShipStaticData": true,
      "StaticDataReport": true,
      "StandardClassBPositionReport": true,
      "ExtendedClassBPositionReport": true,
      "AidsToNavigationReport": true,
      "BaseStationReport": true,
      "BinaryBroadcastMessage": true,
      "StandardSearchAndRescueAircraftReport": true
    };

	map.on('mousemove', function(e) {
	  if (!focusedVessel) {
	    document.getElementById('latlong-display').textContent =
	      `${e.latlng.lat.toFixed(5)}, ${e.latlng.lng.toFixed(5)}`;
	  }
	});

        // Helper function to clear all live logs and show a placeholder.
        function clearLiveLogs() {
          liveLogsContent.innerHTML = "<div class='placeholder' style='font-family: monospace; font-size: 12px; color: #888; text-align: center; padding: 10px;'>Waiting for next packet...</div>";
        }


map.on('click', () => {
  if (focusedVessel) {
    document.getElementById('show-paths').checked = false;
    const vessel = vesselData[focusedVessel];
    vesselMarkers[focusedVessel].getTooltip().setContent(vessel.Name);
    vesselMarkers[focusedVessel].setZIndexOffset(0);
    focusedVessel = null;
    unsubscribeInstantUpdates();

    // Hide detail overlay and all related buttons when no vessel is focused.
    document.getElementById('vessel-detail').style.display = 'none';
    document.getElementById('toggle-detail-overlay').style.display = 'none';
    document.getElementById('live-logs').style.display = 'none';
    document.getElementById('stats-button').style.display = 'none';

    clearLiveLogs();
    updateFocussedVisibility();
    updateStationaryMarkers();
  }
  sendSummaryRequest();
});

function sendSummaryRequest() {
  const onlyTracked = document.getElementById('only-focussed').checked;
  
  if (onlyTracked && focusedVessel) {
    const filterParams = {
    UserID: parseInt(focusedVessel, 10)  // Convert to integer
  };
    const jsonPayload = JSON.stringify(filterParams);
    //console.log("Emitting requestSummary (Only Tracked):", jsonPayload);
    socket.emit("requestSummary", jsonPayload);
    updateOverlay();
    return;
  }
  
  const center = map.getCenter();
  const bounds = map.getBounds();
  const radius = center.distanceTo(bounds.getNorthEast()) * 1.5;
  const ageSlider = document.getElementById("age-slider");
  const maxAge = parseInt(ageSlider.value, 10);
  
  const filterParams = {
    latitude: center.lat,
    longitude: center.lng,
    radius: radius,      // in meters
    maxResults: 500,     // fixed limit
    maxAge: maxAge,      // in hours
    updatePeriod: 2      // in seconds
  };

  if (!document.getElementById('stationary').checked) {
    filterParams.minSpeed = 1;
  }
  
  const jsonPayload = JSON.stringify(filterParams);
  //console.log("Emitting requestSummary:", jsonPayload);
  socket.emit("requestSummary", jsonPayload);
  updateOverlay();
}

        // Mapping objects for Nav Status, and Static Message Types.

        const navigationalStatusMapping = {
          0: "Using Engine",
          1: "At Anchor",
          2: "Not Under Command",
          3: "Restricted Manoeuvrability",
          4: "Constrained by Draft",
          5: "Moored",
          6: "Aground",
          7: "Engaged in Fishing",
          8: "Under Way Sailing",
          15: "Unknown"
        };

        const staticTypeMapping = {
          0: "Not available",
          1: "Reserved",
          2: "Reserved",
          3: "Reserved",
          4: "Reserved",
          5: "Reserved",
          6: "Reserved",
          7: "Reserved",
          8: "Reserved",
          9: "Reserved",
          10: "Reserved",
          11: "Reserved",
          12: "Reserved",
          13: "Reserved",
          14: "Reserved",
          15: "Reserved",
          16: "Reserved",
          17: "Reserved",
          18: "Reserved",
          19: "Reserved",
          20: "Wing in ground (WIG)",
          21: "Wing in ground (WIG)",
          22: "Wing in ground (WIG)",
          23: "Wing in ground (WIG)",
          24: "Wing in ground (WIG)",
          25: "Wing in ground (WIG)",
          26: "Wing in ground (WIG)",
          27: "Wing in ground (WIG)",
          28: "Wing in ground (WIG)",
          29: "Wing in ground (WIG)",
          30: "Fishing",
          31: "Towing",
          32: "Towing: length>200m, breadth>25m",
          33: "Dredging or underwater ops",
          34: "Diving ops",
          35: "Military ops",
          36: "Sailing",
          37: "Pleasure Craft",
          38: "Reserved",
          39: "Reserved",
          40: "High speed craft (HSC)",
          41: "High speed craft (HSC)",
          42: "High speed craft (HSC)",
          43: "High speed craft (HSC)",
          44: "High speed craft (HSC)",
          45: "High speed craft (HSC)",
          46: "High speed craft (HSC)",
          47: "High speed craft (HSC)",
          48: "High speed craft (HSC)",
          49: "High speed craft (HSC)",
          50: "Pilot Vessel",
          51: "Search and Rescue",
          52: "Tug",
          53: "Port Tender",
          54: "Anti-pollution equipment",
          55: "Law Enforcement",
          56: "Spare - Local Vessel",
          57: "Spare - Local Vessel",
          58: "Medical Transport",
          59: "Noncombatant ship",
          60: "Passenger",
          61: "Passenger",
          62: "Passenger",
          63: "Passenger",
          64: "Passenger",
          65: "Passenger",
          66: "Passenger",
          67: "Passenger",
          68: "Passenger",
          69: "Passenger",
          70: "Cargo",
          71: "Cargo",
          72: "Cargo",
          73: "Cargo",
          74: "Cargo",
          75: "Cargo",
          76: "Cargo",
          77: "Cargo",
          78: "Cargo",
          79: "Cargo",
          80: "Tanker",
          81: "Tanker",
          82: "Tanker",
          83: "Tanker",
          84: "Tanker",
          85: "Tanker",
          86: "Tanker",
          87: "Tanker",
          88: "Tanker",
          89: "Tanker",
          90: "Other Type",
          91: "Other Type",
          92: "Other Type",
          93: "Other Type",
          94: "Other Type",
          95: "Other Type",
          96: "Other Type",
          97: "Other Type",
          98: "Other Type",
          99: "Other Type"
        };

	const staticAtoNTypeMapping = {
	  0:  "Default, Type of AtoN not specified",
	  1:  "Reference point",
	  2:  "RACON",
	  3:  "Fixed structures off-shore",
	  4:  "Emergency Wreck Marking Buoy",
	  5:  "Light, without sectors",
	  6:  "Light, with sectors",
	  7:  "Leading Light Front",
	  8:  "Leading Light Rear",
	  9:  "Beacon, Cardinal N",
	  10: "Beacon, Cardinal E",
	  11: "Beacon, Cardinal S",
	  12: "Beacon, Cardinal W",
	  13: "Beacon, Port hand",
	  14: "Beacon, Starboard hand",
	  15: "Beacon, Preferred Channel port hand",
	  16: "Beacon, Preferred Channel starboard hand",
	  17: "Beacon, Isolated danger",
	  18: "Beacon, Safe water",
	  19: "Beacon, Special mark",
	  20: "Cardinal Mark N",
	  21: "Cardinal Mark E",
	  22: "Cardinal Mark S",
	  23: "Cardinal Mark W",
	  24: "Port hand Mark",
	  25: "Starboard hand Mark",
	  26: "Preferred Channel Port hand",
	  27: "Preferred Channel Starboard hand",
	  28: "Isolated danger",
	  29: "Safe Water",
	  30: "Special Mark",
	  31: "Light Vessel/LANBY/Rigs"
	};


const vesselColorPalette = [
  "#FF4500", // Orange Red
  "#00CED1", // Dark Turquoise
  "#F58231", // Vibrant Orange
  "#FF00FF", // Fuchsia
  "#FF69B4", // Hot Pink
  "#FF8C00", // Dark Orange
  "#8A2BE2", // Blue Violet
  "#0082C8", // Vibrant Blue
  "#FF1493", // Deep Pink
  "#E6194B", // Vibrant Red
  "#46F0F0", // Vibrant Cyan
  "#00BFFF", // Deep Sky Blue
  "#00FF00", // Lime
  "#F032E6", // Vibrant Magenta
  "#FFD700", // Gold
  "#FF6347", // Tomato
  "#DC143C", // Crimson
  "#FFE119", // Vibrant Yellow
  "#40E0D0", // Turquoise
  "#DA70D6", // Orchid
  "#911EB4", // Vibrant Purple
  "#FF7F50", // Coral
  "#3CB44B"  // Vibrant Green
];

const friendlyMessageTypes = {
  "PositionReport": "Position (A)",
  "ShipStaticData": "Static (A)",
  "StaticDataReport": "Static (B)",
  "StandardClassBPositionReport": "Position (B std)",
  "ExtendedClassBPositionReport": "Position (B ext)",
  "AidsToNavigationReport": "AtoN",
  "BaseStationReport": "Base Station",
  "BinaryBroadcastMessage": "Binary Broadcast",
  "StandardSearchAndRescueAircraftReport": "SAR"
};

function djb2Hash(str) {
  let hash = 8393;
  for (let i = 0; i < str.length; i++) {
    hash = ((hash << 5) + hash) + str.charCodeAt(i); // hash * 33 + c
  }
  return hash >>> 0; // Ensure a positive integer
}

function hashStringToIndex(description, modulo) {
  return djb2Hash(description) % modulo;
}

// Change receiverMarkers from an array to an object.
let receiverMarkers = {};

function refreshReceivers() {
  fetch('/receivers')
    .then(response => {
      if (!response.ok) {
        throw new Error(`Network error: ${response.status}`);
      }
      return response.json();
    })
    .then(receivers => {
      const currentReceiverIDs = new Set();

      if (Array.isArray(receivers) && receivers.length > 0) {
        receivers.forEach(receiver => {
          const id = String(receiver.id);
          currentReceiverIDs.add(id);

          const lat = parseFloat(receiver.latitude);
          const lng = parseFloat(receiver.longitude);

          if (isNaN(lat) || isNaN(lng)) {
            console.warn("Invalid coordinates for receiver id", id);
            return;
          }

          // Create or update the receiver marker.
          if (receiverMarkers[id]) {
		  // Update marker position.
		  receiverMarkers[id].setLatLng([lat, lng]);
		  const updatedLocalTime = new Date(receiver.LastUpdated).toLocaleString();
	    	  let linksHTML = "";
	    	  if (receiver.url && receiver.url.trim() !== "") {
	    	    linksHTML += `<a href="${receiver.url}" target="_blank">Website</a>`;
	    	  }
	    	  if (receiver.metrics) {
	    	    if (linksHTML !== "") {
	    	      linksHTML += " | ";
	    	    }
	    	    linksHTML += `<a href="/metrics.html?id=${id}" target="_blank">Metrics</a>`;
	    	  }
	    	  if (receiver.state) {
	    	    if (linksHTML !== "") {
	    	      linksHTML += " | ";
	    	    }
	    	    linksHTML += `<a href="/coverage.html?id=${id}" target="_blank">Coverage</a>`;
	    	  }
		  const popupContent = `
		    <strong>${receiver.name}</strong><br>
		    ${receiver.description}<br>
		    Updated: ${updatedLocalTime}<br>
		    ${linksHTML}
		  `;
		  // Update the popup content.
		  receiverMarkers[id].setPopupContent(popupContent);
          } else {
            const marker = L.marker([lat, lng], { icon: createReceiverIcon() }).addTo(map);
            const updatedLocalTime = new Date(receiver.lastupdated).toLocaleString();
            let linksHTML = "";
	    if (receiver.url && receiver.url.trim() !== "") {
	      linksHTML += `<a href="${receiver.url}" target="_blank">Website</a>`;
	    }
	    if (receiver.metrics) {
	      // Add separator if needed.
	      if (linksHTML !== "") {
	        linksHTML += " | ";
	      }
	      linksHTML += `<a href="/metrics.html?id=${id}" target="_blank">Metrics</a>`;
	    }
	    if (receiver.state) {
	      if (linksHTML !== "") {
	        linksHTML += " | ";
	      }
	      linksHTML += `<a href="/coverage.html?id=${id}" target="_blank">Coverage</a>`;
	    }
            const popupContent = `
              <strong>${receiver.name}</strong><br>
              ${receiver.description}<br>
              Updated: ${updatedLocalTime}<br>
              ${linksHTML}
            `;
            marker.bindPopup(popupContent, { autoPan: true });

            // Bind tooltip showing a label for a receiver.
            marker.bindTooltip(`${receiver.name} (RX)`, {
              permanent: true,
              interactive: true,
              direction: 'top',
              className: 'receiver-tooltip'
            }).openTooltip();

            receiverMarkers[id] = marker;
          }

          // Store receiver info with an extra flag.
          receiverData[id] = {
            Name: receiver.name,
            LastUpdated: receiver.LastUpdated,
            UserID: id,
            isReceiver: true,
            // You can store other properties (url, description, etc.) if needed.
            url: receiver.url,
            description: receiver.description
          };
        });
      } else {
        console.warn("No receivers found.");
      }

      // Remove stale markers/data.
      for (const id in receiverMarkers) {
        if (!currentReceiverIDs.has(id)) {
          map.removeLayer(receiverMarkers[id]);
          delete receiverMarkers[id];
          delete receiverData[id];
        }
      }
    })
    .catch(error => {
      console.error('Error fetching receivers:', error);
    });
}

function getColorForVesselTypeConsistent(type) {
  if (!type) return "blue";
  const description = staticTypeMapping[type] || type;
  const index = hashStringToIndex(description, vesselColorPalette.length);
  return vesselColorPalette[index];
}

// Create a custom boat icon using your existing SVG, but with the stroke and fill set to the vessel type's color.
function createBoatIcon(type, heading = 0, fillOpacity = 0.5) {
  const color = getColorForVesselTypeConsistent(type);
  const svgHtml = `
    <svg width="20" height="50" viewBox="0 0 20 50"
         style="transform: rotate(${heading}deg); transform-origin: center;">
      <path
        d="M5 45 L15 45 L15 30 Q10 5,5 30 Z"
        stroke="${color}"
        stroke-width="2"
        fill="${color}"
        fill-opacity="${fillOpacity}"
      />
    </svg>
  `;
  return L.divIcon({
    html: svgHtml,
    className: 'boat-icon',
    iconSize: [20, 50],
    iconAnchor: [10, 25],
    popupAnchor: [0, -25],
  });
}

function getCustomIcon(vesselState, iconUrl) {
  // Determine the heading as before
  const heading = (typeof vesselState.TrueHeading === 'number' && vesselState.TrueHeading < 360)
      ? vesselState.TrueHeading
      : (typeof vesselState.Cog === 'number' && vesselState.Cog >= 0 && vesselState.Cog < 360)
        ? vesselState.Cog
        : 0;
  
  return L.divIcon({
    html: `<div class="non-vessel-icon-image" style="
              width: 30px;
              height: 30px;
              background-image: url('${iconUrl}');
              background-size: contain;
              background-repeat: no-repeat;
              transform: rotate(${heading}deg);
            "></div>`,
    className: 'non-vessel-icon', // still used for container styling if needed
    iconSize: [30, 30],
    iconAnchor: [15, 15], // center of the 30x30 div
    popupAnchor: [0, -15]
  });
}


function getVesselIcon(vesselState) {
  // For lower zoom levels, show a simple circle marker.
  if (map.getZoom() < 10) {
    return createCircleIcon(vesselState);
  }
  
  // Check the AISClass value for special cases.
  if (vesselState.AISClass) {
    const aisClass = vesselState.AISClass.trim();
    if (aisClass === "AtoN") {
      return getCustomIcon(vesselState, 'images/aids-to-navigation.png');
    } else if (aisClass === "BASE") {
      return getCustomIcon(vesselState, 'images/base-station.png');
    } else if (aisClass === "SAR") {
      return getCustomIcon(vesselState, 'images/sar-aircraft.png');
    }
  }
  
  // Default: compute the vessel's heading and create a boat icon.
  const heading = (typeof vesselState.TrueHeading === 'number' && vesselState.TrueHeading < 360)
                    ? vesselState.TrueHeading
                    : (typeof vesselState.Cog === 'number' && vesselState.Cog >= 0 && vesselState.Cog < 360)
                      ? vesselState.Cog
                      : 0;
  return createBoatIcon(vesselState.Type, heading);
}

function attachImageClick(imgElem) {
  imgElem.addEventListener('click', function(e) {
    e.stopPropagation(); // Prevent the click from bubbling up if needed.
    openImageModal(this.src);
  });
}

// Preload the vessel image before inserting it into the container.
function loadVesselImage(url, container) {
  url = url.trim();
  // Create the image element.
  const img = document.createElement('img');
  img.id = 'vessel-image';
  img.style.maxWidth = '100%';
  img.style.margin = '5px 0';
  img.style.height = 'auto';
  img.style.cursor = 'pointer';
  img.alt = 'Vessel Image';

  // Attach the click event immediately.
  img.addEventListener('click', function(e) {
    e.stopPropagation();
    // Use the current src of the image when clicked.
    openImageModal(img.src);
  });

  // When the image loads, append it to the container.
  img.onload = function() {
    // Remove any previously appended image with the same id.
    const existingImg = container.querySelector('#vessel-image');
    if (existingImg) {
      existingImg.remove();
    }
    container.appendChild(img);
  };

  // Handle loading errors.
  img.onerror = function() {
    console.error("Image failed to load:", url);
    // Optionally, retry loading after a delay or show a fallback image.
  };

  // Set the image source (this starts the asynchronous load).
  img.src = url;
}

function updateVesselDetailHeader(UserID) {
  const textContainer = document.getElementById('vessel-header-text');

  // Build header HTML: Name, Lookup, Link
  let headerHtml = `
    <h4 style="margin:0;padding:0;">
      <span style="font-size:1.2em;">${vesselData[UserID].Name}</span><br>
      <a href="https://www.vesselfinder.com/vessels/details/${vesselData[UserID].UserID}"
         target="_blank">Lookup</a>
      |
      <span id="copy-link" style="cursor:pointer; color:blue;">Link</span>
  `;

  // Add Messages popup link if DecodedBinary exists
  if (vesselData[UserID].DecodedBinary) {
    headerHtml += `
      |
      <span id="show-binary-messages" style="cursor:pointer; color:blue;">
        Messages
      </span>
    `;
  }

  headerHtml += `</h4>`;
  textContainer.innerHTML = headerHtml;


  // --- now restore the image logic ---
  const imageContainer = document.getElementById('vessel-header-image');
  if (vesselData[UserID].ImageURL) {
    // only reload if the URL changed (optional optimization)
    loadVesselImage(vesselData[UserID].ImageURL, imageContainer);
  } else {
    imageContainer.innerHTML = '';
  }

  // Attach copy-link behavior
  const copyLinkEl = document.getElementById('copy-link');
  if (copyLinkEl) {
    copyLinkEl.onclick = (e) => {
      e.stopPropagation();
      const currentUrl = `${window.location.origin}${window.location.pathname}?UserID=${UserID}`;
      navigator.clipboard.writeText(currentUrl).then(() => {
        copyLinkEl.textContent = 'Link Copied';
        setTimeout(() => { copyLinkEl.textContent = 'Link'; }, 2000);
      });
    };
  }

  // Attach Messages popup behavior
  const msgBtn = document.getElementById('show-binary-messages');
  if (msgBtn) {
    msgBtn.onclick = (e) => {
      e.stopPropagation();
      window.open(
        `/binarymessages.html?UserID=${UserID}`,
        '_blank',
        'width=500,height=600'
      );
    };
  }
}

function updateLatLongDisplay() {
  const latlongDisplay = document.getElementById('latlong-display');
  if (focusedVessel && vesselData[focusedVessel]) {
    const lat = vesselData[focusedVessel].Latitude;
    const lon = vesselData[focusedVessel].Longitude;
    if (typeof lat === 'number' && typeof lon === 'number') {
      latlongDisplay.innerHTML = `<strong>${lat.toFixed(5)}, ${lon.toFixed(5)}</strong>`;
    }
  }
}

function debounce(func, wait) {
  let timeout;
  return function(...args) {
    const context = this;
    clearTimeout(timeout);
    timeout = setTimeout(() => {
      func.apply(context, args);
    }, wait);
  };
}

const debouncedAdjustMapBounds = debounce(adjustMapBounds, 500);


// Function to open the modal with the clicked image
function openImageModal(imageSrc) {
  const modalOverlay = document.getElementById('image-modal-overlay');
  const modalImage = document.getElementById('modal-image');
  modalImage.src = imageSrc;
  modalOverlay.style.display = 'flex';
}

// Function to close the modal
function closeImageModal() {
  const modalOverlay = document.getElementById('image-modal-overlay');
  modalOverlay.style.display = 'none';
}

// Attach click listener to the vessel image when vessel details are shown.
function attachImageClick() {
  const vesselImage = document.getElementById('vessel-image');
  if (vesselImage) {
    vesselImage.addEventListener('click', function(e) {
      e.stopPropagation();
      openImageModal(this.src);
    });
  }
}

function clearHistory() {
  localStorage.removeItem('vesselData');
  Object.keys(vesselMarkers).forEach(UserID => {
    map.removeLayer(vesselMarkers[UserID]);
  });
  Object.keys(vesselTracks).forEach(UserID => {
    map.removeLayer(vesselTracks[UserID]);
  });
  Object.keys(vesselData).forEach(key => delete vesselData[key]);
  Object.keys(vesselMarkers).forEach(key => delete vesselMarkers[key]);
  Object.keys(vesselTracks).forEach(key => delete vesselTracks[key]);
  updateOverlay();
  location.reload();
}

function attachPolylineEvents(layerGroup, UserID) {
  // Iterate over each polyline in the layer group.
  layerGroup.eachLayer(function(polylineSegment) {
    polylineSegment.on('mousemove', function(e) {
      const nearest = getNearestTrackPoint(e, vesselData[UserID].track);
      if (nearest) {
        const [timestamp, lat, lon, sog, cog, trueHeading] = nearest.info;
        const localTime = new Date(timestamp).toLocaleString();
        const vessel = vesselData[UserID];
        const name = vessel.Name || "Unknown Vessel";
        const callsign = vessel.CallSign || "N/A";
        
        let popupContent = `<strong>${name} (${callsign})</strong><br>
                            ${localTime}<br>
                            ${lat.toFixed(5)}, ${lon.toFixed(5)}<br>`;
        if (sog !== null) {
          popupContent += `Speed: ${sog} kn<br>`;
        }
        if (cog !== null) {
          popupContent += `Course: ${cog}°<br>`;
        }
        if (trueHeading !== null) {
          popupContent += `Heading: ${trueHeading}°<br>`;
        }
        
        L.popup({ closeButton: false, autoPan: false })
          .setLatLng(nearest.ptLatLng)
          .setContent(popupContent)
          .openOn(map);
      }
    });
    polylineSegment.on('mouseout', function() {
      map.closePopup();
    });
  });
}

function updateLegend() {

  const legend = document.getElementById('vessel-legend');
  const currentDisplay = window.getComputedStyle(legend).display;
  
  if (currentDisplay === 'none') {
    return; // If the legend is hidden, don't update it
  }

  // Get the top 5 vessel types
  const vesselTypes = {};

  // Loop through the vessel data to gather vessel types
  for (const UserID in vesselData) {
    const vessel = vesselData[UserID];
    if (vessel.Type) {
      const typeDescription = staticTypeMapping[vessel.Type] || vessel.Type;
      const typeColor = getColorForVesselTypeConsistent(vessel.Type);

      if (!vesselTypes[typeDescription]) {
        vesselTypes[typeDescription] = {
          count: 0,
          color: typeColor,
        };
      }
      vesselTypes[typeDescription].count += 1;
    }
  }

  // Get the top 5 types based on count
  const topTypes = Object.keys(vesselTypes)
    .sort((a, b) => vesselTypes[b].count - vesselTypes[a].count);

  let legendContent = '';
  topTypes.forEach(type => {
    const count = vesselTypes[type].count;
    const color = vesselTypes[type].color;

    legendContent += `
      <div class="legend-item">
        <svg width="20" height="50" viewBox="0 0 20 50" style="transform: rotate(0deg); transform-origin: center;">
          <path d="M5 45 L15 45 L15 30 Q10 5,5 30 Z" stroke="${color}" fill="${color}" stroke-width="2" />
        </svg>
        <span>${type} (${count})</span>
      </div>
    `;
  });

  // Update the legend content
  document.getElementById('legend-content').innerHTML = legendContent;

  // Display the legend
  document.getElementById('vessel-legend').style.display = 'block';
}

function getColorForSpeed(speed) {
  const maxSpeed = 40;  // maximum expected speed in knots
  // Clamp the speed value between 0 and maxSpeed
  const clampedSpeed = Math.max(0, Math.min(maxSpeed, speed));
  // Compute a ratio (0 = 0 knots, 1 = maxSpeed)
  const ratio = clampedSpeed / maxSpeed;
  // Calculate hue: 120 (green) at 0 knots to 0 (red) at 20 knots.
  // Here, a higher ratio gives a lower hue value.
  const hue = (1 - ratio) * 120;
  // Return a string with full saturation and 50% lightness.
  return `hsl(${hue}, 100%, 50%)`;
}


function createColoredTrack(track) {
  const segments = [];
  // Loop through the track segments
  for (let i = 0; i < track.length - 1; i++) {
    const pt1 = track[i];
    const pt2 = track[i + 1];
    // Use the speed of the first point (or average of pt1 and pt2) for the color
    const speed = (pt1[3] != null ? pt1[3] : 0);
    const color = getColorForSpeed(speed);
    // Create a polyline segment with this color
    const segment = L.polyline([[pt1[1], pt1[2]], [pt2[1], pt2[2]]], {
      color: color,
      weight: 3,
      opacity: 0.8
    });
    segments.push(segment);
  }
  // Group the segments so you can treat them as one layer
  return L.layerGroup(segments);
}

function updateFocusedVesselTrack(UserID) {
  if (focusedVessel === UserID && vesselData[UserID] && vesselData[UserID].track) {
    if (vesselColoredTracks[UserID]) {
      map.removeLayer(vesselColoredTracks[UserID]);
    }
    const newColoredTrack = createColoredTrack(vesselData[UserID].track);
    vesselColoredTracks[UserID] = newColoredTrack;
    map.addLayer(newColoredTrack);
  }
}

function createReceiverIcon() {
  const svgHtml = `
    <svg style="pointer-events: none;" width="20" height="20" viewBox="0 0 20 20">
      <circle cx="10" cy="10" r="10" fill="red" />
    </svg>
  `;
  return L.divIcon({
    html: svgHtml,
    className: '',
    iconSize: [20, 20],
    iconAnchor: [10, 10]
  });
}

function hydrateTrackHistory(UserID) {
  const historySlider = document.getElementById('history-slider');
  const maxHistory = historySlider.value;
  fetch(`/history/${UserID}?maxAge=${maxHistory}&format=csv`)
    .then(response => {
      if (!response.ok) {
        throw new Error(`History fetch failed with status: ${response.status}`);
      }
      return response.text();
    })
    .then(csvData => {
      // Parse the CSV formatted history into an array of points.
      // Each point is an array: [timestamp, latitude, longitude, sog, cog, trueHeading]
      const newPoints = csvData.trim().split('\n').map(line => {
        const parts = line.split(',');
        const lat = parseFloat(parts[1]);
        const lon = parseFloat(parts[2]);
        // Only return the point if both lat and lon are valid numbers.
        if (isNaN(lat) || isNaN(lon)) {
          return null;
        }
        // Parse extra fields; if empty, use null.
        const sog = parts[3] && parts[3].trim() !== "" ? parseFloat(parts[3]) : null;
        const cog = parts[4] && parts[4].trim() !== "" ? parseFloat(parts[4]) : null;
        const trueHeading = parts[5] && parts[5].trim() !== "" ? parseFloat(parts[5]) : null;
        return [parts[0], lat, lon, sog, cog, trueHeading];
      }).filter(point => point !== null);

      // Retrieve the current track history (or start with an empty array).
      const currentTrack = vesselData[UserID].track || [];
      
      // Merge the current track with the new points.
      const mergedTrack = currentTrack.concat(newPoints);
      
      // Sort the merged track by time (assuming the timestamp is ISO formatted).
      mergedTrack.sort((a, b) => new Date(a[0]) - new Date(b[0]));

      // Remove duplicate entries.
      // Two points are considered duplicates if they have identical timestamp, latitude, and longitude.
      const dedupedTrack = [];
      mergedTrack.forEach(point => {
        if (
          dedupedTrack.length === 0 ||
          dedupedTrack[dedupedTrack.length - 1][0] !== point[0] ||
          dedupedTrack[dedupedTrack.length - 1][1] !== point[1] ||
          dedupedTrack[dedupedTrack.length - 1][2] !== point[2]
        ) {
          dedupedTrack.push(point);
        }
      });

      // Update the vessel's track history in your data store.
      vesselData[UserID].track = dedupedTrack;
      
      // Immediately apply the history filter based on the current slider value.
      const now = Date.now();
      const historyHours = parseInt(document.getElementById("history-slider").value, 10);
      const filteredTrack = dedupedTrack.filter(pt => {
        const pointTime = new Date(pt[0]).getTime();
        return (now - pointTime) <= historyHours * 3600000;
      });
      
      // --- Update the polyline on the map using speed-based colors ---
      // Remove any existing track for this vessel.
      if (vesselTracks[UserID]) {
        map.removeLayer(vesselTracks[UserID]);
      }
      // Use createColoredTrack() to generate the new colored track layer.
      vesselTracks[UserID] = createColoredTrack(filteredTrack);
      map.addLayer(vesselTracks[UserID]);
      // Reattach events (e.g., mousemove and mouseout) to the new polyline segments.
      attachPolylineEvents(vesselTracks[UserID], UserID);
      
      // Force re-addition of the polyline in case update functions have removed it.
      if (!map.hasLayer(vesselTracks[UserID])) {
        map.addLayer(vesselTracks[UserID]);
      }
      
      // Save the updated vessel data back into localStorage.
      localStorage.setItem('vesselData', JSON.stringify(vesselData));
      
      // Now update the UI after CSV processing is complete.
      updateOverlay();
    })
    .catch(error => {
      console.error('Error hydrating track history:', error);
      // Optionally, you can call your update functions on error
      updateOverlay();
    });
}

        // Global objects to store markers, vessel data, and track histories.
        const vesselMarkers = {};
        const vesselData = {};   // keyed by UserID/UserID
        const vesselTracks = {}; // keyed by UserID/UserID

        /**
         * Decode the AIS communication state.
         */
        function decodeCommunicationState(state) {
          const intState = Number(state);
          const syncState = intState >> 17;
          const slotTimeout = (intState >> 14) & 0x07;
          const slotOffset = intState & 0x3FFF;
          return { syncState, slotTimeout, slotOffset };
        }

// Global variable to store current port data
let currentPorts = [];

let focussedID = null;

// Create a layer group for port markers
const portLayerGroup = L.layerGroup().addTo(map);

// Create a custom invisible icon
const invisibleIcon = L.divIcon({
  className: 'invisible-icon',
  html: '', // Empty HTML content for an invisible icon
  iconSize: [0, 0]  // No size for the marker
});

// Create and add port markers with tooltips to the portLayerGroup
function addPortMarkers(ports) {
  // Compare new ports with the current ones (using JSON stringify for a basic deep comparison)
  // Depending on your data structure, you may want a more robust comparison.
  if (JSON.stringify(ports) === JSON.stringify(currentPorts)) {
    // If the data is the same, do nothing.
    return;
  }
  
  // Update the current ports cache
  currentPorts = ports;

  // Clear existing port markers
  portLayerGroup.clearLayers();

  ports.forEach(port => {
    const { CITY, LATITUDE, LONGITUDE } = port;

    // Create the marker with the invisible icon
    const portMarker = L.marker([LATITUDE, LONGITUDE], { icon: invisibleIcon });

    const tooltipContent = `<img src="/images/port.png" style="width: 16px; height: 16px; vertical-align: middle; margin-right: 4px;" />${CITY}`;
    portMarker.bindTooltip(tooltipContent, { permanent: true, direction: 'top', className: 'port-marker-tooltip' });

    // Add the marker to the portLayerGroup
    portMarker.addTo(portLayerGroup);
  });
}

let debounceTimeout;

function selectVesselById(UserID) {
  // Check if a marker already exists for the vessel.
  if (!vesselMarkers[UserID]) {
    // If the marker does not exist, fetch the vessel state.
    fetch(`/state/${UserID}`)
      .then(response => {
        if (!response.ok) {
          throw new Error(`Request failed with status ${response.status}`);
        }
        return response.json();
      })
      .then(stateData => {
        // Ensure that the state has valid position data.
        if (typeof stateData.Latitude === "number" && typeof stateData.Longitude === "number") {
          // Update or add the vessel to your global state.
          vesselData[UserID] = stateData;
	  if (!vesselData[UserID].track) {
  		vesselData[UserID].track = [];
	  }
	  if (!vesselData[UserID].color) {
            vesselData[UserID].color = randomColor();
          }
          // Create a marker using your existing function (e.g., getVesselIcon).
          let marker = L.marker(
            [stateData.Latitude, stateData.Longitude],
            { icon: getVesselIcon(stateData) }
          ).addTo(map);
          vesselMarkers[UserID] = marker;

          // Optionally, bind popups or tooltips.
          marker.bindPopup(createPopupContent(stateData), { autoPan: false });

          // Focus on the vessel (recenter, highlight, etc.)
          focusOnVessel(UserID);

        } else {
          console.error("Invalid location data received for vessel:", UserID);
        }
      })
      .catch(error => {
        console.error("Error fetching vessel state:", error);
      });
  } else {
    // If the marker already exists, update its position.
    fetch(`/state/${UserID}`)
      .then(response => response.json())
      .then(stateData => {
        // Update global state and marker position.
        vesselData[UserID] = stateData;
	if (!vesselData[UserID].track) {
  	   vesselData[UserID].track = [];
	}
        if (!vesselData[UserID].color) {
          vesselData[UserID].color = randomColor();
       }
        vesselMarkers[UserID].setLatLng([stateData.Latitude, stateData.Longitude]);
        vesselMarkers[UserID].getPopup().setContent(createPopupContent(stateData));

        focusOnVessel(UserID);
        hydrateTrackHistory(UserID);
      })
      .catch(error => {
        console.error("Error updating vessel state for marker:", error);
      });
  }
}

function renderSearchResults(data) {
  // Convert the response object to an array.
  if (!Array.isArray(data)) {
    data = Object.values(data);
  }
  
  let content = "";
  data.forEach(entry => {
    const name = entry.Name;
    const lastSeen = timeAgo(new Date(entry.LastUpdated || Date.now()).getTime());
    const numMessages = entry.NumMessages || 0;
  
    // Use extra info if the entry represents a receiver.
    const extraInfo = entry.isReceiver
      ? `<div class="vessel-callsign">Receiver</div>`
      : `<div class="vessel-callsign">Call Sign: ${entry.CallSign ? entry.CallSign : "N/A"}</div>`;
  
    content += `<div class="vessel-entry" data-userid="${entry.UserID}">
                  <div class="vessel-name">${name}</div>
                  ${extraInfo}
                  <div class="vessel-timestamp">${lastSeen} | ${numMessages} msgs</div>
                </div>`;
  });
  
  document.getElementById('overlay-content').innerHTML = content;
  
  // Update the count to reflect search results.
  document.getElementById('vessel-count').innerHTML =
    `${data.length} of ${data.length} entries`; // or customize based on your needs
  
  // Attach click event listeners for each overlay entry.
  document.querySelectorAll('.vessel-entry').forEach(entry => {
    entry.addEventListener('click', event => {
      event.stopPropagation();
      const UserID = entry.getAttribute('data-userid');
      if (receiverData.hasOwnProperty(UserID)) {
        const marker = receiverMarkers[UserID];
        map.setView(marker.getLatLng(), 10);
        marker.openPopup();
      } else {
        selectVesselById(UserID);
      }
    });
  });
}



        /**
         * Build popup content from vessel data.
         */
function createPopupContent(data) {
  const lines = [];
  // Top line: Always show name, callsign, and class.
  let name = data.Name ? data.Name : "Unknown Vessel";
  if (data.CallSign) {
    name += ` (${data.CallSign})`;
  }
  if (data.AISClass) {
    name += ` | ${data.AISClass}`;
  }
  lines.push(`<strong>${name}</strong>`);

  // Add subsequent lines only if they have valid (non-null/non-empty) values.
  addLine(lines, "Last Update", data.lastUpdate ? timeAgo(data.lastUpdate) : null);
  addLine(lines, "MMSI", data.UserID);

  if (data.UserID) {
    const midData = lookupMidByUserID(data.UserID);
    addLine(lines, "Country", midData.country);
  }

  addLine(lines, "Destination", data.Destination && data.Destination.trim() !== "" ? data.Destination : null);
  addLine(lines, "Speed", (data.Sog != null ? `${data.Sog} kn` : null));
  if (data.Altitude != null) {
    addLine(lines, "Altitude", `${data.Altitude} m`);
  } 
  if (data.Type !== undefined) {
    // choose AtoN mapping if this is an aid-to-navigation station
    const mapping = (data.AISClass === "AtoN")
      ? staticAtoNTypeMapping
      : staticTypeMapping;
    const typeDescription = mapping[data.Type] || data.Type;
    addLine(lines, "Type", typeDescription);
  }

  addLine(lines, "Maximum Draught", (data.MaximumStaticDraught != null ? `${data.MaximumStaticDraught} m` : null));

  if (data.NavigationalStatus !== undefined) {
    const navStatusDescription = navigationalStatusMapping[data.NavigationalStatus] || data.NavigationalStatus;
    addLine(lines, "Nav Status", navStatusDescription);
  }

  return `<div class="popup-content">${lines.join('<br>')}</div>`;
}

function lookupMidByUserID(userID) {
  // Extract the first 3 characters to form the MID
  const mid = String(userID).substring(0, 3);

  if (mids.hasOwnProperty(mid)) {
    return {
      shortcode: mids[mid][0] || null,   // Country short code
      country:   mids[mid][3] || null    // Country name
    };
  }

  // Fallback if MID not found
  return {
    shortcode: "ZZ",
    country:   "Unknown"
  };
}

function buildTooltipLine(...values) {
  return values
    .filter(val => val !== null && val !== undefined && (typeof val === "string" ? val.trim() !== "" : true))
    .join(" | ");
}

// Helper to add a line if the value is valid
function addLine(lines, label, value, formatFn) {
  if (value !== null && value !== undefined && value !== "") {
    lines.push(`${label}: ${formatFn ? formatFn(value) : value}`);
  }
}

function getLatLngs(track) {
  return track.map(pt => [pt[1], pt[2]]);
}

function filterTrackPoints(track) {
  const historyHours = parseInt(document.getElementById("history-slider").value, 10);
  const now = Date.now();
  return track.filter(pt => {
    // Convert the point's timestamp to milliseconds.
    const pointTime = new Date(pt[0]).getTime();
    return (now - pointTime) <= historyHours * 3600000;
  });
}

function createCircleIcon(vesselState) {
  // Get a color that is consistent for the vessel type
  const color = getColorForVesselTypeConsistent(vesselState.Type);
  // Return a divIcon with circular styling
  return L.divIcon({
    html: `<div style="
              width: 12px;
              height: 12px;
              background: ${color};
              border: 0px;
              border-radius: 50%;
           "></div>`,
    className: '', // Optionally leave className empty to prevent extra styling
    iconSize: [12, 12],
    iconAnchor: [6, 6]
  });
}

function createDetailContent(data) {
  const lines = [];
  const lastSeen = data.lastUpdate ? timeAgo(data.lastUpdate) : null;
  addLine(lines, "Last Update", lastSeen);
  addLine(lines, "Messages", data.NumMessages);
  addLine(lines, "MMSI", data.UserID);
  addLine(lines, "AIS Class", data.AISClass);

if (data.UserID) {
  const midData = lookupMidByUserID(data.UserID);
  const countryFlag = `
    <div style="display: inline-flex; align-items: center; margin: 0;">
      <span style="line-height: 20px; margin-right: 8px;">Flag:</span>
      <img src="/flags/${midData.shortcode.toLowerCase()}.svg" 
           alt="${midData.country} Flag" 
           style="width: 30px; height: 20px; border: 1px solid black; object-fit: cover;"
           title="${midData.country}">
    </div>
  `;
  lines.push(countryFlag); // Add the flag with text directly to lines
}

  addLine(lines, "Call Sign", data.CallSign);
  addLine(lines, "IMO Number", data.ImoNumber);

  // Destination: show a default text if it's empty
  if (data.Destination && data.Destination.trim() !== "") {
    addLine(lines, "Destination", data.Destination);
  }

  addLine(lines, "Speed", (data.Sog != null ? `${data.Sog} kn` : null));
  if (data.Altitude != null) {
    addLine(lines, "Altitude", `${data.Altitude} m`);
  }
  addLine(lines, "Course", (data.Cog != null ? `${data.Cog}°` : null));

  if (data.TrueHeading != null && data.TrueHeading < 360) {
    addLine(lines, "Heading", `${data.TrueHeading}°`);
  }

  if (data.Type != null) {
    // If it’s an AtoN report, use the special AtoN mapping; otherwise the normal one
    const mapping = (data.AISClass === "AtoN")
      ? staticAtoNTypeMapping
      : staticTypeMapping;
    const typeDescription = mapping[data.Type] || data.Type;
    addLine(lines, "Type", typeDescription);
  }

  if (data.Dimension) {
    const d = data.Dimension;
    // Calculate overall length and width, but only add if non-zero.
    const totalLength = (Number(d.A) || 0) + (Number(d.B) || 0);
    const totalWidth = (Number(d.C) || 0) + (Number(d.D) || 0);
    if (totalLength > 0 && totalWidth > 0) {
      lines.push(`Dimensions: ${totalLength}m x ${totalWidth}m`);
    }
  }

  if (data.Eta) {
    const e = data.Eta;
    const now = new Date();
    const etaDate = new Date(now.getFullYear(), e.Month - 1, e.Day, e.Hour, e.Minute);
    const etaFormatted = etaDate.toLocaleString('ja-JP', {
      year: 'numeric',
      month: '2-digit',
      day: '2-digit',
      hour: '2-digit',
      minute: '2-digit',
      hour12: false
    });
    lines.push(`ETA: ${etaFormatted}`);
  }

  addLine(lines, "Max Draught", (data.MaximumStaticDraught != null ? `${data.MaximumStaticDraught} m` : null));

  if (data.NavigationalStatus != null) {
    const navStatusDescription = navigationalStatusMapping[data.NavigationalStatus] || data.NavigationalStatus;
    addLine(lines, "Nav Status", navStatusDescription);
  }

  addLine(lines, "Rate Of Turn", (data.RateOfTurn != null ? `${data.RateOfTurn}°/min` : null));

if (data.MessageTypes && Array.isArray(data.MessageTypes)) {
  // Wrap each numeric code in a clickable span
  const codeSpans = data.MessageTypes.map(type =>
    `<span class="msg-type" data-type="${type}" style="cursor:pointer; text-decoration:underline;">${type}</span>`
  );
  lines.push(`Message Types: ${codeSpans.join(', ')}`);
}

  return `<div class="popup-content">${lines.join('<br>')}</div>`;
}

function adjustMapBounds() {
  if (focusedVessel) {
    // When a vessel is focused, center solely on that vessel.
    map.setView(vesselMarkers[focusedVessel].getLatLng(), 13);
    return;
  }

  if (userLatLng) {
    // When no vessel is focused, find the vessel marker nearest to the user.
    let closestMarker = null;
    let closestDistance = Infinity;
    for (const key in vesselMarkers) {
      if (vesselMarkers.hasOwnProperty(key) && map.hasLayer(vesselMarkers[key])) {
        let markerLatLng = vesselMarkers[key].getLatLng();
        let distance = L.latLng(userLatLng).distanceTo(markerLatLng);
        if (distance < closestDistance) {
          closestDistance = distance;
          closestMarker = vesselMarkers[key];
        }
      }
    }
    if (closestMarker) {
      // Define a threshold distance in meters (adjust this value as needed)
      const threshold = 5000; // e.g. 5 km
      if (closestDistance < threshold) {
        // If the closest vessel is really close, use the default zoom (like on page load).
        map.setView(userLatLng, 10);
      } else {
        // Otherwise, fit bounds to include both the user and the closest vessel.
        let bounds = L.latLngBounds([userLatLng, closestMarker.getLatLng()]);
        map.fitBounds(bounds, { padding: [50, 50], maxZoom: 10 });
      }
    } else {
      // If no vessel markers exist, center on the user.
      map.setView(userLatLng, 10);
    }
  } else {
    // Fallback: if the user's location is unknown, use all vessel markers.
    let bounds = L.latLngBounds([]);
    for (const key in vesselMarkers) {
      if (vesselMarkers.hasOwnProperty(key) && map.hasLayer(vesselMarkers[key])) {
        bounds.extend(vesselMarkers[key].getLatLng());
      }
    }
    if (bounds.isValid()) {
      map.fitBounds(bounds, { padding: [50, 50] });
    }
  }
}

        // Utility: Compute a time elapsed string.
        function timeAgo(timestamp) {
          const seconds = Math.floor((Date.now() - timestamp) / 1000);
          if (seconds < 60) return seconds + " sec ago";
          const minutes = Math.floor(seconds / 60);
          if (minutes < 60) return minutes + " min ago";
          const hours = Math.floor(minutes / 60);
          if (hours < 24) return hours + " hrs ago";
          const days = Math.floor(hours / 24);
          return days + " days ago";
        }

function updateStationaryMarkers() {
  const showStationary = document.getElementById('stationary').checked;
  const onlyFocussed = document.getElementById('only-focussed').checked;
  const showPaths = document.getElementById('show-paths').checked;

  for (const userid in vesselData) {
    // Always ensure the marker is visible.
    if (vesselMarkers[userid] && !map.hasLayer(vesselMarkers[userid])) {
      map.addLayer(vesselMarkers[userid]);
    }
    // Now handle track visibility based on only-focussed status.
    if (vesselTracks[userid]) {
      // If onlyFocussed is active and a vessel is focused,
      // then only display the track if this vessel is the focused one.
      if (onlyFocussed && focusedVessel) {
        if (userid === focusedVessel) {
          if (showPaths && !map.hasLayer(vesselTracks[userid])) {
            map.addLayer(vesselTracks[userid]);
          } else if (!showPaths && map.hasLayer(vesselTracks[userid])) {
            map.removeLayer(vesselTracks[userid]);
          }
        } else {
          // Ensure non-focused vessel tracks are not shown.
          if (map.hasLayer(vesselTracks[userid])) {
            map.removeLayer(vesselTracks[userid]);
          }
        }
      } else {
        // If not filtering by focus, add/remove tracks for every vessel normally.
        if (showPaths && !map.hasLayer(vesselTracks[userid])) {
          map.addLayer(vesselTracks[userid]);
        } else if (!showPaths && map.hasLayer(vesselTracks[userid])) {
          map.removeLayer(vesselTracks[userid]);
        }
      }
    }
  }
  updateOverlay();
}



        // Update the known vessels overlay.
function updateOverlay() {
  const filterText = document.getElementById('vessel-filter').value.trim().toLowerCase();
  // When a search is in progress (i.e. 3+ characters are entered), do not update the overlay.
  if (filterText.length >= 3) {
    return;
  }

  const maxAgeHours = parseInt(document.getElementById('age-slider').value, 10);
  const now = Date.now();

  // Get arrays of vessels and receivers.
  const vesselArray = Object.values(vesselData);
  const receiverArray = Object.values(receiverData);

  // Merge the two arrays.
  const combinedEntries = vesselArray.concat(receiverArray);

  // Filter entries that have a name and valid update time.
  const validEntries = combinedEntries.filter(entry => entry.Name && entry.LastUpdated);

  // Filter the entries by the filter text (if any) and age.
  const filteredEntries = validEntries.filter(entry => {
    const textMatch =
      entry.Name.toLowerCase().includes(filterText) ||
      (entry.CallSign && entry.CallSign.toLowerCase().includes(filterText)) ||
      entry.UserID.toString().includes(filterText);
    const entryTime = new Date(entry.LastUpdated).getTime();
    const withinAge = (now - entryTime) <= maxAgeHours * 3600000;
    return textMatch && withinAge;
  });

  // Sort by update time (newest first).
  filteredEntries.sort((a, b) => new Date(b.LastUpdated) - new Date(a.LastUpdated));
  const topEntries = filteredEntries.slice(0, 100);

  const bounds = map.getBounds();
  let visibleCount = 0;
  for (const id in vesselMarkers) {
    if (map.hasLayer(vesselMarkers[id])) visibleCount++;
  }
  for (const id in receiverMarkers) {
    if (bounds.contains(receiverMarkers[id].getLatLng())) {
	visibleCount++;
    }
  }

  // Update the overlay count text.
  document.getElementById('vessel-count').innerHTML =
    `${topEntries.length} of ${filteredEntries.length} entries<br>${visibleCount} visible on map`;

  // Build the HTML content for the overlay.
  let content = "";
  topEntries.forEach(entry => {
    const name = entry.Name;
    const lastSeen = timeAgo(new Date(entry.LastUpdated).getTime());
    const numMessages = entry.NumMessages || 0;
    const extraInfo = entry.isReceiver
      ? `<div class="vessel-callsign">Receiver</div>`
      : `<div class="vessel-callsign">Call Sign: ${entry.CallSign ? entry.CallSign : "N/A"}</div>`;
    content += `<div class="vessel-entry" data-userid="${entry.UserID}">
                  <div class="vessel-name">${name}</div>
                  ${extraInfo}
                  <div class="vessel-timestamp">${lastSeen} | ${numMessages} msgs</div>
                </div>`;
  });

  document.getElementById('overlay-content').innerHTML = content;

  // Attach click events for the overlay entries.
  document.querySelectorAll('.vessel-entry').forEach(entry => {
    entry.addEventListener('click', event => {
      event.stopPropagation();
      const UserID = entry.getAttribute('data-userid');
      if (receiverData.hasOwnProperty(UserID)) {
        const marker = receiverMarkers[UserID];
        map.setView(marker.getLatLng(), 10);
        marker.openPopup();
      } else {
        document.getElementById('stationary').checked = true;
        updateStationaryMarkers();
        focusOnVessel(UserID);
      }
    });
  });
}

// Helper function to check if the vessel is visible by the current age filter
function isVesselVisibleByAge(vessel, maxAgeHours, now) {
    const ageMilliseconds = now - vessel.lastUpdate;
    return ageMilliseconds <= maxAgeHours * 3600000; // Convert to milliseconds
}

// Helper function to check if the vessel is visible by the current age filter
function isVesselVisibleByAge(vessel) {
  const maxAgeHours = parseInt(document.getElementById("age-slider").value, 10);
  const now = Date.now();
  const ageMilliseconds = now - vessel.lastUpdate;
  return ageMilliseconds <= maxAgeHours * 3600000; // Convert to milliseconds
}

function attachMessageTypeClicks() {
  document.querySelectorAll('#detail-content .msg-type').forEach(el => {
    el.addEventListener('click', async (e) => {
      e.stopPropagation();

      const userID   = focusedVessel;
      const rawType  = el.dataset.type;
      const friendly = messageTypeNames[rawType] || `Unknown (${rawType})`;

      try {
        const resp = await fetch(`/latestmessages?UserID=${userID}&MessageID=${rawType}`);
        if (!resp.ok) throw new Error(`HTTP ${resp.status}`);
        const [msg] = await resp.json();

        // Convert timestamp
        const localTs    = new Date(msg.Timestamp).toLocaleString();
        const packetJson = JSON.stringify(msg.Packet, null, 2);

        // Create or get overlay container
        let lm = document.getElementById('latest-message-overlay');
        if (!lm) {
          lm = document.createElement('div');
          lm.id = 'latest-message-overlay';
          document.body.appendChild(lm);
        }
        lm.innerHTML    = '';
        lm.style.display = 'block';

        // Header (flex layout for left/right)
        const header = document.createElement('div');
        header.className = 'lm-header';
        header.style.display        = 'flex';
        header.style.justifyContent = 'space-between';
        header.style.alignItems     = 'center';
        header.innerHTML = `<strong>Message ${rawType}: ${friendly}</strong>`;

        const closeBtn = document.createElement('button');
        closeBtn.className = 'lm-close';
        closeBtn.textContent = '✕';
        closeBtn.onclick = () => { lm.style.display = 'none'; };

        header.appendChild(closeBtn);
        lm.appendChild(header);

        // Timestamp
        const tsDiv = document.createElement('div');
        tsDiv.textContent = localTs;
        lm.appendChild(tsDiv);

        // Packet JSON block
        const prePkt = document.createElement('pre');
        const codePkt = document.createElement('code');
        codePkt.textContent = packetJson;
        prePkt.appendChild(codePkt);
        lm.appendChild(prePkt);

        // Raw AIS sentence block
        const preRaw = document.createElement('pre');
        const codeRaw = document.createElement('code');
        codeRaw.textContent = msg.RawSentence;
        preRaw.appendChild(codeRaw);
        lm.appendChild(preRaw);

      } catch (err) {
        console.error('Failed to load latest message:', err);
        showFlashMessage('Error loading message', el);
      }
    });
  });
}
        // Periodically update the vessel detail overlay.
	function updateVesselDetailOverlay() {
	  if (!detailsOverlayHidden && focusedVessel && vesselData[focusedVessel]) {
	    const html = createDetailContent(vesselData[focusedVessel]);
	    const container = document.getElementById('detail-content');
	    container.innerHTML = html;
	    attachMessageTypeClicks();
	  }
	}
        setInterval(updateVesselDetailOverlay, 1000);
        setInterval(updateOverlay, 1000);

        // Update marker and track visibility based on the "Only Tracked" checkbox.
function updateFocussedVisibility() {
  if (focusedVessel) {
    if (!map.hasLayer(vesselMarkers[focusedVessel])) {
      map.addLayer(vesselMarkers[focusedVessel]);
    }
    const showPaths = document.getElementById('show-paths').checked;
    if (vesselTracks[focusedVessel]) {
      if (showPaths && !map.hasLayer(vesselTracks[focusedVessel])) {
        map.addLayer(vesselTracks[focusedVessel]);
      } else if (!showPaths && map.hasLayer(vesselTracks[focusedVessel])) {
        map.removeLayer(vesselTracks[focusedVessel]);
      }
    }
  }
  updateOverlay();
}


        // --- Live Logs functionality ---
        const maxLogMessages = 250;
        const liveLogsContent = document.getElementById('live-logs-content');

        // Helper function to recursively format nested objects with indentation.
        function formatLogField(key, value, indentLevel = 0) {
          const indentStyle = `style="padding-left: ${indentLevel * 15}px"`;
          let html = `<div ${indentStyle}><span class="log-field">${key}:</span> `;
          if (value !== null && typeof value === 'object') {
            html += `<br>`;
            for (const subKey in value) {
              html += formatLogField(subKey, value[subKey], indentLevel + 1);
            }
          } else {
            html += `${value}`;
          }
          html += `</div>`;
          return html;
        }

function renderLogMessageNode(msg) {
  const entry = document.createElement('div');
  entry.className = 'log-entry';
  entry.dataset.type = msg.type;

  // Helper to render a field, recursing into nested objects
  function renderField(container, key, val, indent = 0) {
    if (val !== null && typeof val === 'object') {
      // Render the key
      const label = document.createElement('div');
      label.className = 'log-field';
      label.style.paddingLeft = `${15 * indent}px`;
      label.textContent = `${key}:`;
      container.appendChild(label);
      // Recurse for each sub-property
      for (const [subKey, subVal] of Object.entries(val)) {
        renderField(container, subKey, subVal, indent + 1);
      }
    } else {
      // Primitive value: render on one line
      const row = document.createElement('div');
      row.className = 'log-field';
      row.style.paddingLeft = `${15 * indent}px`;
      row.textContent = `${key}: ${val}`;
      container.appendChild(row);
    }
  }

  // Timestamp
  const tsDiv = document.createElement('div');
  tsDiv.className = 'log-timestamp';
  tsDiv.style.cssText = 'font-size:10px;color:#888;margin-bottom:2px;';
  tsDiv.textContent = msg.timestamp
    ? new Date(msg.timestamp).toLocaleTimeString()
    : new Date().toLocaleTimeString();
  entry.appendChild(tsDiv);

  // Message Type
  const typeNum   = String(msg.type);
  const typeLabel = messageTypeNames[typeNum] || `Unknown (${typeNum})`;
  renderField(entry, 'Message Type', `${typeNum}: ${typeLabel}`, 0);

  // Other data fields (handles nested objects)
  for (const [field, val] of Object.entries(msg.data)) {
    renderField(entry, field, val, 0);
  }

  // Raw Sentence (label + content block)
  if (msg.raw_sentence) {
    renderField(entry, 'Raw Sentence', msg.raw_sentence, 0);
  }

  return entry;
}

function subscribeInstantUpdates(UserID) {
  focussedID = UserID
  const channelName = "ais_sub/:userID";
  instantChannel = channelName;
  socket.emit(channelName, UserID);
  console.log("[AIS_SUBSCRIBE]", channelName, UserID);

  // Allowed AIS message types as numbers
  //const allowedTypes = new Set([1,2,3,8,9,18,19]);

  instantHandler = function(rawMessage) {
    console.log("[AIS_DATA RECEIVED raw]", rawMessage);

    let message = rawMessage;
    // If you ever get a JSON string, parse it
    if (typeof rawMessage === "string") {
      try {
        message = JSON.parse(rawMessage);
        console.log("[AIS_DATA] parsed JSON →", message);
      } catch (e) {
        console.error("[AIS_DATA] JSON.parse failed:", e, rawMessage);
        return;
      }
    }

    // Ensure `type` is a number
    const msgType = Number(message.type);
    if (Number.isNaN(msgType)) {
      console.warn("[AIS_DATA] bad message.type (not a number):", message.type);
      return;
    }
    console.log("[AIS_DATA] type =", msgType);

    // Filter out unwanted types
    //if (!allowedTypes.has(msgType)) {
    //  console.log("[AIS_DATA] filtered out type", msgType);
    //  return;
    //}

    // Ensure we have a data payload
    if (!message.data || typeof message.data !== "object") {
      console.warn("[AIS_DATA] missing .data payload:", message);
      return;
    }

    // Update vesselData
    if (!vesselData[UserID]) {
      console.warn("[AIS_DATA] no vesselData entry for", UserID);
      return;
    }

    // Copy fields over
    Object.entries(message.data).forEach(([k,v]) => {
      vesselData[UserID][k] = v;
    });

    // Timestamp handling
    if (message.timestamp) {
      const ts = new Date(message.timestamp).getTime();
      vesselData[UserID].lastUpdate = ts;
      console.log("[AIS_DATA] timestamp =>", message.timestamp);
    }

    // Position update
    const lat = message.data.Latitude;
    const lon = message.data.Longitude;
    if (typeof lat === "number" && typeof lon === "number") {
      console.log(`[AIS_DATA] updating position to (${lat}, ${lon})`);

      // Move marker
      if (vesselMarkers[UserID]) {
        vesselMarkers[UserID].setLatLng([lat, lon]);
        vesselMarkers[UserID].setIcon(getVesselIcon(vesselData[UserID]));
        vesselMarkers[UserID].getPopup().setContent(createPopupContent(vesselData[UserID]));
      }

      // Track history
      vesselData[UserID].track = vesselData[UserID].track || [];
      vesselData[UserID].track.push([
        message.timestamp, lat, lon,
        message.data.Sog ?? null,
        message.data.Cog ?? null,
        message.data.TrueHeading ?? null
      ]);

      // Rebuild polyline
      if (vesselTracks[UserID]) map.removeLayer(vesselTracks[UserID]);
      vesselTracks[UserID] = createColoredTrack(filterTrackPoints(vesselData[UserID].track));
      if (document.getElementById('show-paths').checked) {
          map.addLayer(vesselTracks[UserID]);
      }
      attachPolylineEvents(vesselTracks[UserID], UserID);
    }

    // Finally, update overlays/logs
    updateVesselDetailOverlay();
    addLiveLogEntry(message);
  };

  // Attach to the socket
  socket.on("ais_data", instantHandler);
}


    function unsubscribeInstantUpdates() {
      if (instantHandler) {
	console.log("ais_unsub/:userID", focussedID);
        socket.emit("ais_unsub/:userID", focussedID);
        socket.off("ais_data", instantHandler);
      }
      instantChannel = null;
      instantHandler = null;
    }

function addLiveLogEntry(message) {
  // Remove placeholder if present
  const placeholder = liveLogsContent.querySelector('.placeholder');
  if (placeholder) placeholder.remove();

  // Declare node first
  let node;
  // Render the log entry node
  node = renderLogMessageNode(message);
  // Save original message on the node for filtering
  node.originalMessage = message;

  // Prepend to the live logs container
  liveLogsContent.insertBefore(node, liveLogsContent.firstChild);

  // Apply filters immediately
  applyLogFilters();

  // Limit total entries
  while (liveLogsContent.childElementCount > maxLogMessages) {
    liveLogsContent.removeChild(liveLogsContent.lastChild);
  }
}




function applyLogFilters() {
  const entries     = liveLogsContent.querySelectorAll('.log-entry');
  const query       = document.getElementById('live-log-search').value.toLowerCase().trim();
  const showAll     = document.getElementById('log-filter-all').checked;
  // Build a set of allowed types if not showing all
  let allowedTypes = null;
  if (!showAll) {
    allowedTypes = new Set();
    document.querySelectorAll('.log-filter:checked').forEach(cb => {
      cb.value.split(',').forEach(code => allowedTypes.add(code.trim()));
    });
  }

  entries.forEach(entry => {
    const msgType = entry.dataset.type;
    // 1) Filter by message type checkboxes
    if (!showAll && !allowedTypes.has(msgType)) {
      entry.style.display = 'none';
      return;
    }

    // 2) Text‐search filter: always keep timestamp
    const timestamp = entry.querySelector('.log-timestamp');
    if (timestamp) timestamp.style.display = '';

    // Check each .log-field (label + content)
    let anyMatch = false;
    entry.querySelectorAll('.log-field').forEach(fieldDiv => {
      const text = fieldDiv.textContent.toLowerCase();
      if (!query || text.includes(query)) {
        fieldDiv.style.display = '';
        anyMatch = anyMatch || Boolean(query); // if query empty, we'll keep them all anyway
      } else {
        fieldDiv.style.display = 'none';
      }
    });

    // If there's a search query and no fields matched, hide the whole entry
    if (query && !anyMatch) {
      entry.style.display = 'none';
    } else {
      entry.style.display = '';
    }
  });
}


	document.getElementById('log-filter-all').addEventListener('change', applyLogFilters);

        // When the Live Logs button is clicked.
        document.getElementById('live-logs').addEventListener('click', () => {
          const overlay = document.getElementById('live-logs-overlay');
          overlay.style.display = 'block';
          clearLiveLogs();
        });

        // When the close button on the Live Logs overlay is clicked.
        document.getElementById('close-live-logs').addEventListener('click', () => {
          const overlay = document.getElementById('live-logs-overlay');
          overlay.style.display = 'none';
          clearLiveLogs();
        });

        // Make the Live Logs overlay draggable.
        (function makeDraggable() {
          const overlay = document.getElementById('live-logs-overlay');
          const header = document.getElementById('live-logs-header');
          let offsetX = 0, offsetY = 0, isDragging = false;

          header.addEventListener('mousedown', (e) => {
            isDragging = true;
            offsetX = e.clientX - overlay.offsetLeft;
            offsetY = e.clientY - overlay.offsetTop;
          });

          document.addEventListener('mousemove', (e) => {
            if (isDragging) {
              overlay.style.left = (e.clientX - offsetX) + 'px';
              overlay.style.top = (e.clientY - offsetY) + 'px';
            }
          });

          document.addEventListener('mouseup', () => {
            isDragging = false;
          });
        })();

        // Load saved vessel data from localStorage if available.
        const storedData = localStorage.getItem('vesselData');
        if (storedData) {
          try {
            const parsedData = JSON.parse(storedData);
            Object.keys(parsedData).forEach(UserID => {
              vesselData[UserID] = parsedData[UserID];
              if (
                vesselData[UserID].Latitude !== undefined &&
                vesselData[UserID].Longitude !== undefined
              ) {
                const lat = vesselData[UserID].Latitude;
                const lon = vesselData[UserID].Longitude;
                const popupContent = createPopupContent(vesselData[UserID]);
		const marker = L.marker(
		  [vesselData[UserID].Latitude, vesselData[UserID].Longitude],
		  { icon: getVesselIcon(vesselData[UserID]) }
		).addTo(map);

		marker.on('add', function() {
		  const markerElem = marker.getElement();
		  if (markerElem) {
		    const svg = markerElem.querySelector('svg');
		    if (svg) {
		      const heading = 
 			 (typeof vesselData[UserID].TrueHeading === 'number' && vesselData[UserID].TrueHeading < 360)
			    ? vesselData[UserID].TrueHeading
			    : (typeof vesselData[UserID].Cog === 'number' && vesselData[UserID].Cog >= 0 && vesselData[UserID].Cog < 360)
			      ? vesselData[UserID].Cog
			      : 0;  // Default to 0° if neither TrueHeading nor Cog is valid
		      if (heading !== undefined) {
		        svg.style.transform = `rotate(${heading}deg)`;
		      }
		    }
		  }
    	      if (markerElem) {
    	       const svg = markerElem.querySelector('svg');
    		 if (svg) {
    		    svg.addEventListener('click', (e) => {
    		      if (e && typeof e.stopPropagation === 'function') {
    		        e.stopPropagation();
    		      }
    		      focusOnVessel(UserID);
    		    });
    		  }
    	       }
    	    });
                marker.bindPopup(popupContent, { autoPan: false });
                if (vesselData[UserID].Name) {
                  marker.bindTooltip(vesselData[UserID].Name, {
                    permanent: true,
                    direction: 'top',
                    className: 'vessel-tooltip',
                    interactive: true
                  }).openTooltip();
                  attachTooltipClick(marker, UserID);
                }
                marker.on('click', function(e) {
      	      if (e && typeof e.stopPropagation === 'function') {
    	        e.stopPropagation();
    	      }
    	      if (e && typeof e.preventDefault === 'function') {
    	        e.preventDefault();
    	      }
    	      focusOnVessel(UserID);
    	    });
    	    const markerElem = marker.getElement() || marker._icon;
    	    if (markerElem) {
    	      markerElem.addEventListener('click', (e) => {
    	        if (e && typeof e.stopPropagation === 'function') {
    	          e.stopPropagation();
    	        }
       	    focusOnVessel(UserID);
    	      });
    	    }
                if (!isMobile) {
                  marker.on('mouseover', function() { this.openPopup(); });
                  marker.on('mouseout', function() { this.closePopup(); });
                }
                vesselMarkers[UserID] = marker;
              }
		if (vesselData[UserID].track && vesselData[UserID].track.length > 0) {
		  vesselTracks[UserID] = L.polyline(getLatLngs(vesselData[UserID].track), {
		    color: vesselData[UserID].color,
		    weight: 3,
		    opacity: 0.8,
		    interactive: true
		  }).addTo(map);
		  attachPolylineEvents(vesselTracks[UserID], UserID);
		}
            });
            debouncedAdjustMapBounds();
            updateOverlay();
	    updateStationaryMarkers();
          } catch (e) {
            console.error("Error loading stored vessel data", e);
          }
        }

        // Listen for changes to the "Only Tracked" and "OpenSeaMap Overlay" checkboxes.
        document.getElementById('only-focussed').addEventListener('change', () => {
  	    updateFocussedVisibility();
	    updateStationaryMarkers();
	    sendSummaryRequest();
            updateOverlay();
	});
	document.getElementById('openseamap-overlay').addEventListener('change', () => {
	  const overlayEnabled = document.getElementById('openseamap-overlay').checked;
	  if (overlayEnabled) {
	    if (!map.hasLayer(openSeaMapLayer)) {
	      map.addLayer(openSeaMapLayer);
	    }
	    // Bring it to the front after it’s added.
	    openSeaMapLayer.bringToFront();
	  } else {
	    if (map.hasLayer(openSeaMapLayer)) {
	      map.removeLayer(openSeaMapLayer);
	    }
	  }
	});

        // Connect to the Socket.IO server.
        const socket = io();
        let instantChannel = null;
        let instantHandler = null;

        // Listen for the socket connection event.
        socket.on('connect', () => {
          document.getElementById('status-dot').style.background = 'green';
          document.getElementById('status-text').textContent = 'Connected';
	  socket.emit("subscribe", "summaryData");
	  // If a vessel is focused, resubscribe to its channel.
	  if (focusedVessel) {
	    subscribeInstantUpdates(focusedVessel);
  	}
        });

        // Listen for the socket disconnection event.
        socket.on('disconnect', () => {
          document.getElementById('status-dot').style.background = 'red';
          document.getElementById('status-text').textContent = 'Disconnected';
        });

socket.on("summaryData", (data) => {
  const ageSlider = document.getElementById('age-slider');
  const maxAgeHours = parseInt(ageSlider.value, 10); // Get max-age from the slider
  const now = Date.now();
  const maxAgeMilliseconds = maxAgeHours * 3600000;  // Convert hours to milliseconds

  if (typeof data === "string") {
    try {
      data = JSON.parse(data);
    } catch (e) {
      console.error("Failed to parse JSON:", e);
      return;
    }
  }
  if (typeof data !== "object" || Array.isArray(data)) {
    console.error("Received invalid data format:", data);
    return;
  }

  // Remove vessels that no longer appear in the summary data.
  const newIDs = new Set(Object.keys(data));
  for (const userid in vesselData) {
    // Only remove if the vessel is not in the latest summary AND is not manually focused
    if (!newIDs.has(userid) && userid !== focusedVessel) {
      if (vesselMarkers[userid]) map.removeLayer(vesselMarkers[userid]);
      if (vesselTracks[userid]) map.removeLayer(vesselTracks[userid]);
      delete vesselData[userid];
      delete vesselMarkers[userid];
      delete vesselTracks[userid];
    }
  }

  for (const userid in data) {
    const vesselState = data[userid];
    const vesselTimestamp = new Date(vesselState.LastUpdated).getTime();

    // Create new vessel data if not already present.
    if (!vesselData[userid]) {
      vesselData[userid] = Object.assign({}, vesselState);
      vesselData[userid].track = [];
      vesselData[userid].color = randomColor();
    } else {
      // For a focused vessel, update only non-location/movement fields.
      if (userid === focusedVessel) {
        // Destructure to remove the location/movement fields.
        const { Latitude, Longitude, Sog, Cog, TrueHeading, ...nonLocationData } = vesselState;
        Object.assign(vesselData[userid], nonLocationData);
      } else {
        // Not in focus, so merge all fields.
        Object.assign(vesselData[userid], vesselState);
      }
    }
    // Always update these timestamp fields.
    vesselData[userid].LastUpdated = vesselState.LastUpdated;
    vesselData[userid].lastUpdate = vesselTimestamp;

    if (!Array.isArray(vesselData[userid].track)) {
      vesselData[userid].track = [];
    }
    // append the new summary point
    vesselData[userid].track.push([
      vesselState.LastUpdated,           // ISO timestamp
      vesselState.Latitude,              // lat
      vesselState.Longitude,             // lon
      vesselState.Sog  ?? null,          // speed
      vesselState.Cog  ?? null,          // course
      vesselState.TrueHeading ?? null    // heading
    ]);

    const popupContent = createPopupContent(vesselData[userid]);

    // Update marker/track if location data exists…
    if (typeof vesselState.Latitude === "number" && typeof vesselState.Longitude === "number") {
      if (userid !== focusedVessel) {
        // For vessels not in focus, update location and movement fields.
        const lat = vesselState.Latitude;
        const lon = vesselState.Longitude;
        if (vesselMarkers[userid]) {
          vesselMarkers[userid].setLatLng([lat, lon]);
          vesselMarkers[userid].getPopup().setContent(popupContent);
          const markerElem = vesselMarkers[userid].getElement() || vesselMarkers[userid]._icon;
          if (markerElem) {
            const svg = markerElem.querySelector('svg');
            if (svg) {
              const heading =
                (typeof vesselState.TrueHeading === 'number' && vesselState.TrueHeading < 360)
                  ? vesselState.TrueHeading
                  : (typeof vesselState.Cog === 'number' && vesselState.Cog >= 0 && vesselState.Cog < 360)
                    ? vesselState.Cog
                    : 0;
              svg.style.transform = `rotate(${heading}deg)`;
            }
          }
          if (vesselState.Name && userid !== focusedVessel) {
            vesselMarkers[userid].unbindTooltip();
            if (map.getZoom() >= TOOLTIP_ZOOM_THRESHOLD) {
              vesselMarkers[userid].bindTooltip(vesselState.Name, {
                permanent: true,
                direction: 'top',
                className: 'vessel-tooltip',
                interactive: true
              }).openTooltip();
              attachTooltipClick(vesselMarkers[userid], userid);
            }
          }
          vesselMarkers[userid].off('click');
          vesselMarkers[userid].on('click', function(e) {
            if (e && typeof e.stopPropagation === 'function') { e.stopPropagation(); }
            if (e && typeof e.preventDefault === 'function') { e.preventDefault(); }
            focusOnVessel(userid);
          });
          const markerElem2 = vesselMarkers[userid].getElement() || vesselMarkers[userid]._icon;
          if (markerElem2) {
            markerElem2.classList.add('enlarge');
            setTimeout(() => markerElem2.classList.remove('enlarge'), 500);
          }
        } else {
          const marker = L.marker(
            [vesselState.Latitude, vesselState.Longitude],
            { icon: getVesselIcon(vesselData[userid]) }
          ).addTo(map);
          marker.bindPopup(popupContent, { autoPan: false });
          const currentZoom = map.getZoom();
          if (currentZoom >= TOOLTIP_ZOOM_THRESHOLD && vesselState.Name) {
            marker.bindTooltip(vesselState.Name, {
              permanent: true,
              direction: 'top',
              className: 'vessel-tooltip',
              interactive: true
            }).openTooltip();
            attachTooltipClick(marker, userid);
          }
          marker.on('click', function(e) {
            if (e && typeof e.stopPropagation === 'function') { e.stopPropagation(); }
            if (e && typeof e.preventDefault === 'function') { e.preventDefault(); }
            focusOnVessel(userid);
          });
          if (!isMobile) {
            marker.on('mouseover', function() { this.openPopup(); });
            marker.on('mouseout', function() { this.closePopup(); });
          }
          vesselMarkers[userid] = marker;
        }
//        const filteredTrack = filterTrackPoints(vesselData[userid].track);
//        if (vesselTracks[userid]) {
//	  map.removeLayer(vesselTracks[userid]);
//	}
//	vesselTracks[userid] = createColoredTrack(filteredTrack);
//        if (document.getElementById('show-paths').checked) {
//	    map.addLayer(vesselTracks[userid]);
//	    attachPolylineEvents(vesselTracks[userid], userid);
//        }
      } else {
        // For a focused vessel, skip location updates—only update its popup.
        if (vesselMarkers[userid]) {
          vesselMarkers[userid].getPopup().setContent(popupContent);
        }
      }
    } else {
      if (vesselMarkers[userid]) {
        vesselMarkers[userid].getPopup().setContent(popupContent);
        vesselMarkers[userid].unbindTooltip();
        vesselMarkers[userid].bindTooltip(popupContent, {
          direction: 'top',
          className: 'vessel-tooltip'
        });
      }
    }

    if (focusedVessel && focusedVessel == userid && !detailsOverlayHidden) {
      if (isMobile) {
        map.panTo(vesselMarkers[userid].getLatLng());
      } else {
        focusOnVessel(userid, false);
      }
    }
  }
  updateOverlay();
  updateFocussedVisibility();
  updateStationaryMarkers();
  localStorage.setItem('vesselData', JSON.stringify(vesselData));
});

// Use a debounced function to limit the frequency of requests:
// Global variables to store the current search query and the interval timer.
let currentSearchQuery = '';
let searchInterval = null;

document.getElementById('vessel-filter').addEventListener('input', function(event) {
  // Update current search query with trimmed value.
  currentSearchQuery = event.target.value.trim();

  // Check if the query meets the length threshold.
  if (currentSearchQuery.length < 3) {
    // If below threshold, clear any active search interval.
    if (searchInterval) {
      clearInterval(searchInterval);
      searchInterval = null;
    }
    // Update the overlay normally.
    updateOverlay();
    return;
  }

  // If the query length is 3 or more:
  // Call the search function immediately.
  performSearch(currentSearchQuery);

  // If no interval is already running, set one up for every 5 seconds.
  if (!searchInterval) {
    searchInterval = setInterval(() => {
      // Use the latest query value in case the user modifies it.
      performSearch(currentSearchQuery);
    }, 10000);
  }
});

// Function that performs the search fetch.
function performSearch(query) {
  // Get the current max-age value from the age slider (in hours)
  const ageSlider = document.getElementById("age-slider");
  const maxAge = parseInt(ageSlider.value, 10); // Convert the value to an integer

  // Include both the query and the max-age (with field name "maxAge") in the request body.
  fetch('/search', {
    method: 'POST',
    headers: { 'Content-Type': 'application/json' },
    body: JSON.stringify({ query: query, maxAge: maxAge })
  })
  .then(response => {
    if (!response.ok) {
      throw new Error(`Server error: ${response.status}`);
    }
    return response.json();
  })
  .then(searchResults => {
    const receiverResults = Object.values(receiverData).filter(receiver => {
      const q = query.toLowerCase();
      return (
        receiver.Name.toLowerCase().includes(q) ||
        (receiver.CallSign && receiver.CallSign.toLowerCase().includes(q)) ||
        receiver.UserID.toString().includes(q)
      );
    });

    // Merge the two arrays and render the results.
    const combinedResults = searchResults.concat(receiverResults);
    renderSearchResults(combinedResults);
  })
  .catch(err => {
    console.error('Search request failed:', err);
    updateOverlay();
  });
}


        document.getElementById('clear-history').addEventListener('click', clearHistory);

	document.getElementById('stationary').addEventListener('change', () => {
  	  sendSummaryRequest();
    	  updateStationaryMarkers();
	});

        // Attach tooltip click listener.
        function attachTooltipClick(marker, UserID) {
          setTimeout(() => {
            const tooltip = marker.getTooltip();
            if (tooltip) {
              const ttEl = tooltip.getElement();
              if (ttEl) {
                ttEl.addEventListener('click', (e) => {
                  if (e && typeof e.stopPropagation === 'function') {
 		     e.stopPropagation();
		   }
                  focusOnVessel(UserID);
                });
              }
            }
          }, 0);
        }

	let lastFetchedUserID = null;

	function fetchMissingData(UserID) {
	  // Only fetch if this vessel hasn't already had its missing data fetched this selection.
	  if (lastFetchedUserID === UserID) return;

	  fetch(`/state/${UserID}`)
	    .then(response => {
	      if (!response.ok) {
	        throw new Error(`Network response was not ok (${response.status})`);
	      }
	      return response.json();
	    })
	    .then(data => {
	      Object.assign(vesselData[UserID], data);
	      updateVesselDetailOverlay();
	      lastFetchedUserID = UserID;
	    })
	    .catch(err => {
	      console.error("Error fetching missing vessel data:", err);
	    });
	}

// Function to find the nearest point on the polyline track to the mouse event latlng.
function getNearestTrackPoint(e, track) {
  const mouseLatLng = e.latlng;
  let minDistance = Infinity;
  let nearestPoint = null;
  
  // Iterate over each point in the track (each point is [timestamp, lat, lon])
  track.forEach(pt => {
    // Create a Leaflet LatLng object for comparison.
    const ptLatLng = L.latLng(pt[1], pt[2]);
    const distance = mouseLatLng.distanceTo(ptLatLng);
    if (distance < minDistance) {
      minDistance = distance;
      nearestPoint = { ptLatLng, info: pt };
    }
  });
  return nearestPoint;
}




// Focus on a particular vessel.
function focusOnVessel(UserID, initialFocus = true) {
  // Unfocus previously focused vessel
  if (initialFocus) {
	document.getElementById('show-paths').checked = true;
  }
  if (focusedVessel && focusedVessel !== UserID) {
    const prevMarker = vesselMarkers[focusedVessel];
    if (prevMarker) {
      // If a tooltip exists, update its content; otherwise, bind a default one.
      let prevTooltip = prevMarker.getTooltip();
      if (!prevTooltip) {
        prevMarker.bindTooltip(vesselData[focusedVessel].Name, {
          permanent: true,
          direction: 'top',
          className: 'vessel-tooltip'
        });
        prevTooltip = prevMarker.getTooltip();
      }
      if (prevTooltip) {
        prevTooltip.setContent(vesselData[focusedVessel].Name);
      }
      prevMarker.closeTooltip();
      prevMarker.setZIndexOffset(0);
      const prevElem = prevMarker.getElement();
      if (prevElem) {
        prevElem.classList.remove('enlarge');
      }
    }
  }
  
  // Update subscriptions if focusing on a new vessel
  if (focusedVessel !== UserID) {
    clearLiveLogs();
    if (instantChannel) {
      unsubscribeInstantUpdates();
    }
    subscribeInstantUpdates(UserID);
    hydrateTrackHistory(UserID);
  }
  

  if (focusedVessel && focusedVessel !== UserID) {
    const prevMarker = vesselMarkers[focusedVessel];
    if (prevMarker) {
      let prevTooltip = prevMarker.getTooltip();
      if (!prevTooltip) {
        prevMarker.bindTooltip(vesselData[focusedVessel].Name, {
          permanent: true,
          direction: 'top',
          className: 'vessel-tooltip'
        });
        prevTooltip = prevMarker.getTooltip();
      }
      if (prevTooltip) {
        prevTooltip.setContent(vesselData[focusedVessel].Name);
      }
      prevMarker.closeTooltip();
      prevMarker.setZIndexOffset(0);
      const prevElem = prevMarker.getElement();
      if (prevElem) {
        prevElem.classList.remove('enlarge');
      }
    }
  }
  
  // Set the new focused vessel.
  focusedVessel = UserID;

  for (const userid in vesselTracks) {
    if (userid !== focusedVessel && map.hasLayer(vesselTracks[userid])) {
      map.removeLayer(vesselTracks[userid]);
    }
  }

  // Now add the focused vessel’s polyline (if it exists) based on the "show-paths" checkbox.
  if (document.getElementById('show-paths').checked && vesselTracks[focusedVessel] && !map.hasLayer(vesselTracks[focusedVessel])) {
    map.addLayer(vesselTracks[focusedVessel]);
  }


  const marker = vesselMarkers[UserID];
  if (!marker) return; // Ensure marker exists
  marker.setZIndexOffset(1000);
  const vessel = vesselData[UserID];
  
  updateLatLongDisplay();
  
  // Build new tooltip content.
  const line1 = buildTooltipLine(
    vessel.Destination,
    (navigationalStatusMapping[vessel.NavigationalStatus] || vessel.NavigationalStatus) !== 'Unknown'
      ? (navigationalStatusMapping[vessel.NavigationalStatus] || vessel.NavigationalStatus)
      : null
  );
  // Tooltip “Type” for live-updates: branch on AtoN
  const utMapping = (vessel.AISClass === "AtoN")
    ? staticAtoNTypeMapping
   : staticTypeMapping;
  const utTypeText = utMapping[vessel.Type] || vessel.Type;
  const line2 = buildTooltipLine(
    utTypeText,
    (vessel.MaximumStaticDraught != null ? `${vessel.MaximumStaticDraught} m` : null),
    (vessel.Sog != null                     ? `${vessel.Sog} kn`                  : null),
    (vessel.TrueHeading != null && vessel.TrueHeading < 360
      ? `${vessel.TrueHeading}°`
      : `${vessel.Cog}°`)
 );

  const tooltipLines = [`${vessel.Name}${vessel.CallSign ? ` (${vessel.CallSign})` : ''}`];

  if (line1.trim()) tooltipLines.push(line1);
  if (line2.trim()) tooltipLines.push(line2);
  tooltipLines.push(timeAgo(vessel.lastUpdate));
  const newTooltipContent = tooltipLines.join('<br>');
  
  // Make sure the marker has a tooltip before updating.
  let tooltip = marker.getTooltip();
  if (!tooltip) {
    marker.bindTooltip(newTooltipContent, {
      permanent: true,
      direction: 'top',
      className: 'vessel-tooltip',
      interactive: true
    }).openTooltip();
    tooltip = marker.getTooltip();
  } else {
    tooltip.setContent(newTooltipContent);
  }
  
  // Set tooltip element's z-index.
  const tooltipEl = tooltip.getElement();
  if (tooltipEl) {
    tooltipEl.style.zIndex = '1200';
  }
  
  // Show detail overlay and related buttons.
  document.getElementById('toggle-detail-overlay').style.display = 'block';
  document.getElementById('live-logs').style.display = 'block';
  document.getElementById('stats-button').style.display = 'block';
  
  const detailOverlay = document.getElementById('vessel-detail');
  if (!detailsOverlayHidden) {
    detailOverlay.style.display = 'block';
    document.getElementById('toggle-detail-overlay').textContent = 'Hide Details';
  } else {
    detailOverlay.style.display = 'none';
    document.getElementById('toggle-detail-overlay').textContent = 'Show Details';
  }
  
  if (isMobile) {
    setTimeout(() => {
      updateVesselDetailHeader(UserID);
    }, 300);  // 300 ms delay; adjust as needed
  } else {
    updateVesselDetailHeader(UserID);
  }
  
  // Attach copy link event.
  const copyLinkEl = document.getElementById('copy-link');
  if (copyLinkEl) {
    copyLinkEl.addEventListener('click', (e) => {
      if (e && typeof e.stopPropagation === 'function') {
        e.stopPropagation();
      }
      const currentUrl = window.location.href.split('?')[0];
      const copyUrl = `${currentUrl}?UserID=${vesselData[UserID].UserID}`;
      function updateLinkText(newText) {
        copyLinkEl.textContent = newText;
        setTimeout(() => {
          copyLinkEl.textContent = "Link";
        }, 2000);
      }
      if (navigator.clipboard && navigator.clipboard.writeText) {
        navigator.clipboard.writeText(copyUrl).then(() => {
          updateLinkText("Link Copied");
        }).catch(err => {
          console.error("Failed to copy: ", err);
        });
      } else {
        const textArea = document.createElement("textarea");
        textArea.value = copyUrl;
        document.body.appendChild(textArea);
        textArea.select();
        try {
          document.execCommand('copy');
          updateLinkText("Link Copied");
        } catch (err) {
          console.error("Fallback: Unable to copy", err);
        }
        document.body.removeChild(textArea);
      }
    });
  }
  




// Helper function to show flash message
function showFlashMessage(message, parentEl) {
  const flashMsg = document.createElement('span');
  flashMsg.textContent = ` ${message}`;
  flashMsg.style.color = 'green';
  parentEl.appendChild(flashMsg);
  setTimeout(() => {
    flashMsg.remove();
  }, 1000);
}


         // Update the Live Logs modal title with the vessel name.
         const liveLogsTitle = document.getElementById('live-logs-title');
         if (vesselData[UserID].Name) {
           liveLogsTitle.textContent = `${vesselData[UserID].Name}`;
         } else {
           liveLogsTitle.textContent = 'Live Messages';
         }
          const detailContent = createDetailContent(vesselData[UserID]);
          document.getElementById('detail-content').innerHTML = detailContent;

	  // Fetch missing data from /state/<UserID> and update overlay.
	  fetchMissingData(UserID);

	if (initialFocus) {
	  const markerLatLng = vesselMarkers[UserID].getLatLng();
	  const currentZoom = map.getZoom();
	  const desiredZoom = 13;
  
	  if (currentZoom >= desiredZoom) {
	    // If already zoomed in enough, just pan to the vessel's location.
	    map.panTo(markerLatLng);
	  } else {
	    // Otherwise, fit bounds and set the zoom to desiredZoom at most.
	    let bounds = L.latLngBounds([]);
	    bounds.extend(markerLatLng);
	    map.fitBounds(bounds, { padding: [50, 50], maxZoom: desiredZoom });
	  }
	}

          updateFocussedVisibility();
        }

        document.getElementById('toggle-known-overlay').addEventListener('click', function() {
          const overlay = document.getElementById('vessel-overlay');
          const currentDisplay = window.getComputedStyle(overlay).display;
          if (currentDisplay === 'none') {
            overlay.style.display = 'block';
            this.textContent = 'Hide Vessels';
	    const filterInput = document.getElementById('vessel-filter');
	    if (filterInput.value.trim().length >= 3) {
	      filterInput.dispatchEvent(new Event('input'));
	    }
          } else {
            overlay.style.display = 'none';
            this.textContent = 'Show Vessels';
          }
        });

        document.getElementById('toggle-detail-overlay').addEventListener('click', function() {
          const detailOverlay = document.getElementById('vessel-detail');
          if (detailOverlay.style.display === 'none' || detailOverlay.style.display === '') {
            detailOverlay.style.display = 'block';
            this.textContent = 'Hide Details';
            detailsOverlayHidden = false;
          } else {
            detailOverlay.style.display = 'none';
            this.textContent = 'Show Details';
            detailsOverlayHidden = true;
          }
       });

    const liveLogFilters = {
      "PositionReport": true,
      "ShipStaticData": true,
      "StaticDataReport": true,
      "StandardClassBPositionReport": true,
      "ExtendedClassBPositionReport": true,
      "AidsToNavigationReport": true,
      "BaseStationReport": true,
      "BinaryBroadcastMessage": true,
      "StandardSearchAndRescueAircraftReport": true
    };

    document.querySelectorAll('.log-filter').forEach(checkbox => {
      checkbox.addEventListener('change', function() {
        liveLogFilters[this.value] = this.checked;
        applyLogFilters();  // Use the new filter state in your live logs
      });
    });

       document.getElementById('stats-button').addEventListener('click', () => {
         if (focusedVessel) {
           // Open popup window with the current vessel's UserID.
           window.open('/stats.html?UserID=' + focusedVessel, '_blank', 'width=400,height=600');
         }
       });

window.addEventListener('load', () => {
  // Get URL parameters and check for the UserID parameter.
  const params = new URLSearchParams(window.location.search);
  const UserIDParam = params.get('UserID');
  const skipUserZoom = Boolean(UserIDParam);

  const filterInput = document.getElementById('vessel-filter');
  if (filterInput.value.trim().length >= 3) {
    filterInput.dispatchEvent(new Event('input'));
  }

  // If UserID is provided, fetch the state and center the map accordingly.
  if (UserIDParam) {
    fetch(`/state/${UserIDParam}`)
      .then(response => {
        if (!response.ok) {
          throw new Error(`Network error: ${response.status}`);
        }
        return response.json();
      })
      .then(data => {
        const userSummary = data;

        // Validate that the summary contains valid Latitude and Longitude fields.
        if (userSummary && typeof userSummary.Latitude === 'number' && typeof userSummary.Longitude === 'number') {
          // Center the map on these coordinates; adjust the zoom level as needed.
          map.setView([userSummary.Latitude, userSummary.Longitude], 10);
        } else {
          console.warn('Summary data is missing valid latitude and longitude fields.');
        }
      })
      .catch(error => {
        console.error('Error fetching summary:', error);
      });
  }

  updateStationaryMarkers();
  if (navigator.geolocation) {
    navigator.geolocation.getCurrentPosition(
      (position) => {
        userLatLng = [position.coords.latitude, position.coords.longitude];
        const userMarker = L.marker(userLatLng, { draggable: true })
          .addTo(map)

      userMarker.on('dragend', function(e) {
        const newPos = e.target.getLatLng();
        userLatLng = [newPos.lat, newPos.lng];
        document.getElementById('latlong-display').textContent =
          `${newPos.lat.toFixed(5)}, ${newPos.lng.toFixed(5)}`;
      });        

        if (!skipUserZoom) {
          map.setView(userLatLng, 10);
        }

        // Allow some time for vessel markers to load or update
        setTimeout(() => {
          const bounds = map.getBounds();
          let vesselFound = false;
          let firstVesselLatLng = null;

          // Assume vesselMarkers is a global object containing your vessel markers
          for (const key in vesselMarkers) {
            if (vesselMarkers.hasOwnProperty(key)) {
              const marker = vesselMarkers[key];
              const markerLatLng = marker.getLatLng();
              if (!firstVesselLatLng) {
                firstVesselLatLng = markerLatLng; // store the first vessel position found
              }
              if (bounds.contains(markerLatLng)) {
                vesselFound = true;
                break;
              }
            }
          }

          // If no vessel marker is found in the current viewport and we have at least one vessel marker...
          if (!vesselFound && firstVesselLatLng) {
            // Create a bounds that includes both the user's location and the vessel marker
            const newBounds = L.latLngBounds([userLatLng, firstVesselLatLng]);
            // Fit the map to the new bounds with some padding
            map.fitBounds(newBounds, { padding: [50, 50] });
          }
        }, 1000); // 1 second delay; adjust if necessary
      },
      (error) => {
        debouncedAdjustMapBounds();
        map.fire('moveend');
      }
    );
  } else {
    debouncedAdjustMapBounds();
    map.fire('moveend');
  }

 refreshReceivers();
 setInterval(refreshReceivers, 60000);

  if (UserIDParam) {
    // Delay the focus call to allow vessel markers to load
    setTimeout(() => {
      if (vesselMarkers[UserIDParam]) {
        focusOnVessel(UserIDParam);
      } else {
        console.warn(`Vessel with UserID ${UserIDParam} not found.`);
      }
    }, 1500);
  }
});

document.getElementById('show-paths').addEventListener('change', function() {
  const showPaths = this.checked;
  const onlyFocussed = document.getElementById('only-focussed').checked;
  if (onlyFocussed && focusedVessel) {
    // Only toggle the focused vessel's track.
    if (vesselTracks[focusedVessel]) {
      if (showPaths && !map.hasLayer(vesselTracks[focusedVessel])) {
        map.addLayer(vesselTracks[focusedVessel]);
      } else if (!showPaths && map.hasLayer(vesselTracks[focusedVessel])) {
        map.removeLayer(vesselTracks[focusedVessel]);
      }
    }
  } else {
    // Toggle tracks for all vessels.
    for (const userid in vesselTracks) {
      if (showPaths && !map.hasLayer(vesselTracks[userid])) {
        map.addLayer(vesselTracks[userid]);
      } else if (!showPaths && map.hasLayer(vesselTracks[userid])) {
        map.removeLayer(vesselTracks[userid]);
      }
    }
  }
  updateFocussedVisibility();
});



// Conversion: 1 nautical mile = 1852 meters.
function updateNauticalScale() {
  const scaleLabel = document.getElementById('scale-label');
  const scalePx = 100;
  const center = map.getCenter();
  const point = map.latLngToContainerPoint(center);
  const pointX = L.point(point.x + scalePx, point.y);
  const latLngX = map.containerPointToLatLng(pointX);
  const distanceMeters = center.distanceTo(latLngX);
  const distanceNM = distanceMeters / 1852;
  scaleLabel.textContent = `${distanceNM.toFixed(1)} NM`;
}

// Update the scale whenever the map is zoomed or moved.
map.on('zoomend moveend', updateNauticalScale);
// Call once to set the initial scale.
updateNauticalScale();

function updateFocussedTooltip() {
  if (focusedVessel && vesselData[focusedVessel]) {
    const vessel = vesselData[focusedVessel];
    const line1 = buildTooltipLine(
      vessel.Destination,
      (navigationalStatusMapping[vessel.NavigationalStatus] || vessel.NavigationalStatus) !== 'Unknown'
        ? (navigationalStatusMapping[vessel.NavigationalStatus] || vessel.NavigationalStatus)
        : null
    );
   // Tooltip “Type” field: use AtoN mapping when appropriate
   const ttMapping = (vessel.AISClass === "AtoN")
     ? staticAtoNTypeMapping
     : staticTypeMapping;
   const ttTypeText = ttMapping[vessel.Type] || vessel.Type;
   const line2 = buildTooltipLine(
     ttTypeText,
     (vessel.MaximumStaticDraught != null ? `${vessel.MaximumStaticDraught} m` : null),
     (vessel.Sog != null                     ? `${vessel.Sog} kn`                  : null),
     (vessel.TrueHeading != null && vessel.TrueHeading < 360
       ? `${vessel.TrueHeading}°`
       : `${vessel.Cog}°`)
   );

    const tooltipLines = [`${vessel.Name}${vessel.CallSign ? ` (${vessel.CallSign})` : ''}`];
    if (line1.trim()) tooltipLines.push(line1);
    if (line2.trim()) tooltipLines.push(line2);
    tooltipLines.push(timeAgo(vessel.lastUpdate));
    const newTooltipContent = tooltipLines.join('<br>');
    vesselMarkers[focusedVessel].getTooltip().setContent(newTooltipContent);
  }
}
setInterval(updateFocussedTooltip, 1000);


// Call updateLegend periodically to keep the legend up to date
setInterval(updateLegend, 5000); // Update every 5 seconds

document.getElementById('toggle-legend').addEventListener('click', function() {
  const legend = document.getElementById('vessel-legend');
  if (window.getComputedStyle(legend).display === 'none') {
    legend.style.display = 'block';  // Make it visible first
    updateLegend();                  // Then update the content immediately
    this.textContent = 'Hide Legend';
  } else {
    legend.style.display = 'none';
    this.textContent = 'Show Legend';
  }
});



    document.getElementById('live-log-search').addEventListener('input', applyLogFilters);

const ageSlider = document.getElementById('age-slider');
const ageValueDisplay = document.getElementById('age-value');
let ageDebounceTimer = null;

const historySlider = document.getElementById('history-slider');
const historyValueDisplay = document.getElementById('history-value');
historySlider.addEventListener('input', () => {
  historyValueDisplay.textContent = historySlider.value;
});

document.addEventListener("DOMContentLoaded", function() {

  const savedBasemap = localStorage.getItem('selectedBasemap');

  if (savedBasemap) {
    // Remove any default layer if needed.
    // (Here googleSat is added as default; you might want to remove it if the saved layer is different.)
    if (savedBasemap === "OSM") {
      // Remove the default Google layer (if it's on the map)
      if (map.hasLayer(googleSat)) {
        map.removeLayer(googleSat);
      }
      // Add the OSM layer.
      osm.addTo(map);
    } else if (savedBasemap === "Google") {
      if (map.hasLayer(osm)) {
        map.removeLayer(osm);
      }
      googleSat.addTo(map);
    }
    if (map.hasLayer(openSeaMapLayer)) {
      openSeaMapLayer.bringToFront();
    }
  }

  // History slider elements
  const historySlider = document.getElementById("history-slider");
  const historyValueDisplay = document.getElementById("history-value");
  
  // Age slider elements
  const ageSlider = document.getElementById("age-slider");
  const ageValueDisplay = document.getElementById("age-value");
  
  // Load saved history slider value if available
  const savedHistory = localStorage.getItem("historySliderValue");
  if (savedHistory !== null) {
    historySlider.value = savedHistory;
    historyValueDisplay.textContent = savedHistory;
  }
  
  // Load saved age slider value if available
  const savedAge = localStorage.getItem("ageSliderValue");
  if (savedAge !== null) {
    ageSlider.value = savedAge;
    ageValueDisplay.textContent = savedAge;
  }
  
  // Save new history slider value on input
  historySlider.addEventListener("input", () => {
    const currentValue = historySlider.value;
    historyValueDisplay.textContent = currentValue;
    localStorage.setItem("historySliderValue", currentValue);
  });
  
  // Save new age slider value on input
  ageSlider.addEventListener("input", () => {
    const currentValue = ageSlider.value;
    ageValueDisplay.textContent = currentValue;
    localStorage.setItem("ageSliderValue", currentValue);
  });
});

let historyDebounceTimer = null;
document.getElementById("history-slider").addEventListener("input", () => {
  const historyHours = parseInt(document.getElementById("history-slider").value, 10);
  historyValueDisplay.textContent = historyHours;
  
  const now = Date.now();
  // Immediately update the polyline tracks for all vessels using the new slider value.
for (let UserID in vesselData) {
  if (vesselData[UserID].track) {
    const filteredTrack = vesselData[UserID].track.filter(pt => {
      const pointTime = new Date(pt[0]).getTime();
      return (now - pointTime) <= historyHours * 3600000;
    });
    // Remove the old track layer (if it exists)
    if (vesselTracks[UserID]) {
      map.removeLayer(vesselTracks[UserID]);
    }
    // Create a new colored track layer using createColoredTrack
    if (document.getElementById('show-paths').checked) {
         vesselTracks[UserID] = createColoredTrack(filteredTrack);
         map.addLayer(vesselTracks[UserID]);
         attachPolylineEvents(vesselTracks[UserID], UserID);
    }
  }
}

  
  // Debounce the fetch for additional history data for the focused vessel.
  clearTimeout(historyDebounceTimer);
  historyDebounceTimer = setTimeout(() => {
    if (focusedVessel) {
      hydrateTrackHistory(focusedVessel);
    }
  }, 500); // Adjust debounce delay as needed.
});

document.getElementById('modal-close').addEventListener('click', closeImageModal);
document.getElementById('image-modal-overlay').addEventListener('click', function(e) {
  // If the click is on the overlay (not the content), close the modal.
  if (e.target === this) {
    closeImageModal();
  }
});

document.getElementById("age-slider").addEventListener("input", () => {
  const ageHours = parseInt(ageSlider.value, 10);  // Get the value of the age slider in hours.
  ageValueDisplay.textContent = ageHours;  // Display the selected value.

  // Debounce the filtering process to avoid excessive function calls.
  clearTimeout(ageDebounceTimer);
  ageDebounceTimer = setTimeout(() => {
    sendSummaryRequest();
    updateOverlay();  // Update the vessel overlay count
  }, 500);  // Adjust the debounce delay as needed.
});

map.on('zoomend', function() {
  const currentZoom = map.getZoom();
  for (const userid in vesselMarkers) {
    let marker = vesselMarkers[userid];
    // Focused vessel: update icon and tooltip based on the current zoom.
    if (userid === focusedVessel?.toString()) {
      if (currentZoom >= TOOLTIP_ZOOM_THRESHOLD) {
        marker.bindTooltip(vesselData[userid].Name, {
          permanent: true,
          direction: 'top',
          className: 'vessel-tooltip'
        }).openTooltip();
      } else {
        marker.unbindTooltip();
      }
      // Always use the detailed icon logic (which itself checks zoom level)
      marker.setIcon(getVesselIcon(vesselData[userid]));
    } else {
      // For non-focused vessels:
      if (currentZoom < 10) {
        // When zoom level is below 10, show simple circle markers and no tooltips.
        marker.unbindTooltip();
        marker.setIcon(createCircleIcon(vesselData[userid]));
      } else if (currentZoom < TOOLTIP_ZOOM_THRESHOLD) {
        // At zoom levels between 10 and 11.99, show the detailed icon but no tooltip.
        marker.unbindTooltip();
        marker.setIcon(getVesselIcon(vesselData[userid]));
      } else {
        // At zoom levels 12 and above, add tooltips and detailed icons.
        marker.bindTooltip(vesselData[userid].Name, {
          permanent: true,
          direction: 'top',
          className: 'vessel-tooltip'
        }).openTooltip();
        marker.setIcon(getVesselIcon(vesselData[userid]));
      }
    }
  }
});


const debouncedSendSummaryRequest = debounce(sendSummaryRequest, 250);
map.on("moveend", debouncedSendSummaryRequest);

        // Utility: Generate a random hex color.
        function randomColor() {
          return '#' + Math.floor(Math.random() * 16777215).toString(16).padStart(6, '0');
        }



    </script>
</body>

</html>
