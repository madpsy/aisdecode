<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8"/>
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>AIS Message History Viewer</title>
  <style>
    body { font-family: sans-serif; margin: 2rem; }
    .error { color: red; font-weight: bold; }

    .message { margin-bottom: 2rem; padding: 1rem; border: 1px solid #ddd; border-radius: 4px; }
    .title { font-size: 1.1rem; font-weight: bold; margin-bottom: 0.3rem; }
    .title-details {
      font-weight: normal; font-size: 0.9rem;
      margin-top: 0.2rem; margin-bottom: 0.5rem; color: #555;
    }

    .message .time-controls {
      display: flex; flex-wrap: wrap; gap: 1rem; align-items: flex-start;
      margin-bottom: 0.6rem; font-size: 0.9rem;
    }
    .message .time-controls label {
      display: flex; flex-direction: column;
      flex: 1 1 150px;
    }
    .message .time-controls select,
    .message .time-controls input {
      min-width: 100%;
    }
    .message .time-controls button {
      background: none; border: none;
      font-size: 1.2rem; cursor: pointer;
      flex: 0 0 auto; margin-top: 1.2rem;
      transition: opacity 0.2s;
    }
    .message .time-controls button:disabled {
      color: #bbb; cursor: default; opacity: 0.4;
    }

    .nav { display: flex; align-items: center; margin-bottom: 0.8rem; }
    .nav button {
      background: none; border: none;
      font-size: 1.2rem; margin: 0 0.3rem;
      cursor: pointer; transition: opacity 0.2s;
    }
    .nav button:disabled { color: #bbb; cursor: default; opacity: 0.4; }
    .nav .counter { font-size: 0.9rem; color: #333; min-width: 3em; text-align: center; }

    table {
      border-collapse: collapse; table-layout: auto;
      white-space: nowrap; width: 100%;
    }
    th, td {
      border: 1px solid #ccc; padding: 0.4rem 0.6rem;
      text-align: left; vertical-align: top;
    }
    th { background: #f0f0f0; }

    .raw-sentence {
      margin-top: 0.5rem;
      padding: 0.5rem;
      background: #f9f9f9;
      border: 1px solid #eee;
      border-radius: 4px;
      font-family: monospace;
      white-space: pre-wrap;
    }
  </style>
</head>
<body>
  <div class="message">
    <div class="title" id="main-title">Loading…</div>
    <div class="title-details" id="sub-title"></div>
    <div id="error" class="error"></div>
  </div>

  <div class="message time-controls">
    <label>
      From
      <input type="datetime-local" id="start"/>
    </label>
    <label>
      To
      <input type="datetime-local" id="end"/>
    </label>
    <label>
      Fields
      <select multiple size="4" id="fields"></select>
    </label>
    <button id="apply">Show Range</button>
    <button id="reset">Reset</button>
  </div>

  <div id="individual-view">
    <div class="nav">
      <button id="prev">◀️</button>
      <div class="counter" id="counter">0 of 0</div>
      <button id="next">▶️</button>
    </div>
    <div id="single-table"></div>
    <div class="raw-sentence" id="single-raw"></div>
  </div>

  <div id="range-view" style="display:none;">
    <div id="range-table"></div>
  </div>

  <script>
    // Query-string helper
    function qsParam(name) {
      const v = new URLSearchParams(window.location.search).get(name);
      return v && /^\d+$/.test(v) ? v : null;
    }

    // Flatten nested objects
    function flatten(obj, prefix = '', res = {}) {
      for (const [k, v] of Object.entries(obj || {})) {
        const key = prefix ? `${prefix}.${k}` : k;
        if (v != null && typeof v === 'object' && !Array.isArray(v)) {
          flatten(v, key, res);
        } else {
          res[key] = v;
        }
      }
      return res;
    }

    function humanize(field) {
      return field.replace(/[_\.]/g, ' ');
    }

    // Make HTML for individual-message table
    function makeSingleHTML(msg) {
      const flat = flatten(msg.Packet);
      let html = '<table><thead><tr><th>Field</th><th>Value</th></tr></thead><tbody>';
      Object.keys(flat).sort().forEach(k => {
        html += `<tr><td>${humanize(k)}</td><td>${flat[k]}</td></tr>`;
      });
      return html + '</tbody></table>';
    }

    // Make HTML for range table
    function makeRangeHTML(rows, fields) {
      let html = '<table><thead><tr><th>Timestamp</th>';
      fields.forEach(f => html += `<th>${humanize(f)}</th>`);
      html += '<th>Sentences</th></tr></thead><tbody>';
      rows.forEach((r, i) => {
        const flat = flatten(r.Packet);
        html += '<tr>';
        html += `<td>${new Date(r.Timestamp).toLocaleString([], {hour12:false})}</td>`;
        fields.forEach(f => {
          html += `<td>${flat[f] != null ? flat[f] : ''}</td>`;
        });
        html += `<td><button class="view" data-i="${i}">View</button></td>`;
        html += '</tr>';
      });
      return html + '</tbody></table>';
    }

    (async () => {
      const userID = qsParam('UserID'),
            msgID  = qsParam('MessageID'),
            errEl  = document.getElementById('error'),
            mainT  = document.getElementById('main-title'),
            subT   = document.getElementById('sub-title');

      if (!userID || !msgID) {
        mainT.textContent = 'Error';
        errEl.textContent = 'URL must include numeric UserID and MessageID.';
        return;
      }

      // Fetch vessel name
      try {
        const res = await fetch(`/summary?UserID=${userID}`, { cache: 'no-store' });
        const summary = await res.json();
        const vessel = summary[userID]?.Name.trim() || userID;
        mainT.textContent = `History for ${vessel}`;
      } catch {
        mainT.textContent = `History for ${userID}`;
      }

      // Fetch message types
      let typeMap = {};
      try {
        const r = await fetch('/message_types.json', { cache: 'no-store' });
        typeMap = await r.json();
      } catch {}

      subT.textContent = `${typeMap[msgID] || 'Message ' + msgID} (ID ${msgID})`;

      // Fetch last 100 messages
      let allMsgs = [];
      try {
        const r = await fetch(`/latestmessages?UserID=${userID}&MessageID=${msgID}&limit=100`, { cache: 'no-store' });
        allMsgs = await r.json();
      } catch {
        errEl.textContent = 'Failed to load messages.';
        return;
      }
      if (!allMsgs.length) {
        errEl.textContent = 'No messages found.';
        return;
      }

      // Populate numeric fields selector
      const firstFlat = flatten(allMsgs[0].Packet),
            numeric   = Object.entries(firstFlat)
              .filter(([,v]) => typeof v === 'number')
              .map(([k]) => k)
              .sort(),
            fieldsSel = document.getElementById('fields');
      numeric.forEach(f => {
        const o = document.createElement('option');
        o.value = f;
        o.textContent = humanize(f);
        fieldsSel.append(o);
      });

      // Individual view setup
      let idx = 0;
      const prevB    = document.getElementById('prev'),
            nextB    = document.getElementById('next'),
            counter  = document.getElementById('counter'),
            singleT  = document.getElementById('single-table'),
            singleR  = document.getElementById('single-raw');

      function renderIndividual() {
        const msg = allMsgs[idx];
        counter.textContent = `${idx+1} of ${allMsgs.length}`;
        singleT.innerHTML   = makeSingleHTML(msg);
        singleR.textContent = msg.RawSentence;
        prevB.disabled = idx === 0;
        nextB.disabled = idx === allMsgs.length - 1;
      }
      prevB.onclick = () => idx>0 && (idx--, renderIndividual());
      nextB.onclick = () => idx<allMsgs.length-1 && (idx++, renderIndividual());
      renderIndividual();

      // Range view logic
      const applyB = document.getElementById('apply'),
            resetB = document.getElementById('reset'),
            indV   = document.getElementById('individual-view'),
            rngV   = document.getElementById('range-view'),
            rngT   = document.getElementById('range-table');

      applyB.onclick = async () => {
        const s   = document.getElementById('start').value,
              e   = document.getElementById('end').value,
              sel = Array.from(fieldsSel.selectedOptions).map(o => o.value);

        if (!s || !e || !sel.length) {
          alert('Please select From, To, and at least one field.');
          return;
        }

        const params = new URLSearchParams({
          UserID: userID,
          MessageID: msgID,
          start: new Date(s).toISOString(),
          end:   new Date(e).toISOString(),
          limit: '100'
        });

        let data = [];
        try {
          const r = await fetch(`/latestmessages?${params}`, { cache: 'no-store' });
          data = await r.json();
        } catch {
          alert('Failed to fetch range.');
          return;
        }

        rngT.innerHTML = data.length
          ? makeRangeHTML(data, sel)
          : '<p>No records in that range.</p>';

        // Wire up each "View" button
        rngT.querySelectorAll('button.view').forEach(btn => {
          btn.onclick = () => alert(data[btn.dataset.i].RawSentence);
        });

        indV.style.display = 'none';
        rngV.style.display = '';
      };

      resetB.onclick = () => {
        document.getElementById('start').value = '';
        document.getElementById('end').value   = '';
        fieldsSel.selectedIndex = -1;
        rngT.innerHTML = '';
        rngV.style.display = 'none';
        indV.style.display = '';
      };
    })();
  </script>
</body>
</html>
