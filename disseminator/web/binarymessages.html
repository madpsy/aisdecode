<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>AIS Latest Messages Viewer</title>
  <style>
    body { font-family: sans-serif; margin: 2rem; }
    .error { color: red; font-weight: bold; }
    .message { margin-bottom: 2rem; padding: 1rem; border: 1px solid #ddd; border-radius: 4px; }
    .title { font-size: 1.1rem; font-weight: bold; margin-bottom: 0.3rem; }
    .ts { font-size: 0.9rem; color: #555; margin-bottom: 0.3rem; }
    .nav { display: flex; align-items: center; margin-bottom: 0.8rem; }
    .nav button {
      background: none;
      border: none;
      font-size: 1.2rem;
      margin: 0 0.3rem;
      cursor: pointer;
      transition: opacity 0.2s;
    }
    .nav button:disabled {
      color: #bbb;
      cursor: default;
      opacity: 0.4;
    }
    .nav .counter {
      font-size: 0.9rem;
      color: #333;
      min-width: 3em;
      text-align: center;
    }
    .table-container { overflow-x: auto; }
    table {
      border-collapse: collapse;
      table-layout: auto;
      margin-top: 0.5rem;
      white-space: nowrap;
    }
    th, td {
      border: 1px solid #ccc;
      padding: 0.4rem 0.6rem;
      text-align: left;
      vertical-align: top;
    }
    th { background: #f0f0f0; }
    .message .chart-container {
      position: relative;
      width: 100%;
      height: 300px;
      margin-top: 1rem;
    }
    .message .chart-container canvas {
      width: 100% !important;
      height: 100% !important;
    }
    .no-binary { font-style: italic; color: #a00; margin: 0.5rem 0; }
  </style>

  <!-- Chart.js and date adapter for time scales -->
  <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/chartjs-adapter-date-fns"></script>
  <!-- Zoom & Pan plugin for Chart.js -->
  <script src="https://cdn.jsdelivr.net/npm/chartjs-plugin-zoom"></script>
</head>
<body>

  <h1 id="main-title">Loading vessel…</h1>
  <label style="display:block; margin-bottom:1rem;">
    <input type="checkbox" id="auto-refresh-checkbox"> Auto Refresh (60s)
  </label>
  <div id="output">Loading messages…</div>

  <script>
    Chart.register(ChartZoom);
    Chart.defaults.elements.point.radius = 1;

    // Map of blocks keyed by "MessageID|DAC|FI"
    const messageBlocks = new Map();
    let autoRefreshIntervalId = null;

    function getUserID() {
      const v = new URLSearchParams(window.location.search).get('UserID');
      return v && /^\d+$/.test(v) ? v : null;
    }

    function flattenObject(obj, parentKey = '', res = {}) {
      for (const [k, v] of Object.entries(obj)) {
        const nk = parentKey ? `${parentKey}.${k}` : k;
        if (v != null && typeof v === 'object' && !Array.isArray(v)) {
          flattenObject(v, nk, res);
        } else {
          res[nk] = v;
        }
      }
      return res;
    }

    function humanizeField(field) {
      return field.replace(/[_\.]/g, ' ');
    }

    function makeTableHTML(data) {
      return `
        <table>
          <thead><tr><th>Field</th><th>Value</th></tr></thead>
          <tbody>
            ${Object.entries(data).map(([f, v]) =>
              `<tr>
                <td>${humanizeField(f)}</td>
                <td>${String(v)}</td>
              </tr>`
            ).join('')}
          </tbody>
        </table>`;
    }

    async function fetchAndRender(block) {
      const { userID, msgID, dac, fi, asm, initialMsg } = block;
      const url =
        `/latestmessages?UserID=${userID}` +
        `&MessageID=${msgID}&DAC=${dac}&FI=${fi}&limit=100` +
        `&t=${Date.now()}`;
      let arr = [];
      try {
        const res = await fetch(url, { cache: 'no-store' });
        if (res.ok) arr = await res.json();
      } catch (e) {
        console.error('[AutoRefresh] fetch error', e);
      }

      // Keep only decoded packets
      const history = arr
        .filter(m => m.Packet?.DecodedBinary)
        .sort((a, b) => new Date(b.Timestamp) - new Date(a.Timestamp));

      // If none decoded, still show the initial message
      block.history = history.length ? history : [initialMsg];

      if (!block.dom) createBlockDOM(block);
      updateBlockDOM(block);
    }

    function createBlockDOM(block) {
      const c = document.createElement('div');
      c.className = 'message';
      block.dom = {};

      // Title
      const titleDiv = document.createElement('div');
      titleDiv.className = 'title';
      c.appendChild(titleDiv);
      block.dom.titleDiv = titleDiv;

      // Timestamp
      const tsDiv = document.createElement('div');
      tsDiv.className = 'ts';
      c.appendChild(tsDiv);
      block.dom.tsDiv = tsDiv;

      // Nav
      const nav = document.createElement('div');
      nav.className = 'nav';
      c.appendChild(nav);
      block.dom.nav = nav;

      const btnNewer = document.createElement('button');
      btnNewer.textContent = '◀️';
      nav.appendChild(btnNewer);
      block.dom.btnNewer = btnNewer;

      const counter = document.createElement('div');
      counter.className = 'counter';
      nav.appendChild(counter);
      block.dom.counter = counter;

      const btnOlder = document.createElement('button');
      btnOlder.textContent = '▶️';
      nav.appendChild(btnOlder);
      block.dom.btnOlder = btnOlder;

      btnNewer.onclick = () => {
        if (block.idx > 0) {
          block.idx--;
          updateBlockDOM(block);
        }
      };
      btnOlder.onclick = () => {
        if (block.idx < block.history.length - 1) {
          block.idx++;
          updateBlockDOM(block);
        }
      };

      // "not decoded" notice
      const notice = document.createElement('div');
      notice.className = 'no-binary';
      c.appendChild(notice);
      block.dom.notice = notice;

      // Table container
      const tableContainer = document.createElement('div');
      tableContainer.className = 'table-container';
      c.appendChild(tableContainer);
      block.dom.tableContainer = tableContainer;

      // Chart container
      const chartWrapper = document.createElement('div');
      chartWrapper.className = 'chart-container';
      const canvas = document.createElement('canvas');
      chartWrapper.appendChild(canvas);
      c.appendChild(chartWrapper);
      block.dom.chartWrapper = chartWrapper;
      block.dom.canvas = canvas;

      document.getElementById('output').appendChild(c);
    }

    function updateBlockDOM(block) {
      const { dom, asm, history, idx, msgID, dac, fi } = block;
      const msg = history[idx];
      const hasBinary = !!msg.Packet?.DecodedBinary;

      // Title with raw IDs
      const titleText = asm[msgID]?.[dac]?.[fi]?.Title || 'Unknown message type';
      dom.titleDiv.textContent = `${titleText} (ID ${msgID}, DAC ${dac}, FI ${fi})`;

      if (!hasBinary) {
        // Show only notice
        dom.notice.textContent = 'Binary data not decoded for this message type.';
        dom.tsDiv.style.display = 'none';
        dom.nav.style.display = 'none';
        dom.tableContainer.style.display = 'none';
        dom.chartWrapper.style.display = 'none';
        return;
      }

      // Clear notice, show UI
      dom.notice.textContent = '';
      dom.tsDiv.style.display = '';
      dom.nav.style.display = 'flex';
      dom.tableContainer.style.display = '';
      dom.chartWrapper.style.display = '';

      // Timestamp & nav
      dom.tsDiv.textContent = new Date(msg.Timestamp).toLocaleString([], {
        hour12: false,
        year: 'numeric', month: '2-digit', day: '2-digit',
        hour: '2-digit', minute: '2-digit', second: '2-digit'
      });
      dom.btnNewer.disabled = idx === 0;
      dom.btnOlder.disabled = idx === history.length - 1;
      dom.counter.textContent = `${idx + 1} of ${history.length}`;

      // Table
      dom.tableContainer.innerHTML = makeTableHTML(
        flattenObject(msg.Packet.DecodedBinary)
      );

      // Chart
      const records = history.map(m => flattenObject(m.Packet.DecodedBinary));
      const times   = history.map(m => new Date(m.Timestamp));
      const fields  = Object.keys(records[0] || {}).filter(f => typeof records[0][f] === 'number');
      const defaultVis = new Set(fields.slice(0, 3));

      if (!block.chart) {
        const datasets = fields.map(f => ({
          label: humanizeField(f),
          data: times.map((t, i) => ({ x: t, y: records[i][f] })),
          borderWidth: 1,
          hidden: !defaultVis.has(f),
          _fieldKey: f
        }));
        block.chart = new Chart(dom.canvas.getContext('2d'), {
          type: 'line',
          data: { datasets },
          options: {
            animation: false,
            maintainAspectRatio: false,
            scales: {
              x: {
                type: 'time',
                time: {
                  tooltipFormat: 'HH:mm:ss',
                  displayFormats: { hour: 'HH:mm', minute: 'HH:mm' }
                },
                ticks: { autoSkip: true, maxRotation: 0 }
              },
              y: { beginAtZero: false }
            },
            plugins: {
              legend: { position: 'bottom', labels: { boxWidth: 8, padding: 8, font: { size: 10 } } },
              tooltip: { mode: 'index', intersect: false },
              zoom: {
                pan: { enabled: true, mode: 'x' },
                zoom: {
                  wheel: { enabled: true },
                  drag: { enabled: true, backgroundColor: 'rgba(54,162,235,0.3)' },
                  pinch: { enabled: true },
                  mode: 'x',
                  doubleClickReset: true
                }
              }
            },
            interaction: { mode: 'nearest', axis: 'x', intersect: false }
          }
        });
        dom.canvas.addEventListener('dblclick', () => block.chart.resetZoom());
      } else {
        const oldDs = block.chart.data.datasets;
        const newDs = fields.map(f => {
          const ex = oldDs.find(d => d._fieldKey === f);
          if (ex) {
            ex.data = times.map((t, i) => ({ x: t, y: records[i][f] }));
            return ex;
          }
          return {
            label: humanizeField(f),
            data: times.map((t, i) => ({ x: t, y: records[i][f] })),
            borderWidth: 1,
            hidden: !defaultVis.has(f),
            _fieldKey: f
          };
        });
        block.chart.data.datasets = newDs;
        block.chart.update();
      }
    }

    function runRefresh() {
      for (const b of messageBlocks.values()) {
        fetchAndRender(b);
      }
    }

    // Auto-refresh checkbox
    const autoCB = document.getElementById('auto-refresh-checkbox');
    if (localStorage.getItem('autoRefreshEnabled') === 'true') {
      autoCB.checked = true;
      runRefresh();
      autoRefreshIntervalId = setInterval(runRefresh, 60000);
    }
    autoCB.addEventListener('change', e => {
      localStorage.setItem('autoRefreshEnabled', e.target.checked);
      if (e.target.checked) {
        runRefresh();
        autoRefreshIntervalId = setInterval(runRefresh, 60000);
      } else {
        clearInterval(autoRefreshIntervalId);
      }
    });

    async function main() {
      const userID = getUserID();
      const titleEl = document.getElementById('main-title');
      const output  = document.getElementById('output');
      if (!userID) {
        titleEl.textContent = 'Error';
        output.innerHTML = '<div class="error">Invalid or missing numeric UserID parameter.</div>';
        return;
      }

      // Load summary
      let summary;
      try {
        const r = await fetch(`/summary?UserID=${userID}`);
        if (!r.ok) throw '';
        summary = await r.json();
      } catch {
        titleEl.textContent = 'Error';
        output.innerHTML = '<div class="error">Failed to load summary</div>';
        return;
      }
      const info = summary[userID] || {};
      titleEl.textContent = `Latest Messages for ${info.Name?.trim() ? info.Name : userID}`;

      // Load ASM
      let asm;
      try {
        const r = await fetch('/asm.json');
        if (!r.ok) throw '';
        asm = await r.json();
      } catch {
        output.innerHTML = '<div class="error">Failed to load asm.json</div>';
        return;
      }

      // Fetch all latest messages
      let allMsgs;
      try {
        const r = await fetch(`/latestmessages?UserID=${userID}`);
        if (r.status !== 200) throw '';
        allMsgs = await r.json();
      } catch {
        output.innerHTML = '<div class="error">Vessel Not Found</div>';
        return;
      }

      // Only show blocks for messages where ApplicationID.Valid===true
      const validMsgs = allMsgs.filter(m => m.Packet?.ApplicationID?.Valid);
      if (!validMsgs.length) {
        output.innerHTML = '<div>No valid message types available.</div>';
        return;
      }

      // Build blocks
      output.innerHTML = '';
      messageBlocks.clear();
      validMsgs.forEach(m => {
        const dab = m.Packet.ApplicationID;
        const dac = dab.DesignatedAreaCode;
        const fi  = dab.FunctionIdentifier;
        const key = `${m.MessageID}|${dac}|${fi}`;
        if (!messageBlocks.has(key)) {
          messageBlocks.set(key, {
            userID,
            msgID: m.MessageID,
            dac,
            fi,
            asm,
            initialMsg: m,
            history: [],
            idx: 0,
            dom: null,
            chart: null
          });
        }
      });

      // Render all
      await Promise.all(Array.from(messageBlocks.values()).map(b => fetchAndRender(b)));
    }

    main();
  </script>
</body>
</html>
