<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8"/>
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>AIS Latest Messages Viewer</title>
  <style>
    body { font-family: sans-serif; margin: 2rem; }
    .error { color: red; font-weight: bold; }
    .message { margin-bottom: 2rem; padding: 1rem; border: 1px solid #ddd; border-radius: 4px; }
    .title { font-size: 1.1rem; font-weight: bold; margin-bottom: 0.3rem; }
    .ts { font-size: 0.9rem; color: #555; margin-bottom: 0.3rem; }
    .nav { display: flex; align-items: center; margin-bottom: 0.8rem; }
    .nav button {
      background: none; border: none;
      font-size: 1.2rem; margin: 0 0.3rem;
      cursor: pointer; transition: opacity 0.2s;
    }
    .nav button:disabled { color: #bbb; cursor: default; opacity: 0.4; }
    .nav .counter { font-size: 0.9rem; color: #333; min-width: 3em; text-align: center; }

    .table-container { overflow-x: auto; margin-bottom: 1rem; }
    table {
      border-collapse: collapse; table-layout: auto;
      white-space: nowrap; width: 100%;
    }
    th, td {
      border: 1px solid #ccc; padding: 0.4rem 0.6rem;
      text-align: left; vertical-align: top;
    }
    th { background: #f0f0f0; }
    .no-binary { font-style: italic; color: #a00; margin: 0.5rem 0; }

    .message .chart-container {
      position: relative; width: 100%; height: 300px; margin-top: 1rem;
    }
    .message .chart-container canvas {
      width: 100% !important; height: 100% !important;
    }

    /* wrapable controls */
    .message .time-controls {
      display: flex; flex-wrap: wrap; gap: 1rem; align-items: baseline;
      margin-bottom: 0.6rem; font-size: 0.9rem;
    }
    .message .time-controls label {
      display: flex; flex-direction: column;
      flex: 1 1 150px;
    }
    .message .time-controls select,
    .message .time-controls input {
      min-width: 100%;
    }
    .message .time-controls button {
      flex: 0 0 auto;
      margin-top: 1.8rem;
    }
  </style>

  <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/chartjs-adapter-date-fns"></script>
  <script src="https://cdn.jsdelivr.net/npm/chartjs-plugin-zoom"></script>
</head>
<body>

  <h1 id="main-title">Loading vessel…</h1>
  <label style="display:block; margin-bottom:1rem;">
    <input type="checkbox" id="auto-refresh-checkbox"> Auto Refresh (60s)
  </label>
  <div id="output">Loading messages…</div>

  <script>
    Chart.register(ChartZoom);
    Chart.defaults.elements.point.radius = 1;

    const messageBlocks = new Map();
    let autoRefreshIntervalId = null;

    function getUserID() {
      const v = new URLSearchParams(window.location.search).get('UserID');
      return v && /^\d+$/.test(v) ? v : null;
    }

    function flattenObject(obj, parentKey = '', res = {}) {
      for (const [k, v] of Object.entries(obj)) {
        const nk = parentKey ? `${parentKey}.${k}` : k;
        if (v != null && typeof v === 'object' && !Array.isArray(v)) {
          flattenObject(v, nk, res);
        } else {
          res[nk] = v;
        }
      }
      return res;
    }

    function humanizeField(field) {
      return field.replace(/[_\.]/g, ' ');
    }

    function makeTableHTML(data) {
      return `
        <table>
          <thead><tr><th>Field</th><th>Value</th></tr></thead>
          <tbody>
            ${Object.entries(data).map(([f, v]) =>
              `<tr><td>${humanizeField(f)}</td><td>${String(v)}</td></tr>`
            ).join('')}
          </tbody>
        </table>`;
    }

    async function fetchAndRender(block) {
      const { userID, msgID, dac, fi, asm, initialMsg, start, end, aggregateFields, range } = block;
      const params = new URLSearchParams({
        UserID:    userID,
        MessageID: msgID,
        DAC:       dac,
        FI:        fi,
        t:         Date.now(),
      });
      if (!aggregateFields.length) params.set('limit', 100);
      if (start) params.set('start', start);
      if (end)   params.set('end',   end);
      if (range) params.set('range', range);
      if (aggregateFields.length) {
        params.set('aggregateFields', aggregateFields.join(','));
      }
      const url = `/latestmessages?${params.toString()}`;

      let arr = [];
      try {
        const res = await fetch(url, { cache: 'no-store' });
        if (res.ok) arr = await res.json();
      } catch (e) {
        console.error('[fetchAndRender] fetch error', e);
      }

      const isAgg = aggregateFields.length > 0;
      let history;
      if (isAgg) {
        history = arr;
      } else {
        history = arr
          .filter(m => m.Packet?.DecodedBinary)
          .sort((a, b) =>
            new Date(b.Timestamp) - new Date(a.Timestamp)
          );
      }

      block.history = history.length ? history : [initialMsg];

      if (!block.dom) createBlockDOM(block);

      if (block.dom.fieldsSelect &&
          !block.dom.fieldsSelect.options.length &&
          initialMsg.Packet?.DecodedBinary) {
        const flat = flattenObject(initialMsg.Packet.DecodedBinary);
        Object.entries(flat)
          .filter(([, v]) => typeof v === 'number')
          .forEach(([f]) => {
            const opt = document.createElement('option');
            opt.value = `DecodedBinary.${f}`;
            opt.textContent = humanizeField(f);
            block.dom.fieldsSelect.appendChild(opt);
          });
      }

      updateBlockDOM(block);
    }

    function createBlockDOM(block) {
      const c = document.createElement('div');
      c.className = 'message';
      block.dom = {};

      const controls = document.createElement('div');
      controls.className = 'time-controls';
      controls.innerHTML = `
        <label>From <input type="datetime-local" class="start-input"/></label>
        <label>To   <input type="datetime-local" class="end-input"/></label>
        <label>Fields
          <select multiple size="4" class="fields-select"></select>
        </label>
        <label>Granularity
          <select class="range-select">
            <option value="">Auto</option>
            <option value="day">Day</option>
            <option value="week">Week</option>
            <option value="month">Month</option>
            <option value="year">Year</option>
          </select>
        </label>
        <button class="apply-range">Get</button>
        <button class="reset-range">Reset</button>
      `;
      c.appendChild(controls);
      block.dom.startInput    = controls.querySelector('.start-input');
      block.dom.endInput      = controls.querySelector('.end-input');
      block.dom.fieldsSelect  = controls.querySelector('.fields-select');
      block.dom.rangeSelect   = controls.querySelector('.range-select');
      block.dom.applyRangeBtn = controls.querySelector('.apply-range');
      block.dom.resetRangeBtn = controls.querySelector('.reset-range');

      block.dom.applyRangeBtn.onclick = () => {
        block.start = block.dom.startInput.value
          ? new Date(block.dom.startInput.value).toISOString()
          : null;
        block.end   = block.dom.endInput.value
          ? new Date(block.dom.endInput.value).toISOString()
          : null;
        block.aggregateFields = Array.from(
          block.dom.fieldsSelect.selectedOptions
        ).map(o => o.value);
        block.range = block.dom.rangeSelect.value;
        block.idx = 0;
        fetchAndRender(block);
      };

      block.dom.resetRangeBtn.onclick = () => {
        block.start = block.end = null;
        block.aggregateFields = [];
        block.range = '';
        block.idx = 0;
        block.dom.startInput.value = '';
        block.dom.endInput.value = '';
        block.dom.fieldsSelect.selectedIndex = -1;
        block.dom.rangeSelect.value = '';
        fetchAndRender(block);
      };

      const titleDiv = document.createElement('div');
      titleDiv.className = 'title';
      c.appendChild(titleDiv);
      block.dom.titleDiv = titleDiv;

      const tsDiv = document.createElement('div');
      tsDiv.className = 'ts';
      c.appendChild(tsDiv);
      block.dom.tsDiv = tsDiv;

      const nav = document.createElement('div');
      nav.className = 'nav';
      c.appendChild(nav);
      block.dom.nav = nav;

      const btnNewer = document.createElement('button');
      btnNewer.textContent = '◀️';
      nav.appendChild(btnNewer);
      block.dom.btnNewer = btnNewer;

      const counter = document.createElement('div');
      counter.className = 'counter';
      nav.appendChild(counter);
      block.dom.counter = counter;

      const btnOlder = document.createElement('button');
      btnOlder.textContent = '▶️';
      nav.appendChild(btnOlder);
      block.dom.btnOlder = btnOlder;

      btnNewer.onclick = () => {
        if (block.idx > 0) {
          block.idx--;
          updateBlockDOM(block);
        }
      };
      btnOlder.onclick = () => {
        if (block.idx < block.history.length - 1) {
          block.idx++;
          updateBlockDOM(block);
        }
      };

      const notice = document.createElement('div');
      notice.className = 'no-binary';
      c.appendChild(notice);
      block.dom.notice = notice;

      const tableContainer = document.createElement('div');
      tableContainer.className = 'table-container';
      c.appendChild(tableContainer);
      block.dom.tableContainer = tableContainer;

      const chartWrapper = document.createElement('div');
      chartWrapper.className = 'chart-container';
      const canvas = document.createElement('canvas');
      chartWrapper.appendChild(canvas);
      c.appendChild(chartWrapper);
      block.dom.chartWrapper = chartWrapper;
      block.dom.canvas = canvas;

      document.getElementById('output').appendChild(c);
    }

    function updateBlockDOM(block) {
      const { dom, asm, history, idx, msgID, dac, fi, aggregateFields } = block;
      const msg = history[idx];
      const isAgg = aggregateFields.length > 0;

      const titleText = asm[msgID]?.[dac]?.[fi]?.Title || 'Unknown message type';
      dom.titleDiv.textContent = `${titleText} (ID ${msgID}, DAC ${dac}, FI ${fi})`
        + (isAgg ? ' — aggregated' : '');

      // common time-axis config
      const timeOpts = {
        type: 'time',
        time: {
          tooltipFormat: 'yyyy-MM-dd HH:mm:ss',
          displayFormats: {
            millisecond: 'HH:mm:ss',
            second: 'HH:mm:ss',
            minute: 'HH:mm',
            hour: 'yyyy-MM-dd HH:mm',
            day: 'yyyy-MM-dd',
            month: 'yyyy-MM',
            year: 'yyyy'
          }
        },
        ticks: { autoSkip: true, maxRotation: 0 }
      };

      if (isAgg) {
        dom.notice.textContent = '';
        dom.tsDiv.style.display = dom.nav.style.display =
          dom.tableContainer.style.display = 'none';
        dom.chartWrapper.style.display = '';

        const times = history.map(m => new Date(m.timestamp));
        const aliases = aggregateFields.map(p =>
          p.split('.').map(s => s.toLowerCase()).join('_') + '_avg'
        );
        const datasets = aliases.map(alias => {
          const label = humanizeField(alias.replace(/^decodedbinary_/, ''));
          return {
            label,
            data: times.map((t,i) => ({ x: t, y: history[i][alias] })),
            borderWidth: 1
          };
        });

        if (dom.chart) dom.chart.destroy();
        dom.chart = new Chart(dom.canvas.getContext('2d'), {
          type: 'line',
          data: { datasets },
          options: {
            animation: false,
            maintainAspectRatio: false,
            scales: { x: timeOpts, y: { beginAtZero: false } },
            plugins: {
              legend: { position: 'bottom' },
              zoom: {
                pan: { enabled: true, mode: 'x' },
                zoom: { wheel: { enabled: true }, drag: { enabled: true }, mode: 'x' }
              }
            },
            interaction: { mode: 'nearest', axis: 'x', intersect: false }
          }
        });

      } else {
        dom.notice.textContent = '';
        dom.tsDiv.style.display = '';
        dom.nav.style.display = 'flex';
        dom.tableContainer.style.display = '';
        dom.chartWrapper.style.display = '';

        dom.tsDiv.textContent = new Date(msg.Timestamp).toLocaleString([], {
          hour12: false,
          year:'numeric', month:'2-digit', day:'2-digit',
          hour:'2-digit', minute:'2-digit', second:'2-digit'
        });
        dom.btnNewer.disabled = idx===0;
        dom.btnOlder.disabled = idx===history.length-1;
        dom.counter.textContent = `${idx+1} of ${history.length}`;

        dom.tableContainer.innerHTML = makeTableHTML(
          flattenObject(msg.Packet.DecodedBinary)
        );

        const records = history.map(m=>flattenObject(m.Packet.DecodedBinary));
        const timesArr = history.map(m=>new Date(m.Timestamp));
        const fields = Object.keys(records[0]||{}).filter(f=>typeof records[0][f]==='number');
        const defaultVis = new Set(fields.slice(0,3));

        if (dom.chart) dom.chart.destroy();
        const datasets = fields.map(f=>({
          label: humanizeField(f),
          data: timesArr.map((t,i)=>({ x:t, y:records[i][f] })),
          borderWidth:1,
          hidden:!defaultVis.has(f),
          _fieldKey:f
        }));

        dom.chart = new Chart(dom.canvas.getContext('2d'), {
          type:'line',
          data:{datasets},
          options:{
            animation:false,
            maintainAspectRatio:false,
            scales:{ x: timeOpts, y:{ beginAtZero:false } },
            plugins:{
              legend:{ position:'bottom' },
              zoom:{
                pan:{ enabled:true, mode:'x' },
                zoom:{ wheel:{ enabled:true }, drag:{ enabled:true }, mode:'x' }
              }
            },
            interaction:{ mode:'nearest', axis:'x', intersect:false }
          }
        });
        dom.canvas.addEventListener('dblclick', () => dom.chart.resetZoom());
      }
    }

    function runRefresh() {
      for (const b of messageBlocks.values()) fetchAndRender(b);
    }

    const autoCB = document.getElementById('auto-refresh-checkbox');
    if (localStorage.getItem('autoRefreshEnabled')==='true') {
      autoCB.checked = true;
      runRefresh();
      autoRefreshIntervalId = setInterval(runRefresh,60000);
    }
    autoCB.addEventListener('change', e => {
      localStorage.setItem('autoRefreshEnabled', e.target.checked);
      if (e.target.checked) {
        runRefresh();
        autoRefreshIntervalId = setInterval(runRefresh,60000);
      } else {
        clearInterval(autoRefreshIntervalId);
      }
    });

    async function main() {
      const userID = getUserID();
      const titleEl = document.getElementById('main-title');
      const output  = document.getElementById('output');
      if (!userID) {
        titleEl.textContent='Error';
        output.innerHTML='<div class="error">Invalid or missing numeric UserID parameter.</div>';
        return;
      }

      let summary;
      try {
        const r = await fetch(`/summary?UserID=${userID}`);
        if (!r.ok) throw '';
        summary = await r.json();
      } catch {
        titleEl.textContent='Error';
        output.innerHTML='<div class="error">Failed to load summary</div>';
        return;
      }
      const info = summary[userID]||{};
      titleEl.textContent=`Latest Messages for ${info.Name?.trim()?info.Name:userID}`;

      let asm;
      try {
        const r = await fetch('/asm.json');
        if (!r.ok) throw '';
        asm = await r.json();
      } catch {
        output.innerHTML='<div class="error">Failed to load asm.json</div>';
        return;
      }

      let allMsgs;
      try {
        const r = await fetch(`/latestmessages?UserID=${userID}`);
        if (r.status!==200) throw '';
        allMsgs = await r.json();
      } catch {
        output.innerHTML='<div class="error">Vessel Not Found</div>';
        return;
      }

      const validMsgs = allMsgs.filter(m=>m.Packet?.ApplicationID?.Valid);
      if (!validMsgs.length) {
        output.innerHTML='<div>No valid message types available.</div>';
        return;
      }

      output.innerHTML='';
      messageBlocks.clear();
      validMsgs.forEach(m=>{
        const dab = m.Packet.ApplicationID;
        const key = `${m.MessageID}|${dab.DesignatedAreaCode}|${dab.FunctionIdentifier}`;
        if (!messageBlocks.has(key)) {
          messageBlocks.set(key,{
            userID, msgID:m.MessageID,
            dac:dab.DesignatedAreaCode,
            fi:dab.FunctionIdentifier,
            asm, initialMsg:m,
            history:[], idx:0,
            dom:null, chart:null,
            start:null, end:null,
            aggregateFields:[], range:''
          });
        }
      });

      await Promise.all(Array.from(messageBlocks.values()).map(b=>fetchAndRender(b)));
    }
    main();
  </script>
</body>
</html>
