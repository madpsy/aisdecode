<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>AIS Latest Messages Viewer</title>
  <style>
    body { font-family: sans-serif; margin: 2rem; }
    .error { color: red; font-weight: bold; }
    .message { margin-bottom: 2rem; padding: 1rem; border: 1px solid #ddd; border-radius: 4px; }
    .title { font-size: 1.1rem; font-weight: bold; margin-bottom: 0.3rem; }
    .ts { font-size: 0.9rem; color: #555; margin-bottom: 0.3rem; }
    .nav { display: flex; align-items: center; margin-bottom: 0.8rem; }
    .nav button {
      background: none;
      border: none;
      font-size: 1.2rem;
      margin: 0 0.3rem;
      cursor: pointer;
      transition: opacity 0.2s;
    }
    .nav button:disabled {
      color: #bbb;
      cursor: default;
      opacity: 0.4;
    }
    .nav .counter {
      font-size: 0.9rem;
      color: #333;
      min-width: 3em;
      text-align: center;
    }
    .table-container { overflow-x: auto; }
    table {
      border-collapse: collapse;
      table-layout: auto;
      margin-top: 0.5rem;
      white-space: nowrap;
    }
    th, td {
      border: 1px solid #ccc;
      padding: 0.4rem 0.6rem;
      text-align: left;
      vertical-align: top;
    }
    th { background: #f0f0f0; }
    .message .chart-container {
      position: relative;
      width: 100%;
      height: 300px;
      margin-top: 1rem;
    }
    .message .chart-container canvas {
      width: 100% !important;
      height: 100% !important;
    }
  </style>

  <!-- Chart.js and date adapter for time scales -->
  <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/chartjs-adapter-date-fns"></script>
  <!-- Zoom & Pan plugin for Chart.js -->
  <script src="https://cdn.jsdelivr.net/npm/chartjs-plugin-zoom"></script>
</head>
<body>

  <h1 id="main-title">Loading vessel…</h1>
  <label style="display:block; margin-bottom:1rem;">
    <input type="checkbox" id="auto-refresh-checkbox"> Auto Refresh (60s)
  </label>
  <div id="output">Loading messages…</div>

  <script>
    Chart.register(ChartZoom);
    Chart.defaults.elements.point.radius = 1;

    // Use a Map to track one block per MessageID|DAC|FI
    const messageBlocks = new Map();
    let autoRefreshIntervalId = null;

    function getUserID() {
      const v = new URLSearchParams(window.location.search).get('UserID');
      return v && /^\d+$/.test(v) ? v : null;
    }

    function flattenObject(obj, parentKey = '', res = {}) {
      for (const [k, v] of Object.entries(obj)) {
        const nk = parentKey ? `${parentKey}.${k}` : k;
        if (v != null && typeof v === 'object' && !Array.isArray(v)) {
          flattenObject(v, nk, res);
        } else {
          res[nk] = v;
        }
      }
      return res;
    }

    function formatValue(val) {
      if (typeof val === 'number' && isFinite(val)) {
        return parseFloat(val.toFixed(4)).toString();
      }
      return String(val);
    }

    function humanizeField(field) {
      return field.replace(/[_\.]/g, ' ');
    }

    function makeTableHTML(data) {
      return `
        <table>
          <thead><tr><th>Field</th><th>Value</th></tr></thead>
          <tbody>
            ${Object.entries(data).map(([f, v]) =>
              `<tr>
                 <td>${humanizeField(f)}</td>
                 <td>${formatValue(v)}</td>
               </tr>`
            ).join('')}
          </tbody>
        </table>`;
    }

    async function fetchAndRender(block) {
      const { userID, msgID, dac, fi, asm, initialMsg } = block;
      const url = `/latestmessages?UserID=${userID}`
                + `&MessageID=${msgID}&DAC=${dac}&FI=${fi}&limit=100`
                + `&t=${Date.now()}`;
      let arr = [];
      try {
        const res = await fetch(url, { cache: 'no-store' });
        if (res.ok) arr = await res.json();
      } catch (e) {
        console.error('[AutoRefresh] fetch error', e);
      }
      const history = arr
        .filter(m => m.Packet?.DecodedBinary)
        .sort((a, b) => new Date(b.Timestamp) - new Date(a.Timestamp));

      block.history = history.length ? history : [initialMsg];
      if (!block.dom) createBlockDOM(block);
      updateBlockDOM(block);
    }

    function createBlockDOM(block) {
      const c = document.createElement('div');
      c.className = 'message';
      block.dom = { container: c };

      // title
      const titleDiv = document.createElement('div');
      titleDiv.className = 'title';
      c.appendChild(titleDiv);
      block.dom.titleDiv = titleDiv;

      // timestamp + nav
      const tsDiv = document.createElement('div');
      tsDiv.className = 'ts';
      const nav = document.createElement('div'); nav.className = 'nav';
      const btnNewer = document.createElement('button');
      const btnOlder = document.createElement('button');
      const counter = document.createElement('div'); counter.className = 'counter';
      btnNewer.textContent = '◀️'; btnOlder.textContent = '▶️';
      nav.append(btnNewer, counter, btnOlder);
      c.append(tsDiv, nav);
      block.dom.tsDiv = tsDiv;
      block.dom.btnNewer = btnNewer;
      block.dom.btnOlder = btnOlder;
      block.dom.counter = counter;

      // table
      const tableContainer = document.createElement('div');
      tableContainer.className = 'table-container';
      c.appendChild(tableContainer);
      block.dom.tableContainer = tableContainer;

      // chart
      const chartWrapper = document.createElement('div');
      chartWrapper.className = 'chart-container';
      const canvas = document.createElement('canvas');
      chartWrapper.appendChild(canvas);
      c.appendChild(chartWrapper);
      block.dom.canvas = canvas;

      // nav click handlers
      btnNewer.onclick = () => { if (block.idx > 0) { block.idx--; updateBlockDOM(block); } };
      btnOlder.onclick = () => { if (block.idx < block.history.length - 1) { block.idx++; updateBlockDOM(block); } };

      document.getElementById('output').appendChild(c);
    }

    function updateBlockDOM(block) {
      const { dom, asm, history, idx, msgID, dac, fi } = block;
      const msg = history[idx];

      // — Title
      dom.titleDiv.textContent =
        asm[msgID]?.[dac]?.[fi]?.Title
        || `Msg ${msgID} (DAC ${dac}, FI ${fi})`;

      // — Timestamp & nav
      dom.tsDiv.textContent = new Date(msg.Timestamp).toLocaleString([], {
        hour12: false,
        year: 'numeric', month: '2-digit', day: '2-digit',
        hour: '2-digit', minute: '2-digit', second: '2-digit'
      });
      dom.btnNewer.disabled = idx === 0;
      dom.btnOlder.disabled = idx === history.length - 1;
      dom.counter.textContent = `${idx + 1} of ${history.length}`;

      // — Table
      dom.tableContainer.innerHTML =
        makeTableHTML(flattenObject(msg.Packet.DecodedBinary));

      // — Build the raw arrays
      const records = history.map(m => flattenObject(m.Packet.DecodedBinary));
      const times   = history.map(m => new Date(m.Timestamp));
      const fields  = Object.keys(records[0] || {}).filter(f => typeof records[0][f] === 'number');
      const defaultVisible = new Set(fields.slice(0, 3));

      // — Create or update datasets, reusing existing instances to keep `.hidden`
      if (!block.chart) {
        const datasets = fields.map(field => ({
          label:    humanizeField(field),
          data:     times.map((t, i) => ({ x: t, y: records[i][field] })),
          borderWidth: 1,
          hidden:   !defaultVisible.has(field),
          _fieldKey: field
        }));

        block.chart = new Chart(dom.canvas.getContext('2d'), {
          type: 'line',
          data: { datasets },
          options: {
            animation: false,
            maintainAspectRatio: false,
            scales: {
              x: {
                type: 'time',
                time: {
                  tooltipFormat: 'HH:mm:ss',
                  displayFormats: { hour: 'HH:mm', minute: 'HH:mm' }
                },
                ticks: { autoSkip: true, maxRotation: 0 }
              },
              y: { beginAtZero: false }
            },
            plugins: {
              legend: {
                position: 'bottom',
                labels: { boxWidth: 8, padding: 8, font: { size: 10 } }
              },
              tooltip: { mode: 'index', intersect: false },
              zoom: {
                pan: { enabled: true, mode: 'x' },
                zoom: {
                  wheel: { enabled: true },
                  drag: { enabled: true, backgroundColor: 'rgba(54,162,235,0.3)' },
                  pinch: { enabled: true },
                  mode: 'x',
                  doubleClickReset: true
                }
              }
            },
            interaction: { mode: 'nearest', axis: 'x', intersect: false }
          }
        });

        // double-click to reset zoom
        dom.canvas.addEventListener('dblclick', () => block.chart.resetZoom());
      } else {
        const oldDatasets = block.chart.data.datasets;
        const newDatasets = fields.map(field => {
          const existing = oldDatasets.find(ds => ds._fieldKey === field);
          if (existing) {
            existing.data = times.map((t, i) => ({ x: t, y: records[i][field] }));
            return existing;
          }
          return {
            label:    humanizeField(field),
            data:     times.map((t, i) => ({ x: t, y: records[i][field] })),
            borderWidth: 1,
            hidden:   !defaultVisible.has(field),
            _fieldKey: field
          };
        });

        block.chart.data.datasets = newDatasets;
        block.chart.update();
      }
    }

    function runRefresh() {
      for (const block of messageBlocks.values()) {
        fetchAndRender(block);
      }
    }

    // Persist & re-hydrate Auto-Refresh state
    const autoCB = document.getElementById('auto-refresh-checkbox');
    const saved = localStorage.getItem('autoRefreshEnabled');
    if (saved === 'true') {
      autoCB.checked = true;
      runRefresh();
      autoRefreshIntervalId = setInterval(runRefresh, 60000);
    }
    autoCB.addEventListener('change', function(e) {
      const enabled = e.target.checked;
      localStorage.setItem('autoRefreshEnabled', enabled);
      if (enabled) {
        runRefresh();
        autoRefreshIntervalId = setInterval(runRefresh, 60000);
      } else if (autoRefreshIntervalId) {
        clearInterval(autoRefreshIntervalId);
        autoRefreshIntervalId = null;
      }
    });

    async function main() {
      const userID = getUserID();
      const titleEl = document.getElementById('main-title');
      const output = document.getElementById('output');
      if (!userID) {
        titleEl.textContent = 'Error';
        output.innerHTML = '<div class="error">Invalid or missing numeric UserID parameter.</div>';
        return;
      }

      // Load summary
      let summary;
      try {
        const r = await fetch(`/summary?UserID=${userID}`);
        if (!r.ok) throw '';
        summary = await r.json();
      } catch {
        titleEl.textContent = 'Error';
        output.innerHTML = '<div class="error">Failed to load summary</div>';
        return;
      }
      const info = summary[userID] || {};
      const name = info.Name?.trim() ? info.Name : userID;
      titleEl.textContent = `Latest Messages for ${name}`;

      // Load ASM definitions
      let asm;
      try {
        const r = await fetch('/asm.json');
        if (!r.ok) throw '';
        asm = await r.json();
      } catch {
        output.innerHTML = '<div class="error">Failed to load asm.json</div>';
        return;
      }

      // Initial fetch of latest messages (one per message_id|DAC|FI)
      let allMsgs;
      try {
        const r = await fetch(`/latestmessages?UserID=${userID}`);
        if (r.status !== 200) throw '';
        allMsgs = await r.json();
      } catch {
        output.innerHTML = '<div class="error">Vessel Not Found</div>';
        return;
      }

      const decoded = allMsgs.filter(m => m.Packet?.DecodedBinary);
      if (!decoded.length) {
        output.innerHTML = '<div>No decoded-binary messages available.</div>';
        return;
      }

      // Clear and build blocks
      output.innerHTML = '';
      messageBlocks.clear();
      decoded.forEach(msg => {
        const dab = msg.Packet.ApplicationID || {};
        const dac = dab.DesignatedAreaCode;
        const fi  = dab.FunctionIdentifier;
        const key = `${msg.MessageID}|${dac}|${fi}`;
        if (!messageBlocks.has(key)) {
          messageBlocks.set(key, {
            userID,
            msgID: msg.MessageID,
            dac, fi,
            asm,
            initialMsg: msg,
            history: [],
            idx: 0,
            dom: null,
            chart: null
          });
        }
      });

      // Render all blocks
      await Promise.all(Array.from(messageBlocks.values()).map(b => fetchAndRender(b)));
    }

    main();
  </script>
</body>
</html>
