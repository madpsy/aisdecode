<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>AIS Latest Messages Viewer</title>
  <style>
    body { font-family: sans-serif; margin: 2rem; }
    .error { color: red; font-weight: bold; }
    .message { margin-bottom: 2rem; padding: 1rem; border: 1px solid #ddd; border-radius: 4px; }
    .title { font-size: 1.1rem; font-weight: bold; margin-bottom: 0.3rem; }
    .ts { font-size: 0.9rem; color: #555; margin-bottom: 0.3rem; }
    .nav { display: flex; align-items: center; margin-bottom: 0.8rem; }
    .nav button {
      background: none;
      border: none;
      font-size: 1.2rem;
      margin: 0 0.3rem;
      cursor: pointer;
      transition: opacity 0.2s;
    }
    .nav button:disabled {
      color: #bbb;
      cursor: default;
      opacity: 0.4;
    }
    .nav .counter {
      font-size: 0.9rem;
      color: #333;
      min-width: 3em;
      text-align: center;
    }
    .table-container { overflow-x: auto; }
    table {
      border-collapse: collapse;
      table-layout: auto;
      margin-top: 0.5rem;
      white-space: nowrap;
    }
    th, td {
      border: 1px solid #ccc;
      padding: 0.4rem 0.6rem;
      text-align: left;
      vertical-align: top;
    }
    th { background: #f0f0f0; }

    /* —— Chart container styling —— */
    .message .chart-container {
      position: relative;
      width: 100%;
      height: 300px;
      margin-top: 1rem;
    }
    .message .chart-container canvas {
      width: 100% !important;
      height: 100% !important;
    }
  </style>

  <!-- Chart.js and date adapter for time scales -->
  <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/chartjs-adapter-date-fns"></script>
  <!-- Zoom & Pan plugin for Chart.js -->
  <script src="https://cdn.jsdelivr.net/npm/chartjs-plugin-zoom"></script>
</head>
<body>

  <h1 id="main-title">Loading vessel…</h1>
  <label style="display:block; margin-bottom:1rem;"><input type="checkbox" id="auto-refresh-checkbox"> Auto Refresh (60s)</label>
  <div id="output">Loading messages…</div>

  <script>
    // 1) register the zoom plugin
    Chart.register(ChartZoom);
    // 2) make points small by default
    Chart.defaults.elements.point.radius = 1;

    const messageBlocks = [];
    let autoRefreshIntervalId = null;

    function getUserID() {
      const p = new URLSearchParams(window.location.search);
      const v = p.get('UserID');
      return v && /^\d+$/.test(v) ? v : null;
    }

    function flattenObject(obj, parentKey = '', res = {}) {
      for (const [k, v] of Object.entries(obj)) {
        const nk = parentKey ? `${parentKey}.${k}` : k;
        if (v != null && typeof v === 'object' && !Array.isArray(v)) {
          flattenObject(v, nk, res);
        } else {
          res[nk] = v;
        }
      }
      return res;
    }

    function formatValue(val) {
      if (typeof val === 'number' && isFinite(val)) {
        return parseFloat(val.toFixed(4)).toString();
      }
      return String(val);
    }

    function humanizeField(field) {
      return field.replace(/[_\.]/g, ' ');
    }

    function makeTableHTML(data) {
      return `
        <table>
          <thead><tr><th>Field</th><th>Value</th></tr></thead>
          <tbody>
            ${Object.entries(data).map(([f, v]) =>
              `<tr>
                 <td>${humanizeField(f)}</td>
                 <td>${formatValue(v)}</td>
               </tr>`
            ).join('')}
          </tbody>
        </table>`;
    }

    async function main() {
      const userID = getUserID();
      const titleEl = document.getElementById('main-title');
      const output = document.getElementById('output');
      if (!userID) {
        titleEl.textContent = 'Error';
        output.innerHTML = '<div class="error">Invalid or missing numeric UserID parameter.</div>';
        return;
      }

      let summary;
      try {
        const r = await fetch(`/summary?UserID=${userID}`);
        if (!r.ok) throw '';
        summary = await r.json();
      } catch {
        titleEl.textContent = 'Error';
        output.innerHTML = '<div class="error">Failed to load summary</div>';
        return;
      }
      const info = summary[userID] || {};
      const name = info.Name?.trim() ? info.Name : userID;
      titleEl.textContent = `Latest Messages for ${name}`;

      let asm;
      try {
        const r = await fetch('/asm.json');
        if (!r.ok) throw '';
        asm = await r.json();
      } catch {
        output.innerHTML = '<div class="error">Failed to load asm.json</div>';
        return;
      }

      let allMsgs;
      try {
        const r = await fetch(`/latestmessages?UserID=${userID}`);
        if (r.status !== 200) throw '';
        allMsgs = await r.json();
      } catch {
        output.innerHTML = '<div class="error">Vessel Not Found</div>';
        return;
      }

      const decoded = allMsgs.filter(m => m.Packet?.DecodedBinary);
      if (!decoded.length) {
        output.innerHTML = '<div>No decoded-binary messages available.</div>';
        return;
      }
      output.innerHTML = '';
      messageBlocks.length = 0; // reset blocks

      await Promise.all(decoded.map(msg => initHistory(msg, userID, asm)));
    }

    async function initHistory(initialMsg, userID, asm) {
      // Each block stores its metadata and update logic
      const block = { initialMsg, userID, asm, history: [], chart: null, idx: 0, dom: {} };
      messageBlocks.push(block);
      await fetchAndRender(block);
    }

    async function fetchAndRender(block) {
      const { initialMsg, userID, asm } = block;
      const url = `/latestmessages?UserID=${userID}`
                + `&MessageID=${initialMsg.MessageID}&limit=100`;
      let arr = [];
      try {
        const r = await fetch(url);
        if (r.ok) arr = await r.json();
      } catch {}
      const history = arr
        .filter(m => m.Packet?.DecodedBinary)
        .sort((a, b) => new Date(b.Timestamp) - new Date(a.Timestamp));
      block.history = history.length ? history : [initialMsg];

      if (!block.dom.container) {
        createBlockDOM(block);
      }
      updateBlockDOM(block);
    }

    function createBlockDOM(block) {
      const container = document.createElement('div');
      container.className = 'message';
      block.dom.container = container;

      // title
      const titleDiv = document.createElement('div');
      titleDiv.className = 'title';
      container.appendChild(titleDiv);
      block.dom.titleDiv = titleDiv;

      // timestamp and nav
      const tsDiv = document.createElement('div');
      tsDiv.className = 'ts';
      const nav = document.createElement('div'); nav.className = 'nav';
      const btnNewer = document.createElement('button');
      const btnOlder = document.createElement('button');
      const counter = document.createElement('div'); counter.className = 'counter';
      btnNewer.textContent = '◀️'; btnOlder.textContent = '▶️';
      nav.append(btnNewer, counter, btnOlder);
      container.append(tsDiv, nav);
      block.dom.tsDiv = tsDiv;
      block.dom.btnNewer = btnNewer;
      block.dom.btnOlder = btnOlder;
      block.dom.counter = counter;

      // table
      const tableContainer = document.createElement('div');
      tableContainer.className = 'table-container';
      container.appendChild(tableContainer);
      block.dom.tableContainer = tableContainer;

      // chart
      const chartWrapper = document.createElement('div');
      chartWrapper.className = 'chart-container';
      const canvas = document.createElement('canvas');
      chartWrapper.appendChild(canvas);
      container.appendChild(chartWrapper);
      block.dom.canvas = canvas;

      document.getElementById('output').appendChild(container);

      // nav handlers
      btnNewer.onclick = () => { if (block.idx > 0) { block.idx--; updateBlockDOM(block); } };
      btnOlder.onclick = () => { const len = block.history.length; if (block.idx < len - 1) { block.idx++; updateBlockDOM(block); } };
    }

    function updateBlockDOM(block) {
      const { dom, asm, history, idx } = block;
      const m = history[idx];
      // title
      const dac = m.Packet.ApplicationID.DesignatedAreaCode;
      const fi  = m.Packet.ApplicationID.FunctionIdentifier;
      dom.titleDiv.textContent = asm[m.MessageID]?.[dac]?.[fi]?.Title || 'Unknown message type';
      // timestamp and nav
      dom.tsDiv.textContent = new Date(m.Timestamp).toLocaleString([], {
        hour12: false,
        year: 'numeric', month: '2-digit', day: '2-digit',
        hour: '2-digit', minute: '2-digit', second: '2-digit'
      });
      dom.btnNewer.disabled = idx === 0;
      dom.btnOlder.disabled = idx === history.length - 1;
      dom.counter.textContent = `${idx + 1} of ${history.length}`;
      // table
      dom.tableContainer.innerHTML = makeTableHTML(flattenObject(m.Packet.DecodedBinary));

      // chart data
      const records = history.map(x => flattenObject(x.Packet.DecodedBinary));
      const times = history.map(x => new Date(x.Timestamp));
      const fields = Object.keys(records[0]).filter(f => typeof records[0][f] === 'number');
      const visible = new Set(fields.slice(0, 3)); // keep first 3 visible by default
      const datasets = fields.map(field => ({
        label: humanizeField(field),
        data: times.map((t,i) => ({ x: t, y: records[i][field] })),
        borderWidth: 1,
        hidden: !visible.has(field)
      }));

      if (!block.chart) {
        block.chart = new Chart(dom.canvas.getContext('2d'), {
          type: 'line',
          data: { datasets },
          options: {
            animation: false,
            maintainAspectRatio: false,
            scales: {
              x: { type: 'time', time: { tooltipFormat: 'HH:mm:ss', displayFormats: { hour: 'HH:mm', minute: 'HH:mm' } }, ticks: { autoSkip: true, maxRotation: 0 } },
              y: { beginAtZero: false }
            },
            plugins: {
              legend: { position: 'bottom', labels: { boxWidth: 8, padding: 8, font: { size: 10 } } },
              tooltip: { mode: 'index', intersect: false },
              zoom: { pan: { enabled: true, mode: 'x' }, zoom: { wheel: { enabled: true }, drag: { enabled: true, backgroundColor: 'rgba(54,162,235,0.3)' }, pinch: { enabled: true }, mode: 'x', doubleClickReset: true } }
            },
            interaction: { mode: 'nearest', axis: 'x', intersect: false }
          }
        });
        // dblclick to reset zoom
        dom.canvas.addEventListener('dblclick', () => block.chart.resetZoom());
      } else {
        block.chart.data.datasets = datasets;
        block.chart.update();
      }
    }

    function runRefresh() {
      messageBlocks.forEach(block => fetchAndRender(block));
    }

    document.getElementById('auto-refresh-checkbox').addEventListener('change', function(e) {
      if (e.target.checked) {
        runRefresh();
        autoRefreshIntervalId = setInterval(runRefresh, 60000);
      } else if (autoRefreshIntervalId) {
        clearInterval(autoRefreshIntervalId);
        autoRefreshIntervalId = null;
      }
    });

    main();
  </script>
</body>
</html>
