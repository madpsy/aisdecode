<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Vessel History</title>
  <!-- Include Bootstrap CSS -->
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/twitter-bootstrap/4.6.0/css/bootstrap.min.css">
  <!-- Include Leaflet CSS -->
  <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.3/dist/leaflet.css"
        integrity="sha256-kLaT2GOSpHechhsozzB+flnD+zUyjE2LlfWPgU04xyI=" crossorigin="" />
  <style>
    body {
      font-family: sans-serif;
      margin: 2rem;
    }
    /* Selection window styles for histogram */
    #message-histogram {
      position: relative;
      user-select: none;
    }
    .selection-window {
      position: absolute;
      top: 0;
      height: 100%;
      background-color: rgba(255, 165, 0, 0.2);
      border-left: 2px solid rgba(255, 165, 0, 0.7);
      border-right: 2px solid rgba(255, 165, 0, 0.7);
      pointer-events: none;
      z-index: 10;
    }
    .selection-handle {
      position: absolute;
      top: 0;
      width: 8px;
      height: 100%;
      background-color: rgba(255, 165, 0, 0.7);
      cursor: ew-resize;
      pointer-events: all;
    }
    .selection-handle-left {
      left: -4px;
    }
    .selection-handle-right {
      right: -4px;
    }
    .selection-info {
      position: absolute;
      top: 5px;
      left: 50%;
      transform: translateX(-50%);
      background-color: rgba(255, 255, 255, 0.8);
      padding: 2px 6px;
      border-radius: 3px;
      font-size: 11px;
      pointer-events: none;
      white-space: nowrap;
    }
    .vessel-header {
      display: flex;
      align-items: flex-start;
      margin-bottom: 2rem;
    }
    .flag-container {
      margin-right: 2rem;
    }
    .flag-img {
      width: 80px;
      height: auto;
      border: 1px solid #ddd;
    }
    .vessel-info {
      flex-grow: 1;
      display: flex;
      flex-wrap: wrap;
      gap: 1rem;
    }
    .vessel-image {
      max-width: 300px;
      max-height: 200px;
      border: 1px solid #ddd;
      margin-left: 1rem;
    }
    .error {
      color: red;
      font-weight: bold;
    }
    .info-column {
      flex: 1;
      min-width: 300px;
    }
    table {
      border-collapse: collapse;
      width: 100%;
      margin-bottom: 1rem;
    }
    th, td {
      border: 1px solid #ddd;
      padding: 6px;
      text-align: left;
    }
    th {
      background-color: #f2f2f2;
    }
    .history-section {
      margin-top: 2rem;
    }
    .date-selector {
      display: flex;
      gap: 1rem;
      margin-bottom: 1rem;
      align-items: center;
    }
    .date-selector label {
      display: flex;
      flex-direction: column;
      margin-bottom: 0;
    }
    .date-selector button {
      margin-top: 1.5rem;
    }
    #receiver-select {
      min-width: 120px;
    }
    #message-histogram {
      height: 80px;
      width: 100%;
      margin-bottom: 1rem;
      border: 1px solid #ddd;
      position: relative;
      background-color: #f9f9f9;
    }
    #map-container {
      height: 400px;
      margin-bottom: 1rem;
      border: 1px solid #ddd;
      position: relative;
    }
    .changes-container {
      display: flex;
      flex-wrap: wrap;
      gap: 1rem;
      margin-top: 1rem;
    }
    .changes-table {
      flex: 1;
      min-width: 300px;
    }
    .changes-table h3 {
      font-size: 1.2rem;
      margin-bottom: 0.5rem;
    }
    .no-changes {
      font-style: italic;
      color: #666;
    }
    /* Speed legend styles */
    .speed-legend {
      position: absolute;
      top: 10px;
      right: 10px;
      background: rgba(255, 255, 255, 0.6);
      padding: 5px;
      border: 1px solid #ccc;
      border-radius: 3px;
      z-index: 1000;
      font-size: 12px;
      width: 120px;
    }
    
    /* Replay control styles */
    .replay-control {
      position: absolute;
      bottom: 10px;
      left: 10px;
      background: rgba(255, 255, 255, 0.6);
      padding: 5px;
      border: 1px solid #ccc;
      border-radius: 3px;
      z-index: 1000;
      font-size: 12px;
      display: flex;
      align-items: center;
      gap: 5px;
    }
    .replay-button {
      padding: 4px 8px;
      background-color: #4CAF50;
      color: white;
      border: none;
      border-radius: 3px;
      cursor: pointer;
      font-size: 12px;
      display: flex;
      align-items: center;
      gap: 3px;
    }
    .replay-button:hover {
      background-color: #45a049;
    }
    .replay-button:disabled {
      background-color: #cccccc;
      cursor: not-allowed;
    }
    .replay-duration {
      padding: 2px;
      font-size: 12px;
      border-radius: 3px;
      border: 1px solid #ccc;
    }
    .replay-progress {
      position: absolute;
      bottom: 0;
      left: 0;
      height: 3px;
      background-color: #4CAF50;
      width: 0%;
      transition: width 0.1s linear;
    }
    .speed-scale-container {
      margin-bottom: 6px;
      padding: 0 5px;
      font-family: Arial, sans-serif;
      font-size: 12px;
      line-height: 1;
    }
    .speed-scale-bar {
      height: 6px;
      border-radius: 3px;
      background: linear-gradient(
        to right,
        hsl(120,100%,50%) 0%,    /* green */
        hsl(60, 100%,50%) 50%,   /* yellow */
        hsl(0,  100%,50%) 100%   /* red */
      );
      margin-bottom: 2px;
    }
    .speed-scale-labels {
      display: flex;
      justify-content: space-between;
    }
    #copy-link-btn {
      display: flex;
      align-items: center;
      gap: 5px;
      padding: 5px 10px;
      font-size: 0.9rem;
    }
    #copy-link-btn svg {
      margin-right: 3px;
    }
    
    /* Image overlay styles */
    .image-overlay {
      display: none;
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background-color: rgba(0, 0, 0, 0.8);
      z-index: 2000;
      justify-content: center;
      align-items: center;
    }
    
    .image-overlay.active {
      display: flex;
    }
    
    .overlay-content {
      position: relative;
      max-width: 90%;
      max-height: 90%;
    }
    
    .overlay-content img {
      max-width: 100%;
      max-height: 90vh;
      border: 2px solid white;
      box-shadow: 0 0 20px rgba(0, 0, 0, 0.5);
    }
    
    .close-overlay {
      position: absolute;
      top: -20px;
      right: -20px;
      width: 40px;
      height: 40px;
      border-radius: 50%;
      background-color: white;
      color: black;
      font-size: 24px;
      display: flex;
      justify-content: center;
      align-items: center;
      cursor: pointer;
      box-shadow: 0 0 10px rgba(0, 0, 0, 0.5);
    }
    
    #vessel-img {
      cursor: pointer;
    }
  </style>
  
  <!-- Add custom style for receiver tooltips -->
  <style>
    .receiver-tooltip {
      background-color: rgba(255, 255, 255, 0.9);
      border: 1px solid #999;
      border-radius: 3px;
      padding: 2px 5px;
      font-weight: bold;
      font-size: 11px;
      box-shadow: 0 1px 3px rgba(0,0,0,0.3);
    }
    
    .receiver-tooltip-active {
      border: 2px solid #f03;
    }
    
    /* Replay tooltip styles */
    .replay-tooltip {
      z-index: 1000 !important; /* Higher z-index to stay on top */
    }
    
    /* Lower z-index for receiver tooltips during replay */
    .replay-active .receiver-tooltip {
      z-index: 500 !important;
    }
  </style>
</head>
<body>
  <div style="display: flex; justify-content: space-between; align-items: center;">
    <h1 id="main-title">Vessel History</h1>
    <button id="copy-link-btn" class="btn btn-sm btn-outline-secondary">
      <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" class="bi bi-link-45deg" viewBox="0 0 16 16">
        <path d="M4.715 6.542 3.343 7.914a3 3 0 1 0 4.243 4.243l1.828-1.829A3 3 0 0 0 8.586 5.5L8 6.086a1.002 1.002 0 0 0-.154.199 2 2 0 0 1 .861 3.337L6.88 11.45a2 2 0 1 1-2.83-2.83l.793-.792a4.018 4.018 0 0 1-.128-1.287z"/>
        <path d="M6.586 4.672A3 3 0 0 0 7.414 9.5l.775-.776a2 2 0 0 1-.896-3.346L9.12 3.55a2 2 0 1 1 2.83 2.83l-.793.792c.112.42.155.855.128 1.287l1.372-1.372a3 3 0 1 0-4.243-4.243L6.586 4.672z"/>
      </svg>
      Copy Link
    </button>
  </div>

  <div class="vessel-header">
    <div class="flag-container">
      <img id="flag-img" class="flag-img" src="" alt="Country Flag" style="display: none;">
    </div>
    <div class="vessel-info">
      <div class="info-column">
        <table id="vessel-table-left">
          <tbody>
            <!-- Left column data will be inserted here dynamically -->
          </tbody>
        </table>
      </div>
      <div class="info-column">
        <table id="vessel-table-right">
          <tbody>
            <!-- Right column data will be inserted here dynamically -->
          </tbody>
        </table>
      </div>
    </div>
    <div>
      <img id="vessel-img" class="vessel-image" src="" alt="Vessel Image" style="display: none;">
    </div>
    
    <!-- Image overlay -->
    <div id="image-overlay" class="image-overlay">
      <div class="overlay-content">
        <div class="close-overlay">&times;</div>
        <img id="overlay-img" src="" alt="Vessel Image Full Size">
      </div>
    </div>
  </div>

  <div class="history-section">
    <div class="date-selector">
      <label>From <input type="datetime-local" id="start"/></label>
      <label>To <input type="datetime-local" id="end"/></label>
      <label>Receiver
        <select id="receiver-select" class="form-control">
          <option value="">All</option>
          <!-- Receiver options will be populated dynamically -->
        </select>
      </label>
      <button id="apply-btn" class="btn btn-primary">Search</button>
      <button id="reset-btn" class="btn btn-secondary">Reset</button>
    </div>
    
    <div id="error" class="error"></div>
    
    <div id="message-histogram"></div>
    
    <div id="map-container">
      <div class="speed-legend">
        <div class="speed-scale-container">
          <div class="speed-scale-bar"></div>
          <div class="speed-scale-labels">
            <span>0 kn</span>
            <span>40 kn</span>
          </div>
        </div>
      </div>
      <div class="replay-control">
        <button id="replay-button" class="replay-button">
          <svg xmlns="http://www.w3.org/2000/svg" width="12" height="12" fill="currentColor" viewBox="0 0 16 16">
            <path d="M11.596 8.697l-6.363 3.692c-.54.313-1.233-.066-1.233-.697V4.308c0-.63.692-1.01 1.233-.696l6.363 3.692a.802.802 0 0 1 0 1.393z"/>
          </svg>
          Replay
        </button>
        <select id="replay-duration" class="replay-duration">
          <option value="10">10s</option>
          <option value="20" selected>20s</option>
          <option value="30">30s</option>
          <option value="60">60s</option>
        </select>
        <div id="replay-progress" class="replay-progress"></div>
      </div>
    </div>
    
    <div class="changes-container">
      <div class="changes-table">
        <h3>Destination Changes</h3>
        <table id="destination-changes" class="table table-striped table-bordered">
          <thead>
            <tr>
              <th>Time</th>
              <th>From</th>
              <th>To</th>
              <th>ETA</th>
            </tr>
          </thead>
          <tbody>
            <!-- Destination changes will be inserted here -->
          </tbody>
        </table>
      </div>
      
      <div class="changes-table">
        <h3>Status Changes</h3>
        <table id="status-changes" class="table table-striped table-bordered">
          <thead>
            <tr>
              <th>Time</th>
              <th>From</th>
              <th>To</th>
            </tr>
          </thead>
          <tbody>
            <!-- Status changes will be inserted here -->
          </tbody>
        </table>
      </div>
    </div>
  </div>

  <!-- Include jQuery -->
  <script src="https://code.jquery.com/jquery-3.5.1.min.js"></script>
  <!-- Include Leaflet JS -->
  <script src="https://unpkg.com/leaflet@1.9.3/dist/leaflet.js"
          integrity="sha256-WBkoXOwTeyKclOHuWtc+i2uENFpDZ9YPdf5Hf+D7ewM=" crossorigin=""></script>
  <script>
    // Get UserID from URL query parameter
    function getQueryParam(name) {
      const urlParams = new URLSearchParams(window.location.search);
      return urlParams.get(name);
    }

    const userID = getQueryParam('UserID');
    let midsMapping = {};
    let shipTypeConfig = {};
    let navStatusMapping = {};
    let receiversData = []; // Store receivers data globally

    // Format time difference as a human-readable string
    function formatTimeDifference(timestamp) {
      const now = new Date();
      const date = new Date(timestamp);
      const diffMs = now - date;
      
      const seconds = Math.floor(diffMs / 1000);
      const minutes = Math.floor(seconds / 60);
      const hours = Math.floor(minutes / 60);
      const days = Math.floor(hours / 24);
      
      const remainingHours = hours % 24;
      const remainingMinutes = minutes % 60;
      const remainingSeconds = seconds % 60;
      
      let result = '';
      if (days > 0) result += `${days}d `;
      if (remainingHours > 0 || days > 0) result += `${remainingHours}h `;
      if (remainingMinutes > 0 || remainingHours > 0 || days > 0) result += `${remainingMinutes}m `;
      result += `${remainingSeconds}s ago`;
      
      return result;
    }

    // Load MIDs mapping, ship types, and nav status
    Promise.all([
      fetch('/mids.json').then(r => r.json()),
      fetch('/types.json').then(r => r.json()),
      fetch('/navstatus.json').then(r => r.json())
    ])
    .then(([midsData, typesData, navStatusData]) => {
      midsMapping = midsData;
      shipTypeConfig = typesData;
      navStatusMapping = navStatusData;
      loadVesselData();
    })
    .catch(err => {
      console.error('Error loading data:', err);
      document.getElementById('error').textContent = 'Failed to load reference data.';
      loadVesselData(); // Still try to load vessel data even if data loading fails
    });

    // Helper: given a numeric code and the types.json config, return the category name
    function lookupShipType(code) {
      if (!shipTypeConfig.valueLookup || !code) return code;
      
      const categoryId = shipTypeConfig.valueLookup[code];
      if (categoryId == null) return code;
      
      const category = shipTypeConfig.categories.find(cat => cat.id === categoryId);
      return category ? `${category.name} (ID: ${code})` : code;
    }

    // Helper: look up navigational status text
    function lookupNavStatus(code) {
      if (!navStatusMapping || code === undefined || code === null) return "Unknown";
      return navStatusMapping[code] || "Unknown";
    }

    function loadVesselData() {
      if (!userID) {
        document.getElementById('main-title').textContent = 'Error';
        document.getElementById('error').textContent = 'Missing UserID in URL.';
        return;
      }

      fetch(`/state?UserID=${userID}`, { cache: 'no-store' })
        .then(response => response.json())
        .then(data => {
          // Store AIS class globally for use in fetchVesselHistory
          vesselAisClass = data.AISClass || '';
          console.log('Vessel AIS Class:', vesselAisClass);
          
          // Update receiver dropdown if ReceiverIDs are available
          if (data.ReceiverIDs && Array.isArray(data.ReceiverIDs) && data.ReceiverIDs.length > 0) {
            console.log('Vessel heard by receivers:', data.ReceiverIDs);
            
            // Ensure receivers data is loaded
            if (receiversData.length === 0) {
              // If receivers data isn't loaded yet, fetch it now
              fetchReceiversData();
            } else {
              // Filter the receiver dropdown to only show receivers that heard this vessel
              const receiverSelect = document.getElementById('receiver-select');
              
              // Keep only the "All" option and receivers that heard this vessel
              while (receiverSelect.options.length > 1) {
                receiverSelect.remove(1);
              }
              
              // Add options for each receiver that heard this vessel
              receiversData.forEach(receiver => {
                if (data.ReceiverIDs.includes(receiver.id)) {
                  const option = document.createElement('option');
                  option.value = receiver.id;
                  option.textContent = receiver.name;
                  receiverSelect.appendChild(option);
                }
              });
            }
          }
          
          // Update page title with vessel name if available
          if (data.Name) {
            document.getElementById('main-title').textContent = `Vessel History: ${data.Name.trim()}`;
          } else {
            document.getElementById('main-title').textContent = `Vessel History: ${userID}`;
          }

          // Get country code from MID (first 3 digits of UserID)
          const mid = userID.toString().substring(0, 3);
          if (midsMapping[mid] && midsMapping[mid][0]) {
            const countryCode = midsMapping[mid][0].toLowerCase();
            const flagUrl = `/flags/${countryCode}.svg`;
            const flagImg = document.getElementById('flag-img');
            flagImg.src = flagUrl;
            flagImg.alt = `${midsMapping[mid][3]} Flag`;
            flagImg.style.display = 'block';
          }

          // Display vessel image if available
          if (data.ImageURL) {
            const vesselImg = document.getElementById('vessel-img');
            vesselImg.src = data.ImageURL;
            vesselImg.style.display = 'block';
          }

          // Create table rows for vessel information
          const leftTableBody = document.querySelector('#vessel-table-left tbody');
          const rightTableBody = document.querySelector('#vessel-table-right tbody');
          leftTableBody.innerHTML = ''; // Clear existing rows
          rightTableBody.innerHTML = ''; // Clear existing rows

          // Fields to display (if available)
          const fieldsToDisplay = [
            { key: 'UserID', label: 'MMSI' },
            { key: 'Name', label: 'Name' },
            { key: 'CallSign', label: 'Call Sign' },
            {
              key: 'ImoNumber',
              label: 'IMO Number',
              // Treat IMO Number = 0 as empty
              checkValue: (val) => val !== undefined && val !== null && val !== '' && val !== 0
            },
            { key: 'AISClass', label: 'AIS Class' },
            { key: 'Type', label: 'Type', format: (val) => lookupShipType(val) },
            {
              key: 'Flag',
              label: 'Flag',
              // Custom value that doesn't exist in the data object
              customValue: true,
              format: () => {
                // Get country name from MID (first 3 digits of UserID)
                const mid = userID.toString().substring(0, 3);
                if (midsMapping[mid] && midsMapping[mid][3]) {
                  return midsMapping[mid][3]; // 4th element is the full country name
                }
                return 'Unknown';
              }
            },
            { key: 'NavigationalStatus', label: 'Status', format: (val) => lookupNavStatus(val) },
            { key: 'Destination', label: 'Destination' },
            { key: 'MaximumStaticDraught', label: 'Max Draught', format: (val) => val ? `${val} m` : '' },
            {
              key: 'Dimension',
              label: 'Dimension',
              format: (val) => {
                if (!val || typeof val !== 'object') return '';
                const length = (val.A || 0) + (val.B || 0);
                const width = (val.C || 0) + (val.D || 0);
                return `${length}m × ${width}m`;
              }
            },
            {
              key: 'LastUpdated',
              label: 'Last Seen',
              format: (val) => {
                const localTime = new Date(val).toLocaleString();
                const timeDiff = formatTimeDifference(val);
                return `${localTime} (${timeDiff})`;
              }
            }
          ];

          // Add rows for each field if it exists and is not empty
          // Manually define which fields go in which table
          const leftTableFields = ['UserID', 'Name', 'CallSign', 'ImoNumber', 'AISClass', 'Type', 'Flag'];
          const rightTableFields = ['NavigationalStatus', 'Destination', 'MaximumStaticDraught', 'Dimension', 'LastUpdated'];
          
          // Process fields for left table
          fieldsToDisplay.filter(field => leftTableFields.includes(field.key)).forEach(field => {
            // Special cases for fields that should always be shown or have custom values
            const shouldDisplay = field.customValue ||
                                 field.key === 'NavigationalStatus' ||
                                 (field.checkValue ? field.checkValue(data[field.key]) :
                                  (data[field.key] !== undefined &&
                                   data[field.key] !== null &&
                                   data[field.key] !== ''));
            
            if (shouldDisplay) {
              const row = document.createElement('tr');
              
              const labelCell = document.createElement('td');
              labelCell.textContent = field.label;
              labelCell.style.fontWeight = 'bold';
              row.appendChild(labelCell);
              
              const valueCell = document.createElement('td');
              // For custom value fields, just call the format function directly
              if (field.customValue && field.format) {
                valueCell.textContent = field.format();
              } else {
                // Otherwise use formatter function if provided, or use raw value
                const value = data[field.key];
                valueCell.textContent = field.format ? field.format(value) : (value || '');
              }
              row.appendChild(valueCell);
              
              leftTableBody.appendChild(row);
            }
          });
          
          // Process fields for right table
          fieldsToDisplay.filter(field => rightTableFields.includes(field.key)).forEach(field => {
            // Special cases for fields that should always be shown or have custom values
            const shouldDisplay = field.customValue ||
                                 field.key === 'NavigationalStatus' ||
                                 (field.checkValue ? field.checkValue(data[field.key]) :
                                  (data[field.key] !== undefined &&
                                   data[field.key] !== null &&
                                   data[field.key] !== ''));
            
            if (shouldDisplay) {
              const row = document.createElement('tr');
              
              const labelCell = document.createElement('td');
              labelCell.textContent = field.label;
              labelCell.style.fontWeight = 'bold';
              row.appendChild(labelCell);
              
              const valueCell = document.createElement('td');
              // For custom value fields, just call the format function directly
              if (field.customValue && field.format) {
                valueCell.textContent = field.format();
              } else {
                // Otherwise use formatter function if provided, or use raw value
                const value = data[field.key];
                valueCell.textContent = field.format ? field.format(value) : (value || '');
              }
              row.appendChild(valueCell);
              
              rightTableBody.appendChild(row);
            }
          });

          // If no data was added to either table
          if (leftTableBody.children.length === 0 && rightTableBody.children.length === 0) {
            const row = document.createElement('tr');
            const cell = document.createElement('td');
            cell.colSpan = 2;
            cell.textContent = 'No vessel information available';
            row.appendChild(cell);
            leftTableBody.appendChild(row);
          }
        })
        .catch(err => {
          console.error('Error fetching vessel data:', err);
          document.getElementById('error').textContent = 'Failed to load vessel data.';
        });
    }

    // Fetch receivers data and populate the dropdown
    function fetchReceiversData() {
      fetch('/receivers', { cache: 'no-store' })
        .then(response => response.json())
        .then(data => {
          receiversData = data;
          const receiverSelect = document.getElementById('receiver-select');
          
          // Clear existing options except the "All" option
          while (receiverSelect.options.length > 1) {
            receiverSelect.remove(1);
          }
          
          // Add options for each receiver
          data.forEach(receiver => {
            const option = document.createElement('option');
            option.value = receiver.id;
            option.textContent = receiver.name;
            receiverSelect.appendChild(option);
          });
        })
        .catch(err => {
          console.error('Error fetching receivers data:', err);
        });
    }

    // Initialize date selectors with values from URL parameters or default to last 24 hours
    function initDateSelectors() {
      // Try to get start and end from URL parameters
      const startParam = getQueryParam('start');
      const endParam = getQueryParam('end');
      const receiverIdParam = getQueryParam('ReceiverID');
      
      let end, start;
      
      // If end parameter exists and is valid, use it; otherwise use current time
      if (endParam && !isNaN(new Date(endParam).getTime())) {
        end = new Date(endParam);
      } else {
        end = new Date();
      }
      
      // If start parameter exists and is valid, use it; otherwise use 24 hours before end
      if (startParam && !isNaN(new Date(startParam).getTime())) {
        start = new Date(startParam);
      } else {
        start = new Date(end);
        start.setDate(start.getDate() - 1); // 1 day ago
      }
      
      // Format the date for the datetime-local input in local time
      document.getElementById('end').value = formatDateForInput(end);
      document.getElementById('start').value = formatDateForInput(start);
      
      // Helper function to format a date for datetime-local input
      function formatDateForInput(date) {
        const year = date.getFullYear();
        const month = String(date.getMonth() + 1).padStart(2, '0');
        const day = String(date.getDate()).padStart(2, '0');
        const hours = String(date.getHours()).padStart(2, '0');
        const minutes = String(date.getMinutes()).padStart(2, '0');
        return `${year}-${month}-${day}T${hours}:${minutes}`;
      }
      
      // Set receiver dropdown if ReceiverID parameter exists
      if (receiverIdParam) {
        // We'll set this once the receivers are loaded
        const checkReceiverInterval = setInterval(() => {
          const receiverSelect = document.getElementById('receiver-select');
          if (receiverSelect.options.length > 1) {
            // Find the option with the matching value
            for (let i = 0; i < receiverSelect.options.length; i++) {
              if (receiverSelect.options[i].value === receiverIdParam) {
                receiverSelect.selectedIndex = i;
                break;
              }
            }
            clearInterval(checkReceiverInterval);
          }
        }, 100);
      }
    }

    // Initialize map
    let map = null;
    let mapLayerGroup = null;

    function initMap() {
      if (!map) {
        map = L.map('map-container').setView([0, 0], 2);
        L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
          attribution: '&copy; OpenStreetMap contributors'
        }).addTo(map);
        mapLayerGroup = L.layerGroup().addTo(map);
      }
    }

    // Fetch vessel history data
    async function fetchVesselHistory() {
      const startInput = document.getElementById('start');
      const endInput = document.getElementById('end');
      const s = startInput.value, e = endInput.value;
      
      if (!s || !e) {
        alert('Please select From and To dates.');
        return null;
      }

      // Always request all message types regardless of AIS Class
      let positionMessageTypes = ['1', '2', '3', '18', '19']; // All position messages (Class A and B)
      let staticMessageTypes = ['5', '24'];                   // All static messages (Class A and B)

      const startTime = new Date(s).toISOString();
      const endTime = new Date(e).toISOString();
      const limit = 2000;

      try {
        // Get selected receiver ID
        const receiverSelect = document.getElementById('receiver-select');
        const selectedReceiverId = receiverSelect.value;
        
        // Create base parameters for both calls
        const positionParams = {
          UserID: userID,
          MessageID: positionMessageTypes.join(','),
          start: startTime,
          end: endTime,
          limit: limit
        };
        
        const staticParams = {
          UserID: userID,
          MessageID: staticMessageTypes.join(','),
          start: startTime,
          end: endTime,
          limit: limit
        };
        
        // Add ReceiverID parameter if a specific receiver is selected
        if (selectedReceiverId) {
          positionParams.ReceiverID = selectedReceiverId;
          staticParams.ReceiverID = selectedReceiverId;
        }
        
        // Make two separate calls for position and static messages
        const [positionResponse, staticResponse] = await Promise.all([
          // Position messages call
          fetch(`/latestmessages?${new URLSearchParams(positionParams)}`, {cache: 'no-store'}),
          
          // Static messages call
          fetch(`/latestmessages?${new URLSearchParams(staticParams)}`, {cache: 'no-store'})
        ]);

        // Parse both responses
        const positionData = await positionResponse.json();
        const staticData = await staticResponse.json();
        
        // Check if either response has the same number of results as the limit
        const positionCount = positionData.length;
        const staticCount = staticData.length;
        const combinedResults = [...positionData, ...staticData];
        
        // If either count matches the limit, show a warning
        if (positionCount === limit || staticCount === limit) {
          const warningDiv = document.getElementById('error');
          warningDiv.textContent = `Warning: Some data may be missing. ${positionCount === limit ? 'Position' : ''} ${positionCount === limit && staticCount === limit ? 'and' : ''} ${staticCount === limit ? 'Static' : ''} data reached the limit of ${limit} records. Try reducing the time range.`;
          warningDiv.style.display = 'block';
        } else {
          // Clear any previous warnings
          document.getElementById('error').textContent = '';
        }
        
        return combinedResults;
      } catch (err) {
        console.error('Error fetching vessel history:', err);
        alert('Failed to fetch vessel history data.');
        return null;
      }
    }

    // Function to get color based on speed
    function getColorForSpeed(speed) {
      const maxSpeed = 40;  // maximum expected speed in knots
      // Clamp the speed value between 0 and maxSpeed
      const clampedSpeed = Math.max(0, Math.min(maxSpeed, speed));
      // Compute a ratio (0 = 0 knots, 1 = maxSpeed)
      const ratio = clampedSpeed / maxSpeed;
      // Calculate hue: 120 (green) at 0 knots to 0 (red) at maxSpeed knots.
      const hue = (1 - ratio) * 120;
      // Return a string with full saturation and 50% lightness.
      return `hsl(${hue}, 100%, 50%)`;
    }

    // Create a colored track with segments colored by speed
    function createColoredTrack(points) {
      const segments = [];
      // Loop through the points to create segments
      for (let i = 0; i < points.length - 1; i++) {
        const pt1 = points[i];
        const pt2 = points[i + 1];
        // Use the speed of the first point for the color
        const speed = pt1.data.Sog != null ? pt1.data.Sog : 0;
        const color = getColorForSpeed(speed);
        // Create a polyline segment with this color
        const segment = L.polyline([[pt1.lat, pt1.lng], [pt2.lat, pt2.lng]], {
          color: color,
          weight: 3,
          opacity: 0.8
        });
        segments.push(segment);
      }
      // Group the segments so they can be treated as one layer
      return L.layerGroup(segments);
    }

    // Helper to format one point's tooltip HTML
    function makeTooltipHTML(pt) {
      const timestamp = new Date(pt.timestamp).toLocaleString();
      let html = `<strong>${timestamp}</strong><br/>`;
      html += `<strong>Latitude:</strong> ${pt.lat.toFixed(6)}<br/>`;
      html += `<strong>Longitude:</strong> ${pt.lng.toFixed(6)}<br/>`;
      
      // Add other interesting fields if available
      const fields = ['Sog', 'Cog', 'TrueHeading', 'NavigationalStatus', 'Destination'];
      fields.forEach((field, index) => {
        if (pt.data[field] != null) {
          let value = pt.data[field];
          let displayField = field;
          
          // Rename fields for display and format values
          if (field === 'TrueHeading') {
            displayField = 'Heading';
            value = `${value}°`;
          } else if (field === 'NavigationalStatus') {
            displayField = 'Status';
            if (navStatusMapping[value]) {
              value = navStatusMapping[value];
            }
          } else if (field === 'Sog') {
            displayField = 'Speed';
            value = `${value} kn`;
          } else if (field === 'Cog') {
            displayField = 'Course';
            value = `${value}°`;
          }
          
          html += `<strong>${displayField}:</strong> ${value}`;
          
          // Add line break after each field except the last one
          // Only add a line break if this isn't the last field with data
          const isLastFieldWithData = index === fields.length - 1 ||
            fields.slice(index + 1).every(nextField => pt.data[nextField] == null);
          
          if (!isLastFieldWithData) {
            html += '<br/>';
          }
        }
      });
      
      return html;
    }
    
    // Display vessel track on map
    function displayVesselTrack(historyData) {
      if (!historyData || !historyData.length) {
        return;
      }

      // Store the current history data globally for use with time filtering
      window.currentHistoryData = historyData;

      // Clear existing layers
      mapLayerGroup.clearLayers();
      
      // Prepare points with valid coordinates
      const pts = historyData
        .filter(r => {
          const flat = flatten(r.Packet);
          return flat.Latitude != null && flat.Longitude != null &&
                 !isNaN(flat.Latitude) && !isNaN(flat.Longitude);
        })
        .map(r => {
          const flat = flatten(r.Packet);
          return {
            lat: flat.Latitude,
            lng: flat.Longitude,
            timestamp: r.Timestamp,
            record: r,
            data: flat
          };
        });

      if (!pts.length) {
        console.log('No valid position data found');
        return;
      }
      
      // Sort points by timestamp (newest first)
      pts.sort((a, b) => new Date(b.timestamp) - new Date(a.timestamp));
      
      // Create colored track based on speed
      const coloredTrack = createColoredTrack(pts);
      coloredTrack.addTo(mapLayerGroup);
      
      // Tooltip options
      const tooltipOpts = {
        direction: 'top',
        offset: [0, -6],
        permanent: false,
        sticky: true
      };
      
      // Use the global makeTooltipHTML function
      
      // Create a layer group for temporary connection lines
      const connectionLayerGroup = L.layerGroup().addTo(map);
      
      // Add tooltips to each segment in the colored track
      coloredTrack.eachLayer(segment => {
        segment.bindTooltip('', tooltipOpts);
        
        segment.on('mousemove', e => {
          // Find the nearest point to where the mouse is
          let minDist = Infinity, nearestPoint = null;
          pts.forEach(pt => {
            const ptLatLng = L.latLng(pt.lat, pt.lng);
            const d = e.latlng.distanceTo(ptLatLng);
            if (d < minDist) {
              minDist = d;
              nearestPoint = pt;
            }
          });
          
          if (nearestPoint) {
            // Use let instead of const for html variable to allow modification
            let html = makeTooltipHTML(nearestPoint);
            
            // Check if the record has a ReceiverID
            const receiverId = nearestPoint.record.ReceiverID;
            if (receiverId && receiversData.length > 0) {
              // Find the receiver in receiversData
              const receiver = receiversData.find(r => r.id === receiverId);
              if (receiver && receiver.latitude && receiver.longitude) {
                // Calculate distance in kilometers
                const pointLatLng = L.latLng(nearestPoint.lat, nearestPoint.lng);
                const receiverLatLng = L.latLng(receiver.latitude, receiver.longitude);
                const distanceKm = (pointLatLng.distanceTo(receiverLatLng) / 1000).toFixed(2);
                
                // Add receiver info to tooltip with proper formatting
                html += `<br/><strong>Receiver:</strong> ${receiver.name} (${distanceKm} km)`;
                
                // Clear previous connection lines
                connectionLayerGroup.clearLayers();
                
                // Draw a dashed grey line between the point and the receiver
                const connectionLine = L.polyline(
                  [[nearestPoint.lat, nearestPoint.lng], [receiver.latitude, receiver.longitude]],
                  {
                    color: 'grey',
                    weight: 2,
                    opacity: 0.7,
                    dashArray: '5, 7'
                  }
                ).addTo(connectionLayerGroup);
                
                // Find and highlight the active receiver tooltip
                document.querySelectorAll('.leaflet-tooltip').forEach(tooltip => {
                  // Remove active class from all tooltips
                  tooltip.classList.remove('receiver-tooltip-active');
                  
                  // Add active class to the matching receiver tooltip
                  if (tooltip.textContent === receiver.name) {
                    tooltip.classList.add('receiver-tooltip-active');
                  }
                });
              }
            }
            
            segment.setTooltipContent(html);
            segment.openTooltip(e.latlng);
          }
        });
        
        segment.on('mouseout', () => {
          segment.closeTooltip();
          // Clear connection lines when mouse leaves the segment
          connectionLayerGroup.clearLayers();
          
          // Remove active class from all receiver tooltips
          document.querySelectorAll('.leaflet-tooltip').forEach(tooltip => {
            tooltip.classList.remove('receiver-tooltip-active');
          });
        });
      });
      
      // Add markers at the first and last points with tooltips
      const first = pts[pts.length - 1]; // Oldest point
      const last = pts[0]; // Newest point
      
      const startMarker = L.marker([first.lat, first.lng], {
        icon: L.divIcon({
          className: 'start-marker',
          html: '🔵',
          iconSize: [20, 20],
          iconAnchor: [10, 10]
        })
      }).addTo(mapLayerGroup);
      startMarker.bindTooltip('Start: ' + new Date(first.timestamp).toLocaleString(), tooltipOpts);
      
      // Add mouseover event to start marker to show connection to receiver
      startMarker.on('mouseover', () => {
        // Clear previous connection lines
        connectionLayerGroup.clearLayers();
        
        // Check if the record has a ReceiverID
        const receiverId = first.record.ReceiverID;
        if (receiverId && receiversData.length > 0) {
          // Find the receiver in receiversData
          const receiver = receiversData.find(r => r.id === receiverId);
          if (receiver && receiver.latitude && receiver.longitude) {
            // Calculate distance in kilometers
            const pointLatLng = L.latLng(first.lat, first.lng);
            const receiverLatLng = L.latLng(receiver.latitude, receiver.longitude);
            const distanceKm = (pointLatLng.distanceTo(receiverLatLng) / 1000).toFixed(2);
            
            // Update tooltip content
            const tooltipContent = `Start: ${new Date(first.timestamp).toLocaleString()}<br/><strong>Receiver:</strong> ${receiver.name} (${distanceKm} km)`;
            startMarker.setTooltipContent(tooltipContent);
            
            // Draw a dashed grey line between the point and the receiver
            const connectionLine = L.polyline(
              [[first.lat, first.lng], [receiver.latitude, receiver.longitude]],
              {
                color: 'grey',
                weight: 2,
                opacity: 0.7,
                dashArray: '5, 7'
              }
            ).addTo(connectionLayerGroup);
          }
        }
      });
      
      startMarker.on('mouseout', () => {
        // Clear connection lines when mouse leaves the marker
        connectionLayerGroup.clearLayers();
      });
      
      const endMarker = L.marker([last.lat, last.lng], {
        icon: L.divIcon({
          className: 'end-marker',
          html: '🔴',
          iconSize: [20, 20],
          iconAnchor: [10, 10]
        })
      }).addTo(mapLayerGroup);
      endMarker.bindTooltip('End: ' + new Date(last.timestamp).toLocaleString(), tooltipOpts);
      
      // Add mouseover event to end marker to show connection to receiver
      endMarker.on('mouseover', () => {
        // Clear previous connection lines
        connectionLayerGroup.clearLayers();
        
        // Check if the record has a ReceiverID
        const receiverId = last.record.ReceiverID;
        if (receiverId && receiversData.length > 0) {
          // Find the receiver in receiversData
          const receiver = receiversData.find(r => r.id === receiverId);
          if (receiver && receiver.latitude && receiver.longitude) {
            // Calculate distance in kilometers
            const pointLatLng = L.latLng(last.lat, last.lng);
            const receiverLatLng = L.latLng(receiver.latitude, receiver.longitude);
            const distanceKm = (pointLatLng.distanceTo(receiverLatLng) / 1000).toFixed(2);
            
            // Update tooltip content
            const tooltipContent = `End: ${new Date(last.timestamp).toLocaleString()}<br/><strong>Receiver:</strong> ${receiver.name} (${distanceKm} km)`;
            endMarker.setTooltipContent(tooltipContent);
            
            // Draw a dashed grey line between the point and the receiver
            const connectionLine = L.polyline(
              [[last.lat, last.lng], [receiver.latitude, receiver.longitude]],
              {
                color: 'grey',
                weight: 2,
                opacity: 0.7,
                dashArray: '5, 7'
              }
            ).addTo(connectionLayerGroup);
          }
        }
      });
      
      endMarker.on('mouseout', () => {
        // Clear connection lines when mouse leaves the marker
        connectionLayerGroup.clearLayers();
      });
      
      // Add receiver markers for receivers that heard this vessel
      // Get the vessel data to find which receivers heard it
      fetch(`/state?UserID=${userID}`, { cache: 'no-store' })
        .then(response => response.json())
        .then(data => {
          if (data.ReceiverIDs && Array.isArray(data.ReceiverIDs) && data.ReceiverIDs.length > 0) {
            // Filter receivers to only those that heard this vessel
            const relevantReceivers = receiversData.filter(receiver =>
              data.ReceiverIDs.includes(receiver.id)
            );
            
            // Add a marker for each receiver
            relevantReceivers.forEach(receiver => {
              if (receiver.latitude && receiver.longitude) {
                // Create a red circle marker for the receiver
                const receiverMarker = L.circleMarker([receiver.latitude, receiver.longitude], {
                  radius: 6,
                  color: 'red',
                  fillColor: '#f03',
                  fillOpacity: 0.8,
                  weight: 2
                }).addTo(mapLayerGroup);
                
                // Add a permanent tooltip with the receiver name
                receiverMarker.bindTooltip(receiver.name, {
                  permanent: true,
                  direction: 'top',
                  offset: [0, -10],
                  className: 'receiver-tooltip'
                }).openTooltip();
              }
            });
          }
        })
        .catch(err => {
          console.error('Error fetching vessel data for receiver markers:', err);
        });
      
      // Fit map to vessel track data only (not including receivers)
      const latlngs = pts.map(p => [p.lat, p.lng]);
      map.fitBounds(L.latLngBounds(latlngs).pad(0.2));
    }

    // Track changes in destination and navigational status
    function trackChanges(historyData) {
      if (!historyData || !historyData.length) {
        return;
      }
      
      // Sort by timestamp (oldest first)
      const sortedData = [...historyData].sort((a, b) =>
        new Date(a.Timestamp) - new Date(b.Timestamp)
      );
      
      const destinationChanges = [];
      const statusChanges = [];
      
      let lastDestination = null;
      let lastStatus = null;
      let firstRecord = null;
      let firstStaticRecord = null;
      let firstPositionRecord = null;
      
      // Find the first record with static data (containing Destination field)
      // and the first record with position data (containing NavigationalStatus field)
      for (const record of sortedData) {
        const flat = flatten(record.Packet);
        
        // Store the first record for general use
        if (!firstRecord) {
          firstRecord = record;
        }
        
        // Find the first record with Destination field (static message)
        if (!firstStaticRecord && flat.Destination !== undefined) {
          firstStaticRecord = record;
        }
        
        // Find the first record with NavigationalStatus field (position message)
        if (!firstPositionRecord &&
            (record.MessageID === 1 || record.MessageID === 2 || record.MessageID === 3 ||
             record.MessageID === 18 || record.MessageID === 19) &&
            record.Packet && record.Packet.NavigationalStatus !== undefined) {
          firstPositionRecord = record;
          console.log('Found position record with NavigationalStatus:', record);
        }
        
        // If we found both types of records, we can break early
        if (firstStaticRecord && firstPositionRecord) {
          break;
        }
      }
      
      // If we didn't find a record with Destination, use the first record
      if (!firstStaticRecord && sortedData.length > 0) {
        firstStaticRecord = firstRecord;
      }
      
      // If we didn't find a position record, use the first record
      if (!firstPositionRecord && sortedData.length > 0) {
        firstPositionRecord = firstRecord;
      }
      
      sortedData.forEach(record => {
        const flat = flatten(record.Packet);
        const timestamp = record.Timestamp;
        
        // Track destination changes
        if (flat.Destination !== undefined) {
          const currentDestination = flat.Destination || '';
          if (lastDestination !== null && currentDestination !== lastDestination) {
            // Include ETA if available
            let etaStr = '';
            // Access ETA directly from the original packet, not the flattened structure
            if (record.Packet && record.Packet.Eta) {
              etaStr = formatEta(record.Packet.Eta);
            }
            
            destinationChanges.push({
              timestamp,
              from: lastDestination,
              to: currentDestination,
              eta: etaStr
            });
          }
          lastDestination = currentDestination;
        }
        
        // Track navigational status changes
        if (flat.NavigationalStatus !== undefined) {
          const currentStatus = flat.NavigationalStatus;
          if (lastStatus !== null && currentStatus !== lastStatus) {
            statusChanges.push({
              timestamp,
              from: lastStatus,
              to: currentStatus
            });
          }
          lastStatus = currentStatus;
        }
      });
      
      // Display destination changes
      const destTable = document.querySelector('#destination-changes tbody');
      destTable.innerHTML = '';
      
      if (destinationChanges.length > 0) {
        destinationChanges.forEach(change => {
          const row = document.createElement('tr');
          
          const timeCell = document.createElement('td');
          timeCell.textContent = new Date(change.timestamp).toLocaleString();
          row.appendChild(timeCell);
          
          const fromCell = document.createElement('td');
          fromCell.textContent = change.from || '(empty)';
          row.appendChild(fromCell);
          
          const toCell = document.createElement('td');
          toCell.textContent = change.to || '(empty)';
          row.appendChild(toCell);
          
          // Add ETA cell
          const etaCell = document.createElement('td');
          etaCell.textContent = change.eta || '';
          row.appendChild(etaCell);
          
          destTable.appendChild(row);
        });
      } else if (firstStaticRecord) {
        // If no changes but we have static data, show the current value
        const flat = flatten(firstStaticRecord.Packet);
        if (flat.Destination !== undefined) {
          const row = document.createElement('tr');
          
          const timeCell = document.createElement('td');
          timeCell.textContent = new Date(firstStaticRecord.Timestamp).toLocaleString();
          row.appendChild(timeCell);
          
          const fromCell = document.createElement('td');
          fromCell.textContent = '';
          row.appendChild(fromCell);
          
          const toCell = document.createElement('td');
          toCell.textContent = flat.Destination || '(empty)';
          row.appendChild(toCell);
          
          // Add ETA cell
          const etaCell = document.createElement('td');
          // Access ETA directly from the original packet, not the flattened structure
          if (firstStaticRecord.Packet && firstStaticRecord.Packet.Eta) {
            etaCell.textContent = formatEta(firstStaticRecord.Packet.Eta);
          }
          row.appendChild(etaCell);
          
          destTable.appendChild(row);
        } else {
          const row = document.createElement('tr');
          const cell = document.createElement('td');
          cell.colSpan = 4;
          cell.className = 'no-changes';
          cell.textContent = 'No destination information available';
          row.appendChild(cell);
          destTable.appendChild(row);
        }
      } else {
        const row = document.createElement('tr');
        const cell = document.createElement('td');
        cell.colSpan = 4;
        cell.className = 'no-changes';
        cell.textContent = 'No destination changes detected';
        row.appendChild(cell);
        destTable.appendChild(row);
      }
      
      // Display navigational status changes
      const statusTable = document.querySelector('#status-changes tbody');
      statusTable.innerHTML = '';
      
      if (statusChanges.length > 0) {
        statusChanges.forEach(change => {
          const row = document.createElement('tr');
          
          const timeCell = document.createElement('td');
          timeCell.textContent = new Date(change.timestamp).toLocaleString();
          row.appendChild(timeCell);
          
          const fromCell = document.createElement('td');
          fromCell.textContent = navStatusMapping[change.from] || change.from || '(unknown)';
          row.appendChild(fromCell);
          
          const toCell = document.createElement('td');
          toCell.textContent = navStatusMapping[change.to] || change.to || '(unknown)';
          row.appendChild(toCell);
          
          statusTable.appendChild(row);
        });
      } else if (firstPositionRecord) {
        // If no changes but we have position data, show the current value
        const row = document.createElement('tr');
        
        const timeCell = document.createElement('td');
        timeCell.textContent = new Date(firstPositionRecord.Timestamp).toLocaleString();
        row.appendChild(timeCell);
        
        const fromCell = document.createElement('td');
        fromCell.textContent = '';
        row.appendChild(fromCell);
        
        const toCell = document.createElement('td');
        
        // Get NavigationalStatus directly from the position record
        const navStatus = firstPositionRecord.Packet.NavigationalStatus;
        console.log('Position record:', firstPositionRecord);
        console.log('NavigationalStatus:', navStatus);
        console.log('Mapped value:', navStatusMapping[navStatus]);
        
        // Convert the status code to a readable string
        if (navStatus === 0) {
          // Special case for 0, which is "Using Engine"
          toCell.textContent = navStatusMapping[0] || "Using Engine";
        } else if (navStatus !== undefined) {
          toCell.textContent = navStatusMapping[navStatus] || `${navStatus}`;
        } else {
          toCell.textContent = '(unknown)';
        }
        row.appendChild(toCell);
        
        statusTable.appendChild(row);
      } else {
        const row = document.createElement('tr');
        const cell = document.createElement('td');
        cell.colSpan = 3;
        cell.className = 'no-changes';
        cell.textContent = 'No navigational status changes detected';
        row.appendChild(cell);
        statusTable.appendChild(row);
      }
    }

    // Format ETA from object to readable string
    function formatEta(eta) {
      if (!eta || typeof eta !== 'object') return '';
      
      const { Day, Month, Hour, Minute } = eta;
      if (Day === undefined || Month === undefined) return '';
      
      // Month is 1-based in the data
      const monthNames = [
        'January', 'February', 'March', 'April', 'May', 'June',
        'July', 'August', 'September', 'October', 'November', 'December'
      ];
      
      const monthName = monthNames[Month - 1] || '';
      let timeStr = '';
      
      if (Hour !== undefined && Minute !== undefined) {
        // Pad with leading zeros if needed
        const hourStr = Hour.toString().padStart(2, '0');
        const minStr = Minute.toString().padStart(2, '0');
        timeStr = ` ${hourStr}:${minStr}`;
      }
      
      return `${Day} ${monthName}${timeStr}`;
    }

    // Helper function to flatten nested objects
    function flatten(obj, prefix = '', res = {}) {
      for (const [k, v] of Object.entries(obj || {})) {
        const key = prefix ? `${prefix}.${k}` : k;
        if (v != null && typeof v === 'object' && !Array.isArray(v)) {
          flatten(v, key, res);
        } else {
          res[key] = v;
        }
      }
      return res;
    }

    // Store vessel AIS class globally
    let vesselAisClass = '';

    // Initialize the page
    document.addEventListener('DOMContentLoaded', () => {
      initDateSelectors();
      initMap();
      
      // Fetch receivers data
      fetchReceiversData();
      
      // Automatically load history data with default 1-day range
      setTimeout(async () => {
        const historyData = await fetchVesselHistory();
        if (historyData) {
          // Store the original history data
          window.originalHistoryData = historyData;
          window.currentHistoryData = historyData;
          
          displayVesselTrack(historyData);
          displayMessageHistogram(historyData);
          trackChanges(historyData);
          
          // Check for filter parameters in URL and restore if present
          checkForTimeFilterInUrl(historyData);
        }
      }, 1000); // Small delay to ensure vessel data is loaded first
      
      // Set up event listeners
      document.getElementById('copy-link-btn').addEventListener('click', async () => {
        const currentUrl = window.location.href;
        
        try {
          // Try to use the modern Clipboard API first
          if (navigator.clipboard && navigator.clipboard.writeText) {
            await navigator.clipboard.writeText(currentUrl);
          } else {
            // Fall back to the older method for browsers that don't support Clipboard API
            const tempInput = document.createElement('input');
            tempInput.value = currentUrl;
            document.body.appendChild(tempInput);
            tempInput.select();
            tempInput.setSelectionRange(0, 99999); // For mobile devices
            document.execCommand('copy');
            document.body.removeChild(tempInput);
          }
          
          // Visual feedback
          const btn = document.getElementById('copy-link-btn');
          const originalText = btn.innerHTML;
          btn.innerHTML = `
            <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" class="bi bi-check-lg" viewBox="0 0 16 16">
              <path d="M12.736 3.97a.733.733 0 0 1 1.047 0c.286.289.29.756.01 1.05L7.88 12.01a.733.733 0 0 1-1.065.02L3.217 8.384a.757.757 0 0 1 0-1.06.733.733 0 0 1 1.047 0l3.052 3.093 5.4-6.425a.247.247 0 0 1 .02-.022Z"/>
            </svg>
            Copied!
          `;
          
          // Reset button text after 2 seconds
          setTimeout(() => {
            btn.innerHTML = originalText;
          }, 2000);
        } catch (err) {
          console.error('Failed to copy URL to clipboard:', err);
        }
      });
      
      // Image overlay functionality
      const vesselImg = document.getElementById('vessel-img');
      const imageOverlay = document.getElementById('image-overlay');
      const overlayImg = document.getElementById('overlay-img');
      const closeOverlay = document.querySelector('.close-overlay');
      
      // Open overlay when clicking on vessel image
      vesselImg.addEventListener('click', () => {
        if (vesselImg.src) {
          overlayImg.src = vesselImg.src;
          imageOverlay.classList.add('active');
        }
      });
      
      // Close overlay when clicking on X button
      closeOverlay.addEventListener('click', () => {
        imageOverlay.classList.remove('active');
      });
      
      // Close overlay when clicking outside the image
      imageOverlay.addEventListener('click', (e) => {
        if (e.target === imageOverlay) {
          imageOverlay.classList.remove('active');
        }
      });
      
      document.getElementById('receiver-select').addEventListener('change', async () => {
        const historyData = await fetchVesselHistory();
        if (historyData) {
          displayVesselTrack(historyData);
          displayMessageHistogram(historyData);
          trackChanges(historyData);
        }
      });
      
      document.getElementById('apply-btn').addEventListener('click', async () => {
        // Update URL with current date range
        const startInput = document.getElementById('start');
        const endInput = document.getElementById('end');
        
        if (startInput.value && endInput.value) {
          // Create a new URL object based on the current URL
          const url = new URL(window.location.href);
          
          // Update or add the start and end parameters
          // Use the input values directly to preserve the exact selected time without timezone conversion
          const startDate = new Date(startInput.value);
          const endDate = new Date(endInput.value);
          
          // Format dates in a way that preserves the local time information
          url.searchParams.set('start', startDate.toISOString());
          url.searchParams.set('end', endDate.toISOString());
          
          // Add receiver ID to URL if selected
          const receiverSelect = document.getElementById('receiver-select');
          if (receiverSelect.value) {
            url.searchParams.set('ReceiverID', receiverSelect.value);
          } else {
            url.searchParams.delete('ReceiverID');
          }
          
          // Update the browser history without reloading the page
          window.history.replaceState({}, '', url);
        }
        
        const historyData = await fetchVesselHistory();
        if (historyData) {
          displayVesselTrack(historyData);
          displayMessageHistogram(historyData);
          trackChanges(historyData);
        }
      });
      
      document.getElementById('reset-btn').addEventListener('click', () => {
        initDateSelectors();
        
        // Clear map
        if (mapLayerGroup) {
          mapLayerGroup.clearLayers();
        }
        
        // Clear histogram
        document.getElementById('message-histogram').innerHTML = '';
        
        // Clear tables
        document.querySelector('#destination-changes tbody').innerHTML = '';
        document.querySelector('#status-changes tbody').innerHTML = '';
      });
    });

    // Store vessel AIS class globally - moved to loadVesselData function
    
    // Store the current time filter globally
    let timeFilter = {
      active: false,
      startTime: null,
      endTime: null
    };
    
    // Function to display message histogram
    function displayMessageHistogram(historyData) {
      if (!historyData || !historyData.length) {
        return;
      }
      
      const histogramContainer = document.getElementById('message-histogram');
      histogramContainer.innerHTML = '';
      
      // Filter for position messages only
      const positionMessageTypes = ['1', '2', '3', '18', '19'];
      const positionMessages = historyData.filter(msg =>
        positionMessageTypes.includes(msg.MessageID.toString())
      );
      
      if (positionMessages.length === 0) {
        histogramContainer.innerHTML = '<div style="padding: 10px; text-align: center; color: #666;">No position messages available</div>';
        return;
      }
      
      // Sort messages by timestamp (oldest first)
      positionMessages.sort((a, b) => new Date(a.Timestamp) - new Date(b.Timestamp));
      
      // Get time range
      const startTime = new Date(positionMessages[0].Timestamp);
      const endTime = new Date(positionMessages[positionMessages.length - 1].Timestamp);
      const totalDuration = endTime - startTime;
      
      // Target number of bins based on duration
      let targetBins, binLabel;
      if (totalDuration <= 3600000) { // 1 hour or less
        targetBins = 60; // ~1 minute bins for 1 hour
        binLabel = 'interval';
      } else if (totalDuration <= 86400000) { // 1 day or less
        targetBins = 96; // ~15 minute bins for 1 day
        binLabel = 'interval';
      } else {
        targetBins = 100; // ~43 minute bins for 3 days
        binLabel = 'interval';
      }
      
      // Calculate bin size based on target number of bins
      const binSize = Math.max(60000, Math.ceil(totalDuration / targetBins)); // Minimum 1 minute
      
      // Create bins
      const bins = {};
      const numBins = Math.ceil(totalDuration / binSize);
      
      // Initialize bins
      for (let i = 0; i < numBins; i++) {
        const binTime = new Date(startTime.getTime() + (i * binSize));
        bins[i] = {
          count: 0,
          startTime: binTime,
          endTime: new Date(binTime.getTime() + binSize)
        };
      }
      
      // Count messages in each bin
      positionMessages.forEach(msg => {
        const msgTime = new Date(msg.Timestamp);
        const binIndex = Math.floor((msgTime - startTime) / binSize);
        if (bins[binIndex]) {
          bins[binIndex].count++;
        }
      });
      
      // Find maximum count for scaling
      const maxCount = Math.max(...Object.values(bins).map(bin => bin.count));
      
      // Create SVG for histogram
      const svgNS = "http://www.w3.org/2000/svg";
      const svg = document.createElementNS(svgNS, "svg");
      svg.setAttribute("width", "100%");
      svg.setAttribute("height", "100%");
      
      // Calculate bar width based on number of bins
      const barWidth = 100 / numBins;
      
      // Create bars
      Object.values(bins).forEach((bin, index) => {
        const barHeight = bin.count > 0 ? (bin.count / maxCount) * 100 : 0;
        const bar = document.createElementNS(svgNS, "rect");
        
        // Position and size - ensure bars start from bottom (100%) and go up
        bar.setAttribute("x", `${index * barWidth}%`);
        bar.setAttribute("y", `${100 - barHeight}%`);
        bar.setAttribute("width", `${barWidth - 0.1}%`);
        bar.setAttribute("height", `${barHeight}%`);
        
        // Styling - blue scale based on count intensity
        const ratio = bin.count / maxCount;
        // Use a blue scale from light blue (low counts) to dark blue (high counts)
        const lightness = 80 - (ratio * 60); // 80% lightness (light blue) to 20% lightness (dark blue)
        bar.setAttribute("fill", `hsl(210, 100%, ${lightness}%)`);
        
        // Tooltip
        const title = document.createElementNS(svgNS, "title");
        
        // Format start date/time
        const formattedStart = bin.startTime.toLocaleString([], {
          day: 'numeric',
          month: 'short',
          hour: '2-digit',
          minute: '2-digit'
        });
        
        // Format end date/time
        const formattedEnd = bin.endTime.toLocaleString([], {
          day: 'numeric',
          month: 'short',
          hour: '2-digit',
          minute: '2-digit'
        });
        
        title.textContent = `${bin.count} position reports ${formattedStart} - ${formattedEnd}`;
        bar.appendChild(title);
        
        svg.appendChild(bar);
      });
      
      histogramContainer.appendChild(svg);
      
      // Store the time range data for selection functionality
      histogramContainer.dataset.startTime = startTime.toISOString();
      histogramContainer.dataset.endTime = endTime.toISOString();
      histogramContainer.dataset.numBins = numBins;
      
      // Add selection functionality
      setupHistogramSelection(histogramContainer, startTime, endTime, historyData);
    }
    
    // Setup selection functionality for the histogram
    function setupHistogramSelection(container, startTime, endTime, historyData) {
      // Remove any existing selection window
      const existingSelection = container.querySelector('.selection-window');
      if (existingSelection) {
        container.removeChild(existingSelection);
      }
      
      // Create selection window if there's an active filter
      if (timeFilter.active) {
        createSelectionWindow(container, startTime, endTime);
      }
      
      // Add click handler to create a new selection
      container.addEventListener('mousedown', function(e) {
        // Ignore if clicking on a handle
        if (e.target.classList.contains('selection-handle')) {
          return;
        }
        
        // Double click to remove selection
        if (e.detail === 2) {
          removeSelectionWindow();
          return;
        }
        
        // Remove any existing selection window first to ensure only one at a time
        removeSelectionWindow();
        
        // Calculate position as percentage
        const rect = container.getBoundingClientRect();
        const x = e.clientX - rect.left;
        const percentage = (x / rect.width) * 100;
        
        // Calculate time at click position
        const timeRange = endTime - startTime;
        const clickTime = new Date(startTime.getTime() + (timeRange * percentage / 100));
        
        // Create a small initial selection window (10% width)
        const halfWidth = 5; // 5% on each side
        const selectionStartTime = new Date(clickTime.getTime() - (timeRange * halfWidth / 100));
        const selectionEndTime = new Date(clickTime.getTime() + (timeRange * halfWidth / 100));
        
        // Set the time filter
        timeFilter = {
          active: true,
          startTime: selectionStartTime,
          endTime: selectionEndTime
        };
        
        // Create the selection window
        createSelectionWindow(container, startTime, endTime);
        
        // Apply the filter to the map
        applyTimeFilter(historyData);
        
        // Update URL with filter window parameters
        updateUrlWithTimeFilter();
      });
    }
    
    // Create a selection window based on the current time filter
    function createSelectionWindow(container, startTime, endTime) {
      if (!timeFilter.active) return;
      
      const totalDuration = endTime - startTime;
      
      // Calculate positions as percentages
      const startPercentage = ((timeFilter.startTime - startTime) / totalDuration) * 100;
      const endPercentage = ((timeFilter.endTime - startTime) / totalDuration) * 100;
      
      // Create selection window element
      const selectionWindow = document.createElement('div');
      selectionWindow.className = 'selection-window';
      selectionWindow.style.left = `${startPercentage}%`;
      selectionWindow.style.width = `${endPercentage - startPercentage}%`;
      
      // Create left handle
      const leftHandle = document.createElement('div');
      leftHandle.className = 'selection-handle selection-handle-left';
      selectionWindow.appendChild(leftHandle);
      
      // Create right handle
      const rightHandle = document.createElement('div');
      rightHandle.className = 'selection-handle selection-handle-right';
      selectionWindow.appendChild(rightHandle);
      
      // Create info label
      const infoLabel = document.createElement('div');
      infoLabel.className = 'selection-info';
      infoLabel.textContent = formatTimeRange(timeFilter.startTime, timeFilter.endTime);
      selectionWindow.appendChild(infoLabel);
      
      // Add to container
      container.appendChild(selectionWindow);
      
      // Setup drag handlers for the handles
      setupDragHandlers(container, leftHandle, rightHandle, startTime, endTime);
    }
    
    // Format a time range for display
    function formatTimeRange(start, end) {
      const formatOptions = {
        month: 'short',
        day: 'numeric',
        hour: '2-digit',
        minute: '2-digit'
      };
      return `${start.toLocaleString([], formatOptions)} - ${end.toLocaleString([], formatOptions)}`;
    }
    
    // Setup drag handlers for the selection window handles
    function setupDragHandlers(container, leftHandle, rightHandle, startTime, endTime) {
      const totalDuration = endTime - startTime;
      let isDragging = false;
      let currentHandle = null;
      
      // Function to handle mouse move during drag
      function handleDrag(e) {
        if (!isDragging || !currentHandle) return;
        
        const rect = container.getBoundingClientRect();
        const x = Math.max(0, Math.min(e.clientX - rect.left, rect.width));
        const percentage = (x / rect.width) * 100;
        
        // Calculate time at drag position
        const dragTime = new Date(startTime.getTime() + (totalDuration * percentage / 100));
        
        const selectionWindow = container.querySelector('.selection-window');
        const infoLabel = selectionWindow.querySelector('.selection-info');
        
        if (currentHandle.classList.contains('selection-handle-left')) {
          // Update left handle position
          if (dragTime < timeFilter.endTime) {
            timeFilter.startTime = dragTime;
            const startPercentage = ((timeFilter.startTime - startTime) / totalDuration) * 100;
            const endPercentage = ((timeFilter.endTime - startTime) / totalDuration) * 100;
            selectionWindow.style.left = `${startPercentage}%`;
            selectionWindow.style.width = `${endPercentage - startPercentage}%`;
          }
        } else {
          // Update right handle position
          if (dragTime > timeFilter.startTime) {
            timeFilter.endTime = dragTime;
            const startPercentage = ((timeFilter.startTime - startTime) / totalDuration) * 100;
            const endPercentage = ((timeFilter.endTime - startTime) / totalDuration) * 100;
            selectionWindow.style.width = `${endPercentage - startPercentage}%`;
          }
        }
        
        // Update info label
        infoLabel.textContent = formatTimeRange(timeFilter.startTime, timeFilter.endTime);
      }
      
      // Function to end dragging
      function endDrag() {
        if (isDragging) {
          isDragging = false;
          document.removeEventListener('mousemove', handleDrag);
          document.removeEventListener('mouseup', endDrag);
          
          // Apply the filter to the map
          const historyData = window.originalHistoryData || window.currentHistoryData;
          if (historyData) {
            applyTimeFilter(historyData);
            
            // Update URL with filter window parameters
            updateUrlWithTimeFilter();
          }
        }
      }
      
      // Set up left handle drag
      leftHandle.addEventListener('mousedown', function(e) {
        e.stopPropagation();
        isDragging = true;
        currentHandle = leftHandle;
        document.addEventListener('mousemove', handleDrag);
        document.addEventListener('mouseup', endDrag);
      });
      
      // Set up right handle drag
      rightHandle.addEventListener('mousedown', function(e) {
        e.stopPropagation();
        isDragging = true;
        currentHandle = rightHandle;
        document.addEventListener('mousemove', handleDrag);
        document.addEventListener('mouseup', endDrag);
      });
    }
    
    // Remove the selection window and clear the time filter
    function removeSelectionWindow() {
      const container = document.getElementById('message-histogram');
      const selectionWindow = container.querySelector('.selection-window');
      if (selectionWindow) {
        container.removeChild(selectionWindow);
      }
      
      // Clear the time filter
      timeFilter = {
        active: false,
        startTime: null,
        endTime: null
      };
      
      // Store the original data back to currentHistoryData
      const originalHistoryData = window.originalHistoryData || window.currentHistoryData;
      
      // Restore the original map display
      if (originalHistoryData) {
        // Reset currentHistoryData to the original data
        window.currentHistoryData = originalHistoryData;
        
        // Display the original data
        displayVesselTrack(originalHistoryData);
        
        // Remove filter parameters from URL
        removeTimeFilterFromUrl();
      }
    }
    
    // Update URL with time filter parameters
    function updateUrlWithTimeFilter() {
      if (!timeFilter.active) return;
      
      // Create a new URL object based on the current URL
      const url = new URL(window.location.href);
      
      // Add or update the filter parameters
      url.searchParams.set('filterStart', timeFilter.startTime.toISOString());
      url.searchParams.set('filterEnd', timeFilter.endTime.toISOString());
      
      // Update the browser history without reloading the page
      window.history.replaceState({}, '', url);
    }
    
    // Remove time filter parameters from URL
    function removeTimeFilterFromUrl() {
      // Create a new URL object based on the current URL
      const url = new URL(window.location.href);
      
      // Remove the filter parameters
      url.searchParams.delete('filterStart');
      url.searchParams.delete('filterEnd');
      
      // Update the browser history without reloading the page
      window.history.replaceState({}, '', url);
    }
    
    // Apply time filter to the map
    function applyTimeFilter(historyData) {
      if (!timeFilter.active || !historyData) return;
      
      // Store the original data if not already stored
      if (!window.originalHistoryData) {
        window.originalHistoryData = historyData;
      }
      
      // Filter the data based on the time range
      const filteredData = historyData.filter(record => {
        const timestamp = new Date(record.Timestamp);
        return timestamp >= timeFilter.startTime && timestamp <= timeFilter.endTime;
      });
      
      // Store the filtered data globally so it can be accessed by the connection line code
      window.currentHistoryData = filteredData;
      
      // Update the map with filtered data but don't store as current data
      displayVesselTrackFiltered(filteredData);
    }
    
    // Display filtered vessel track on map without changing the original data
    function displayVesselTrackFiltered(historyData) {
      if (!historyData || !historyData.length) {
        return;
      }

      // Clear existing layers
      mapLayerGroup.clearLayers();
      
      // Prepare points with valid coordinates
      const pts = historyData
        .filter(r => {
          const flat = flatten(r.Packet);
          return flat.Latitude != null && flat.Longitude != null &&
                 !isNaN(flat.Latitude) && !isNaN(flat.Longitude);
        })
        .map(r => {
          const flat = flatten(r.Packet);
          return {
            lat: flat.Latitude,
            lng: flat.Longitude,
            timestamp: r.Timestamp,
            record: r,
            data: flat
          };
        });

      if (!pts.length) {
        console.log('No valid position data found');
        return;
      }
      
      // Sort points by timestamp (newest first)
      pts.sort((a, b) => new Date(b.timestamp) - new Date(a.timestamp));
      
      // Create colored track based on speed
      const coloredTrack = createColoredTrack(pts);
      coloredTrack.addTo(mapLayerGroup);
      
      // Tooltip options
      const tooltipOpts = {
        direction: 'top',
        offset: [0, -6],
        permanent: false,
        sticky: true
      };
      
      // Create a layer group for temporary connection lines
      const connectionLayerGroup = L.layerGroup().addTo(map);
      
      // Add tooltips to each segment in the colored track
      coloredTrack.eachLayer(segment => {
        segment.bindTooltip('', tooltipOpts);
        
        segment.on('mousemove', e => {
          // Find the nearest point to where the mouse is
          let minDist = Infinity, nearestPoint = null;
          pts.forEach(pt => {
            const ptLatLng = L.latLng(pt.lat, pt.lng);
            const d = e.latlng.distanceTo(ptLatLng);
            if (d < minDist) {
              minDist = d;
              nearestPoint = pt;
            }
          });
          
          if (nearestPoint) {
            let html = makeTooltipHTML(nearestPoint);
            
            // Clear previous connection lines
            connectionLayerGroup.clearLayers();
            
            // Check if the record has a ReceiverID
            const receiverId = nearestPoint.record.ReceiverID;
            if (receiverId && receiversData.length > 0) {
              // Find the receiver in receiversData
              const receiver = receiversData.find(r => r.id === receiverId);
              if (receiver && receiver.latitude && receiver.longitude) {
                // Draw a dashed grey line between the point and the receiver
                const connectionLine = L.polyline(
                  [[nearestPoint.lat, nearestPoint.lng], [receiver.latitude, receiver.longitude]],
                  {
                    color: 'grey',
                    weight: 2,
                    opacity: 0.7,
                    dashArray: '5, 7'
                  }
                ).addTo(connectionLayerGroup);
                
                // Calculate distance in kilometers
                const pointLatLng = L.latLng(nearestPoint.lat, nearestPoint.lng);
                const receiverLatLng = L.latLng(receiver.latitude, receiver.longitude);
                const distanceKm = (pointLatLng.distanceTo(receiverLatLng) / 1000).toFixed(2);
                
                // Add receiver info to tooltip with proper formatting
                html += `<br/><strong>Receiver:</strong> ${receiver.name} (${distanceKm} km)`;
                
                // Find and highlight the active receiver tooltip
                document.querySelectorAll('.leaflet-tooltip').forEach(tooltip => {
                  // Remove active class from all tooltips
                  tooltip.classList.remove('receiver-tooltip-active');
                  
                  // Add active class to the matching receiver tooltip
                  if (tooltip.textContent === receiver.name) {
                    tooltip.classList.add('receiver-tooltip-active');
                  }
                });
              }
            }
            
            // Update tooltip content with the complete HTML including receiver info
            segment.setTooltipContent(html);
            segment.openTooltip(e.latlng);
          }
        });
        
        segment.on('mouseout', () => {
          segment.closeTooltip();
          // Clear connection lines when mouse leaves the segment
          connectionLayerGroup.clearLayers();
          
          // Remove active class from all receiver tooltips
          document.querySelectorAll('.leaflet-tooltip').forEach(tooltip => {
            tooltip.classList.remove('receiver-tooltip-active');
          });
        });
      });
      
      // Add markers at the first and last points with tooltips
      const first = pts[pts.length - 1]; // Oldest point
      const last = pts[0]; // Newest point
      
      const startMarker = L.marker([first.lat, first.lng], {
        icon: L.divIcon({
          className: 'start-marker',
          html: '🔵',
          iconSize: [20, 20],
          iconAnchor: [10, 10]
        })
      }).addTo(mapLayerGroup);
      startMarker.bindTooltip('Start: ' + new Date(first.timestamp).toLocaleString(), tooltipOpts);
      
      // Add mouseover event to start marker to show connection to receiver
      startMarker.on('mouseover', () => {
        // Clear previous connection lines
        connectionLayerGroup.clearLayers();
        
        // Check if the record has a ReceiverID
        const receiverId = first.record.ReceiverID;
        if (receiverId && receiversData.length > 0) {
          // Find the receiver in receiversData
          const receiver = receiversData.find(r => r.id === receiverId);
          if (receiver && receiver.latitude && receiver.longitude) {
            // Calculate distance in kilometers
            const pointLatLng = L.latLng(first.lat, first.lng);
            const receiverLatLng = L.latLng(receiver.latitude, receiver.longitude);
            const distanceKm = (pointLatLng.distanceTo(receiverLatLng) / 1000).toFixed(2);
            
            // Update tooltip content
            const tooltipContent = `Start: ${new Date(first.timestamp).toLocaleString()}<br/><strong>Receiver:</strong> ${receiver.name} / ${distanceKm} km`;
            startMarker.setTooltipContent(tooltipContent);
            
            // Draw a dashed grey line between the point and the receiver
            const connectionLine = L.polyline(
              [[first.lat, first.lng], [receiver.latitude, receiver.longitude]],
              {
                color: 'grey',
                weight: 2,
                opacity: 0.7,
                dashArray: '5, 7'
              }
            ).addTo(connectionLayerGroup);
          }
        }
      });
      
      startMarker.on('mouseout', () => {
        // Clear connection lines when mouse leaves the marker
        connectionLayerGroup.clearLayers();
      });
      
      const endMarker = L.marker([last.lat, last.lng], {
        icon: L.divIcon({
          className: 'end-marker',
          html: '🔴',
          iconSize: [20, 20],
          iconAnchor: [10, 10]
        })
      }).addTo(mapLayerGroup);
      endMarker.bindTooltip('End: ' + new Date(last.timestamp).toLocaleString(), tooltipOpts);
      
      // Add mouseover event to end marker to show connection to receiver
      endMarker.on('mouseover', () => {
        // Clear previous connection lines
        connectionLayerGroup.clearLayers();
        
        // Check if the record has a ReceiverID
        const receiverId = last.record.ReceiverID;
        if (receiverId && receiversData.length > 0) {
          // Find the receiver in receiversData
          const receiver = receiversData.find(r => r.id === receiverId);
          if (receiver && receiver.latitude && receiver.longitude) {
            // Calculate distance in kilometers
            const pointLatLng = L.latLng(last.lat, last.lng);
            const receiverLatLng = L.latLng(receiver.latitude, receiver.longitude);
            const distanceKm = (pointLatLng.distanceTo(receiverLatLng) / 1000).toFixed(2);
            
            // Update tooltip content
            const tooltipContent = `End: ${new Date(last.timestamp).toLocaleString()}<br/><strong>Receiver:</strong> ${receiver.name} / ${distanceKm} km`;
            endMarker.setTooltipContent(tooltipContent);
            
            // Draw a dashed grey line between the point and the receiver
            const connectionLine = L.polyline(
              [[last.lat, last.lng], [receiver.latitude, receiver.longitude]],
              {
                color: 'grey',
                weight: 2,
                opacity: 0.7,
                dashArray: '5, 7'
              }
            ).addTo(connectionLayerGroup);
          }
        }
      });
      
      endMarker.on('mouseout', () => {
        // Clear connection lines when mouse leaves the marker
        connectionLayerGroup.clearLayers();
      });
      
      // Add receiver markers for receivers that heard this vessel
      // Get the vessel data to find which receivers heard it
      fetch(`/state?UserID=${userID}`, { cache: 'no-store' })
        .then(response => response.json())
        .then(data => {
          if (data.ReceiverIDs && Array.isArray(data.ReceiverIDs) && data.ReceiverIDs.length > 0) {
            // Filter receivers to only those that heard this vessel
            const relevantReceivers = receiversData.filter(receiver =>
              data.ReceiverIDs.includes(receiver.id)
            );
            
            // Add a marker for each receiver
            relevantReceivers.forEach(receiver => {
              if (receiver.latitude && receiver.longitude) {
                // Create a red circle marker for the receiver
                const receiverMarker = L.circleMarker([receiver.latitude, receiver.longitude], {
                  radius: 6,
                  color: 'red',
                  fillColor: '#f03',
                  fillOpacity: 0.8,
                  weight: 2
                }).addTo(mapLayerGroup);
                
                // Add a permanent tooltip with the receiver name
                receiverMarker.bindTooltip(receiver.name, {
                  permanent: true,
                  direction: 'top',
                  offset: [0, -10],
                  className: 'receiver-tooltip'
                }).openTooltip();
              }
            });
          }
        })
        .catch(err => {
          console.error('Error fetching vessel data for receiver markers:', err);
        });
      
      // Fit map to vessel track data only (not including receivers)
      const latlngs = pts.map(p => [p.lat, p.lng]);
      map.fitBounds(L.latLngBounds(latlngs).pad(0.2));
    }
    
    // Check for time filter parameters in URL and restore if present
    function checkForTimeFilterInUrl(historyData) {
      const urlParams = new URLSearchParams(window.location.search);
      const filterStart = urlParams.get('filterStart');
      const filterEnd = urlParams.get('filterEnd');
      
      if (filterStart && filterEnd) {
        try {
          const startTime = new Date(filterStart);
          const endTime = new Date(filterEnd);
          
          // Validate dates
          if (!isNaN(startTime.getTime()) && !isNaN(endTime.getTime())) {
            // Set the time filter
            timeFilter = {
              active: true,
              startTime: startTime,
              endTime: endTime
            };
            
            // Add a small delay to ensure the histogram is fully rendered
            setTimeout(() => {
              // Get the actual data time range from the histogram
              const container = document.getElementById('message-histogram');
              const histogramStartTime = container.dataset.startTime ? new Date(container.dataset.startTime) : new Date(historyData[0].Timestamp);
              const histogramEndTime = container.dataset.endTime ? new Date(container.dataset.endTime) : new Date(historyData[historyData.length - 1].Timestamp);
              
              // Create the selection window
              createSelectionWindow(container, histogramStartTime, histogramEndTime);
              
              // Apply the filter to the map
              applyTimeFilter(historyData);
            }, 100);
          }
        } catch (e) {
          console.error('Error restoring time filter from URL:', e);
        }
      }
    }
    
    // Replay functionality
    let replayInProgress = false;
    let replayAnimationId = null;
    let replayTooltip = null;
    let replayPolyline = null;
    let tooltipVisible = true; // Track tooltip visibility
    
    // Function to toggle tooltip visibility
    function toggleTooltipVisibility() {
      if (replayTooltip) {
        if (tooltipVisible) {
          // Hide tooltip
          replayTooltip.getElement().style.display = 'none';
          tooltipVisible = false;
        } else {
          // Show tooltip
          replayTooltip.getElement().style.display = '';
          tooltipVisible = true;
        }
      }
    }
    
    // Initialize replay button
    document.addEventListener('DOMContentLoaded', () => {
      const replayButton = document.getElementById('replay-button');
      if (replayButton) {
        replayButton.addEventListener('click', startReplay);
      }
    });
    
    function startReplay() {
      // If replay is in progress, stop it instead
      if (replayInProgress) {
        stopReplay();
        return;
      }
      
      // Get current points from the map
      const historyData = window.currentHistoryData;
      if (!historyData || !historyData.length) {
        console.log('No data to replay');
        alert('No data available to replay');
        return;
      }
      
      // Prepare points with valid coordinates
      const pts = historyData
        .filter(r => {
          const flat = flatten(r.Packet);
          return flat && flat.Latitude != null && flat.Longitude != null &&
                 !isNaN(flat.Latitude) && !isNaN(flat.Longitude);
        })
        .map(r => {
          const flat = flatten(r.Packet);
          return {
            lat: flat.Latitude,
            lng: flat.Longitude,
            timestamp: r.Timestamp,
            record: r,
            data: flat
          };
        });
      
      if (!pts.length) {
        console.log('No valid position data found for replay');
        alert('No valid position data found for replay');
        return;
      }
      
      // Sort points by timestamp (oldest first)
      pts.sort((a, b) => new Date(a.timestamp) - new Date(b.timestamp));
      
      // Get selected duration
      const durationSelect = document.getElementById('replay-duration');
      const durationSeconds = parseInt(durationSelect.value, 10);
      
      // Update UI
      const replayButton = document.getElementById('replay-button');
      replayButton.innerHTML = `
        <svg xmlns="http://www.w3.org/2000/svg" width="12" height="12" fill="currentColor" viewBox="0 0 16 16">
          <path d="M5.5 3.5A1.5 1.5 0 0 1 7 5v6a1.5 1.5 0 0 1-3 0V5a1.5 1.5 0 0 1 1.5-1.5zm5 0A1.5 1.5 0 0 1 12 5v6a1.5 1.5 0 0 1-3 0V5a1.5 1.5 0 0 1 1.5-1.5z"/>
        </svg>
        Stop
      `;
      
      // Clear existing layers but keep the base map
      mapLayerGroup.clearLayers();
      
      // Add a class to the map container to indicate replay is active
      document.getElementById('map-container').classList.add('replay-active');
      
      // Create a layer group for the replay animation segments
      replayPolyline = L.layerGroup().addTo(mapLayerGroup);
      
      // Create a layer group for receiver connection lines
      const connectionLayerGroup = L.layerGroup().addTo(mapLayerGroup);
      
      // Add receiver markers for receivers that heard this vessel
      addReceiverMarkers();
      
      // Ensure we have at least one valid point
      if (!pts[0] || pts[0].lat === undefined || pts[0].lng === undefined) {
        console.error('First point is invalid:', pts[0]);
        finishReplay([]);
        return;
      }
      
      // Create a marker for the current position
      const currentMarker = L.marker([pts[0].lat, pts[0].lng], {
        icon: L.divIcon({
          className: 'current-marker',
          html: '🔷',
          iconSize: [20, 20],
          iconAnchor: [10, 10]
        })
      }).addTo(mapLayerGroup);
      
      // Create tooltip for the current position
      try {
        let tooltipContent = '';
        try {
          tooltipContent = makeTooltipHTML(pts[0]);
          
          // Add receiver information to tooltip if available
          const receiverId = pts[0].record.ReceiverID;
          if (receiverId && receiversData.length > 0) {
            // Find the receiver in receiversData
            const receiver = receiversData.find(r => r.id === receiverId);
            if (receiver && receiver.latitude && receiver.longitude) {
              // Calculate distance in kilometers
              const pointLatLng = L.latLng(pts[0].lat, pts[0].lng);
              const receiverLatLng = L.latLng(receiver.latitude, receiver.longitude);
              const distanceKm = (pointLatLng.distanceTo(receiverLatLng) / 1000).toFixed(2);
              
              // Add receiver info to tooltip with proper formatting
              tooltipContent += `<br/><strong>Receiver:</strong> ${receiver.name} (${distanceKm} km)`;
            }
          }
        } catch (e) {
          console.error('Error creating tooltip content:', e);
          // Create a simple fallback tooltip content
          tooltipContent = `<strong>${new Date(pts[0].timestamp).toLocaleString()}</strong><br/>` +
                          `<strong>Latitude:</strong> ${pts[0].lat.toFixed(6)}<br/>` +
                          `<strong>Longitude:</strong> ${pts[0].lng.toFixed(6)}`;
        }
        
        replayTooltip = L.tooltip({
          permanent: true,
          direction: 'top',
          offset: [0, -10],
          className: 'replay-tooltip'
        })
        .setLatLng([pts[0].lat, pts[0].lng])
        .setContent(tooltipContent)
        .addTo(map);
        
        // Add click handler to map to toggle tooltip visibility
        map.on('click', toggleTooltipVisibility);
      } catch (e) {
        console.error('Error creating tooltip:', e);
        // Continue without tooltip if there's an error
        replayTooltip = null;
      }
      
      // Set up the animation
      replayInProgress = true;
      const startTime = performance.now();
      const totalDuration = durationSeconds * 1000; // convert to milliseconds
      const progressBar = document.getElementById('replay-progress');
      
      // Animation function
      function animate(currentTime) {
        // Safety check - if replay was cancelled
        if (!replayInProgress) {
          return;
        }
        
        const elapsedTime = currentTime - startTime;
        const progress = Math.min(elapsedTime / totalDuration, 1);
        
        // Update progress bar
        if (progressBar) {
          progressBar.style.width = `${progress * 100}%`;
        }
        
        if (progress < 1 && pts.length > 0) {
          try {
            // Calculate the current point index based on progress
            // Ensure it's never negative and always within bounds
            const rawIndex = Math.floor(progress * pts.length);
            const pointIndex = Math.max(0, Math.min(rawIndex, pts.length - 1));
            
            // Log if we calculated an invalid index (for debugging)
            if (rawIndex < 0 || rawIndex >= pts.length) {
              console.log('Adjusted invalid point index:', rawIndex, 'to', pointIndex, 'pts length:', pts.length);
            }
            
            // Get current point and verify it's valid
            const currentPoint = pts[pointIndex];
            if (!currentPoint || currentPoint.lat === undefined || currentPoint.lng === undefined) {
              console.error('Invalid point at index:', pointIndex, currentPoint);
              finishReplay(pts);
              return;
            }
            
            // Clear existing polylines
            if (replayPolyline) {
              replayPolyline.clearLayers();
            }
            
            // Create colored segments up to the current point
            for (let i = 0; i < pointIndex; i++) {
              const pt1 = pts[i];
              const pt2 = pts[i + 1];
              
              if (pt1 && pt2 && pt1.lat !== undefined && pt1.lng !== undefined &&
                  pt2.lat !== undefined && pt2.lng !== undefined) {
                // Use the speed of the first point for the color
                const speed = pt1.data.Sog != null ? pt1.data.Sog : 0;
                const color = getColorForSpeed(speed);
                
                // Create a polyline segment with this color
                const segment = L.polyline([[pt1.lat, pt1.lng], [pt2.lat, pt2.lng]], {
                  color: color,
                  weight: 3,
                  opacity: 0.8
                }).addTo(replayPolyline);
              }
            }
            
            // Update marker position
            if (currentMarker) {
              currentMarker.setLatLng([currentPoint.lat, currentPoint.lng]);
            }
            
            // Update tooltip position and content (but keep visibility state)
            if (replayTooltip) {
              replayTooltip.setLatLng([currentPoint.lat, currentPoint.lng]);
              try {
                let tooltipContent = makeTooltipHTML(currentPoint);
                
                // Add receiver information to tooltip if available
                const receiverId = currentPoint.record.ReceiverID;
                if (receiverId && receiversData.length > 0) {
                  // Find the receiver in receiversData
                  const receiver = receiversData.find(r => r.id === receiverId);
                  if (receiver && receiver.latitude && receiver.longitude) {
                    // Calculate distance in kilometers
                    const pointLatLng = L.latLng(currentPoint.lat, currentPoint.lng);
                    const receiverLatLng = L.latLng(receiver.latitude, receiver.longitude);
                    const distanceKm = (pointLatLng.distanceTo(receiverLatLng) / 1000).toFixed(2);
                    
                    // Add receiver info to tooltip with proper formatting
                    tooltipContent += `<br/><strong>Receiver:</strong> ${receiver.name} (${distanceKm} km)`;
                  }
                }
                
                replayTooltip.setContent(tooltipContent);
                
                // Maintain visibility state
                if (!tooltipVisible && replayTooltip.getElement()) {
                  replayTooltip.getElement().style.display = 'none';
                }
              } catch (e) {
                console.error('Error updating tooltip content:', e);
                // Use a simple fallback tooltip content
                const fallbackContent = `<strong>${new Date(currentPoint.timestamp).toLocaleString()}</strong><br/>` +
                                      `<strong>Latitude:</strong> ${currentPoint.lat.toFixed(6)}<br/>` +
                                      `<strong>Longitude:</strong> ${currentPoint.lng.toFixed(6)}`;
                replayTooltip.setContent(fallbackContent);
              }
            }
            
            // Show connection to receiver if available
            connectionLayerGroup.clearLayers();
            const receiverId = currentPoint.record.ReceiverID;
            if (receiverId && receiversData.length > 0) {
              // Find the receiver in receiversData
              const receiver = receiversData.find(r => r.id === receiverId);
              if (receiver && receiver.latitude && receiver.longitude) {
                // Draw a dashed grey line between the point and the receiver
                const connectionLine = L.polyline(
                  [[currentPoint.lat, currentPoint.lng], [receiver.latitude, receiver.longitude]],
                  {
                    color: 'grey',
                    weight: 2,
                    opacity: 0.7,
                    dashArray: '5, 7'
                  }
                ).addTo(connectionLayerGroup);
                
                // Find and highlight the active receiver tooltip
                document.querySelectorAll('.leaflet-tooltip').forEach(tooltip => {
                  // Remove active class from all tooltips
                  tooltip.classList.remove('receiver-tooltip-active');
                  
                  // Add active class to the matching receiver tooltip
                  if (tooltip.textContent === receiver.name) {
                    tooltip.classList.add('receiver-tooltip-active');
                  }
                });
              }
            }
            
            // Continue animation
            replayAnimationId = requestAnimationFrame(animate);
          } catch (error) {
            console.error('Error during replay animation:', error);
            finishReplay(pts);
          }
        } else {
          // Animation complete
          finishReplay(pts);
        }
      }
      
      // Start the animation
      replayAnimationId = requestAnimationFrame(animate);
    }
    
    // Function to stop replay
    function stopReplay() {
      if (!replayInProgress) return;
      
      // Cancel animation
      if (replayAnimationId) {
        cancelAnimationFrame(replayAnimationId);
        replayAnimationId = null;
      }
      
      // Call finishReplay to clean up
      finishReplay(window.currentHistoryData || []);
    }
    
    function finishReplay(pts) {
      // Reset UI
      const replayButton = document.getElementById('replay-button');
      if (replayButton) {
        replayButton.innerHTML = `
          <svg xmlns="http://www.w3.org/2000/svg" width="12" height="12" fill="currentColor" viewBox="0 0 16 16">
            <path d="M11.596 8.697l-6.363 3.692c-.54.313-1.233-.066-1.233-.697V4.308c0-.63.692-1.01 1.233-.696l6.363 3.692a.802.802 0 0 1 0 1.393z"/>
          </svg>
          Replay
        `;
      }
      
      // Reset progress bar
      const progressBar = document.getElementById('replay-progress');
      if (progressBar) {
        progressBar.style.width = '0%';
      }
      
      // Clean up
      replayInProgress = false;
      
      // Remove the replay-active class from the map container
      document.getElementById('map-container').classList.remove('replay-active');
      if (replayAnimationId) {
        cancelAnimationFrame(replayAnimationId);
        replayAnimationId = null;
      }
      
      // Remove tooltip
      if (replayTooltip) {
        try {
          map.removeLayer(replayTooltip);
        } catch (e) {
          console.error('Error removing tooltip:', e);
        }
        replayTooltip = null;
        tooltipVisible = true; // Reset tooltip visibility state
        
        // Remove map click handler
        map.off('click', toggleTooltipVisibility);
      }
      
      // Redisplay the full track if we have data
      if (window.currentHistoryData && window.currentHistoryData.length > 0) {
        try {
          displayVesselTrack(window.currentHistoryData);
        } catch (e) {
          console.error('Error redisplaying track:', e);
        }
      }
    }
    
    // Function to add receiver markers to the map
    function addReceiverMarkers() {
      // Get the vessel data to find which receivers heard it
      fetch(`/state?UserID=${userID}`, { cache: 'no-store' })
        .then(response => response.json())
        .then(data => {
          if (data.ReceiverIDs && Array.isArray(data.ReceiverIDs) && data.ReceiverIDs.length > 0) {
            // Filter receivers to only those that heard this vessel
            const relevantReceivers = receiversData.filter(receiver =>
              data.ReceiverIDs.includes(receiver.id)
            );
            
            // Add a marker for each receiver
            relevantReceivers.forEach(receiver => {
              if (receiver.latitude && receiver.longitude) {
                // Create a red circle marker for the receiver
                const receiverMarker = L.circleMarker([receiver.latitude, receiver.longitude], {
                  radius: 6,
                  color: 'red',
                  fillColor: '#f03',
                  fillOpacity: 0.8,
                  weight: 2
                }).addTo(mapLayerGroup);
                
                // Add a permanent tooltip with the receiver name
                receiverMarker.bindTooltip(receiver.name, {
                  permanent: true,
                  direction: 'top',
                  offset: [0, -10],
                  className: 'receiver-tooltip'
                }).openTooltip();
              }
            });
          }
        })
        .catch(err => {
          console.error('Error fetching vessel data for receiver markers:', err);
        });
    }
  </script>
</body>
</html>