<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Vessel History</title>
  <!-- Include Bootstrap CSS -->
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/twitter-bootstrap/4.6.0/css/bootstrap.min.css">
  <!-- Include Leaflet CSS -->
  <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.3/dist/leaflet.css"
        integrity="sha256-kLaT2GOSpHechhsozzB+flnD+zUyjE2LlfWPgU04xyI=" crossorigin="" />
  <style>
    body {
      font-family: sans-serif;
      margin: 2rem;
    }
    .vessel-header {
      display: flex;
      align-items: flex-start;
      margin-bottom: 2rem;
    }
    .flag-container {
      margin-right: 2rem;
    }
    .flag-img {
      width: 80px;
      height: auto;
      border: 1px solid #ddd;
    }
    .vessel-info {
      flex-grow: 1;
      display: flex;
      flex-wrap: wrap;
      gap: 1rem;
    }
    .vessel-image {
      max-width: 300px;
      max-height: 200px;
      border: 1px solid #ddd;
      margin-left: 1rem;
    }
    .error {
      color: red;
      font-weight: bold;
    }
    .info-column {
      flex: 1;
      min-width: 300px;
    }
    table {
      border-collapse: collapse;
      width: 100%;
      margin-bottom: 1rem;
    }
    th, td {
      border: 1px solid #ddd;
      padding: 6px;
      text-align: left;
    }
    th {
      background-color: #f2f2f2;
    }
    .history-section {
      margin-top: 2rem;
    }
    .date-selector {
      display: flex;
      gap: 1rem;
      margin-bottom: 1rem;
      align-items: center;
    }
    .date-selector label {
      display: flex;
      flex-direction: column;
      margin-bottom: 0;
    }
    .date-selector button {
      margin-top: 1.5rem;
    }
    #receiver-select {
      min-width: 120px;
    }
    #message-histogram {
      height: 80px;
      width: 100%;
      margin-bottom: 1rem;
      border: 1px solid #ddd;
      position: relative;
      background-color: #f9f9f9;
    }
    #map-container {
      height: 400px;
      margin-bottom: 1rem;
      border: 1px solid #ddd;
      position: relative;
    }
    .changes-container {
      display: flex;
      flex-wrap: wrap;
      gap: 1rem;
      margin-top: 1rem;
    }
    .changes-table {
      flex: 1;
      min-width: 300px;
    }
    .changes-table h3 {
      font-size: 1.2rem;
      margin-bottom: 0.5rem;
    }
    .no-changes {
      font-style: italic;
      color: #666;
    }
    /* Speed legend styles */
    .speed-legend {
      position: absolute;
      top: 10px;
      right: 10px;
      background: rgba(255, 255, 255, 0.9);
      padding: 5px;
      border: 1px solid #ccc;
      border-radius: 3px;
      z-index: 1000;
      font-size: 12px;
      width: 120px;
    }
    .speed-scale-container {
      margin-bottom: 6px;
      padding: 0 5px;
      font-family: Arial, sans-serif;
      font-size: 12px;
      line-height: 1;
    }
    .speed-scale-bar {
      height: 6px;
      border-radius: 3px;
      background: linear-gradient(
        to right,
        hsl(120,100%,50%) 0%,    /* green */
        hsl(60, 100%,50%) 50%,   /* yellow */
        hsl(0,  100%,50%) 100%   /* red */
      );
      margin-bottom: 2px;
    }
    .speed-scale-labels {
      display: flex;
      justify-content: space-between;
    }
    #copy-link-btn {
      display: flex;
      align-items: center;
      gap: 5px;
      padding: 5px 10px;
      font-size: 0.9rem;
    }
    #copy-link-btn svg {
      margin-right: 3px;
    }
  </style>
</head>
<body>
  <div style="display: flex; justify-content: space-between; align-items: center;">
    <h1 id="main-title">Vessel History</h1>
    <button id="copy-link-btn" class="btn btn-sm btn-outline-secondary">
      <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" class="bi bi-link-45deg" viewBox="0 0 16 16">
        <path d="M4.715 6.542 3.343 7.914a3 3 0 1 0 4.243 4.243l1.828-1.829A3 3 0 0 0 8.586 5.5L8 6.086a1.002 1.002 0 0 0-.154.199 2 2 0 0 1 .861 3.337L6.88 11.45a2 2 0 1 1-2.83-2.83l.793-.792a4.018 4.018 0 0 1-.128-1.287z"/>
        <path d="M6.586 4.672A3 3 0 0 0 7.414 9.5l.775-.776a2 2 0 0 1-.896-3.346L9.12 3.55a2 2 0 1 1 2.83 2.83l-.793.792c.112.42.155.855.128 1.287l1.372-1.372a3 3 0 1 0-4.243-4.243L6.586 4.672z"/>
      </svg>
      Copy Link
    </button>
  </div>

  <div class="vessel-header">
    <div class="flag-container">
      <img id="flag-img" class="flag-img" src="" alt="Country Flag" style="display: none;">
    </div>
    <div class="vessel-info">
      <div class="info-column">
        <table id="vessel-table-left">
          <tbody>
            <!-- Left column data will be inserted here dynamically -->
          </tbody>
        </table>
      </div>
      <div class="info-column">
        <table id="vessel-table-right">
          <tbody>
            <!-- Right column data will be inserted here dynamically -->
          </tbody>
        </table>
      </div>
    </div>
    <div>
      <img id="vessel-img" class="vessel-image" src="" alt="Vessel Image" style="display: none;">
    </div>
  </div>

  <div class="history-section">
    <div class="date-selector">
      <label>From <input type="datetime-local" id="start"/></label>
      <label>To <input type="datetime-local" id="end"/></label>
      <label>Receiver
        <select id="receiver-select" class="form-control">
          <option value="">All</option>
          <!-- Receiver options will be populated dynamically -->
        </select>
      </label>
      <button id="apply-btn" class="btn btn-primary">Search</button>
      <button id="reset-btn" class="btn btn-secondary">Reset</button>
    </div>
    
    <div id="error" class="error"></div>
    
    <div id="message-histogram"></div>
    
    <div id="map-container">
      <div class="speed-legend">
        <div class="speed-scale-container">
          <div class="speed-scale-bar"></div>
          <div class="speed-scale-labels">
            <span>0 kn</span>
            <span>40 kn</span>
          </div>
        </div>
      </div>
    </div>
    
    <div class="changes-container">
      <div class="changes-table">
        <h3>Destination Changes</h3>
        <table id="destination-changes" class="table table-striped table-bordered">
          <thead>
            <tr>
              <th>Time</th>
              <th>From</th>
              <th>To</th>
              <th>ETA</th>
            </tr>
          </thead>
          <tbody>
            <!-- Destination changes will be inserted here -->
          </tbody>
        </table>
      </div>
      
      <div class="changes-table">
        <h3>Status Changes</h3>
        <table id="status-changes" class="table table-striped table-bordered">
          <thead>
            <tr>
              <th>Time</th>
              <th>From</th>
              <th>To</th>
            </tr>
          </thead>
          <tbody>
            <!-- Status changes will be inserted here -->
          </tbody>
        </table>
      </div>
    </div>
  </div>

  <!-- Include jQuery -->
  <script src="https://code.jquery.com/jquery-3.5.1.min.js"></script>
  <!-- Include Leaflet JS -->
  <script src="https://unpkg.com/leaflet@1.9.3/dist/leaflet.js"
          integrity="sha256-WBkoXOwTeyKclOHuWtc+i2uENFpDZ9YPdf5Hf+D7ewM=" crossorigin=""></script>
  <script>
    // Get UserID from URL query parameter
    function getQueryParam(name) {
      const urlParams = new URLSearchParams(window.location.search);
      return urlParams.get(name);
    }

    const userID = getQueryParam('UserID');
    let midsMapping = {};
    let shipTypeConfig = {};
    let navStatusMapping = {};
    let receiversData = []; // Store receivers data globally

    // Format time difference as a human-readable string
    function formatTimeDifference(timestamp) {
      const now = new Date();
      const date = new Date(timestamp);
      const diffMs = now - date;
      
      const seconds = Math.floor(diffMs / 1000);
      const minutes = Math.floor(seconds / 60);
      const hours = Math.floor(minutes / 60);
      const days = Math.floor(hours / 24);
      
      const remainingHours = hours % 24;
      const remainingMinutes = minutes % 60;
      const remainingSeconds = seconds % 60;
      
      let result = '';
      if (days > 0) result += `${days}d `;
      if (remainingHours > 0 || days > 0) result += `${remainingHours}h `;
      if (remainingMinutes > 0 || remainingHours > 0 || days > 0) result += `${remainingMinutes}m `;
      result += `${remainingSeconds}s ago`;
      
      return result;
    }

    // Load MIDs mapping, ship types, and nav status
    Promise.all([
      fetch('/mids.json').then(r => r.json()),
      fetch('/types.json').then(r => r.json()),
      fetch('/navstatus.json').then(r => r.json())
    ])
    .then(([midsData, typesData, navStatusData]) => {
      midsMapping = midsData;
      shipTypeConfig = typesData;
      navStatusMapping = navStatusData;
      loadVesselData();
    })
    .catch(err => {
      console.error('Error loading data:', err);
      document.getElementById('error').textContent = 'Failed to load reference data.';
      loadVesselData(); // Still try to load vessel data even if data loading fails
    });

    // Helper: given a numeric code and the types.json config, return the category name
    function lookupShipType(code) {
      if (!shipTypeConfig.valueLookup || !code) return code;
      
      const categoryId = shipTypeConfig.valueLookup[code];
      if (categoryId == null) return code;
      
      const category = shipTypeConfig.categories.find(cat => cat.id === categoryId);
      return category ? `${category.name} (ID: ${code})` : code;
    }

    // Helper: look up navigational status text
    function lookupNavStatus(code) {
      if (!navStatusMapping || code === undefined || code === null) return "Unknown";
      return navStatusMapping[code] || "Unknown";
    }

    function loadVesselData() {
      if (!userID) {
        document.getElementById('main-title').textContent = 'Error';
        document.getElementById('error').textContent = 'Missing UserID in URL.';
        return;
      }

      fetch(`/state?UserID=${userID}`, { cache: 'no-store' })
        .then(response => response.json())
        .then(data => {
          // Store AIS class globally for use in fetchVesselHistory
          vesselAisClass = data.AISClass || '';
          console.log('Vessel AIS Class:', vesselAisClass);
          
          // Update receiver dropdown if ReceiverIDs are available
          if (data.ReceiverIDs && Array.isArray(data.ReceiverIDs) && data.ReceiverIDs.length > 0) {
            console.log('Vessel heard by receivers:', data.ReceiverIDs);
            
            // Ensure receivers data is loaded
            if (receiversData.length === 0) {
              // If receivers data isn't loaded yet, fetch it now
              fetchReceiversData();
            } else {
              // Filter the receiver dropdown to only show receivers that heard this vessel
              const receiverSelect = document.getElementById('receiver-select');
              
              // Keep only the "All" option and receivers that heard this vessel
              while (receiverSelect.options.length > 1) {
                receiverSelect.remove(1);
              }
              
              // Add options for each receiver that heard this vessel
              receiversData.forEach(receiver => {
                if (data.ReceiverIDs.includes(receiver.id)) {
                  const option = document.createElement('option');
                  option.value = receiver.id;
                  option.textContent = receiver.name;
                  receiverSelect.appendChild(option);
                }
              });
            }
          }
          
          // Update page title with vessel name if available
          if (data.Name) {
            document.getElementById('main-title').textContent = `Vessel History: ${data.Name.trim()}`;
          } else {
            document.getElementById('main-title').textContent = `Vessel History: ${userID}`;
          }

          // Get country code from MID (first 3 digits of UserID)
          const mid = userID.toString().substring(0, 3);
          if (midsMapping[mid] && midsMapping[mid][0]) {
            const countryCode = midsMapping[mid][0].toLowerCase();
            const flagUrl = `/flags/${countryCode}.svg`;
            const flagImg = document.getElementById('flag-img');
            flagImg.src = flagUrl;
            flagImg.alt = `${midsMapping[mid][3]} Flag`;
            flagImg.style.display = 'block';
          }

          // Display vessel image if available
          if (data.ImageURL) {
            const vesselImg = document.getElementById('vessel-img');
            vesselImg.src = data.ImageURL;
            vesselImg.style.display = 'block';
          }

          // Create table rows for vessel information
          const leftTableBody = document.querySelector('#vessel-table-left tbody');
          const rightTableBody = document.querySelector('#vessel-table-right tbody');
          leftTableBody.innerHTML = ''; // Clear existing rows
          rightTableBody.innerHTML = ''; // Clear existing rows

          // Fields to display (if available)
          const fieldsToDisplay = [
            { key: 'UserID', label: 'MMSI' },
            { key: 'Name', label: 'Name' },
            { key: 'CallSign', label: 'Call Sign' },
            {
              key: 'ImoNumber',
              label: 'IMO Number',
              // Treat IMO Number = 0 as empty
              checkValue: (val) => val !== undefined && val !== null && val !== '' && val !== 0
            },
            { key: 'AISClass', label: 'AIS Class' },
            { key: 'Type', label: 'Type', format: (val) => lookupShipType(val) },
            {
              key: 'Flag',
              label: 'Flag',
              // Custom value that doesn't exist in the data object
              customValue: true,
              format: () => {
                // Get country name from MID (first 3 digits of UserID)
                const mid = userID.toString().substring(0, 3);
                if (midsMapping[mid] && midsMapping[mid][3]) {
                  return midsMapping[mid][3]; // 4th element is the full country name
                }
                return 'Unknown';
              }
            },
            { key: 'NavigationalStatus', label: 'Status', format: (val) => lookupNavStatus(val) },
            { key: 'Destination', label: 'Destination' },
            { key: 'MaximumStaticDraught', label: 'Max Draught', format: (val) => val ? `${val} m` : '' },
            {
              key: 'Dimension',
              label: 'Dimension',
              format: (val) => {
                if (!val || typeof val !== 'object') return '';
                const length = (val.A || 0) + (val.B || 0);
                const width = (val.C || 0) + (val.D || 0);
                return `${length}m × ${width}m`;
              }
            },
            {
              key: 'LastUpdated',
              label: 'Last Seen',
              format: (val) => {
                const localTime = new Date(val).toLocaleString();
                const timeDiff = formatTimeDifference(val);
                return `${localTime} (${timeDiff})`;
              }
            }
          ];

          // Add rows for each field if it exists and is not empty
          // Manually define which fields go in which table
          const leftTableFields = ['UserID', 'Name', 'CallSign', 'ImoNumber', 'AISClass', 'Type', 'Flag'];
          const rightTableFields = ['NavigationalStatus', 'Destination', 'MaximumStaticDraught', 'Dimension', 'LastUpdated'];
          
          // Process fields for left table
          fieldsToDisplay.filter(field => leftTableFields.includes(field.key)).forEach(field => {
            // Special cases for fields that should always be shown or have custom values
            const shouldDisplay = field.customValue ||
                                 field.key === 'NavigationalStatus' ||
                                 (field.checkValue ? field.checkValue(data[field.key]) :
                                  (data[field.key] !== undefined &&
                                   data[field.key] !== null &&
                                   data[field.key] !== ''));
            
            if (shouldDisplay) {
              const row = document.createElement('tr');
              
              const labelCell = document.createElement('td');
              labelCell.textContent = field.label;
              labelCell.style.fontWeight = 'bold';
              row.appendChild(labelCell);
              
              const valueCell = document.createElement('td');
              // For custom value fields, just call the format function directly
              if (field.customValue && field.format) {
                valueCell.textContent = field.format();
              } else {
                // Otherwise use formatter function if provided, or use raw value
                const value = data[field.key];
                valueCell.textContent = field.format ? field.format(value) : (value || '');
              }
              row.appendChild(valueCell);
              
              leftTableBody.appendChild(row);
            }
          });
          
          // Process fields for right table
          fieldsToDisplay.filter(field => rightTableFields.includes(field.key)).forEach(field => {
            // Special cases for fields that should always be shown or have custom values
            const shouldDisplay = field.customValue ||
                                 field.key === 'NavigationalStatus' ||
                                 (field.checkValue ? field.checkValue(data[field.key]) :
                                  (data[field.key] !== undefined &&
                                   data[field.key] !== null &&
                                   data[field.key] !== ''));
            
            if (shouldDisplay) {
              const row = document.createElement('tr');
              
              const labelCell = document.createElement('td');
              labelCell.textContent = field.label;
              labelCell.style.fontWeight = 'bold';
              row.appendChild(labelCell);
              
              const valueCell = document.createElement('td');
              // For custom value fields, just call the format function directly
              if (field.customValue && field.format) {
                valueCell.textContent = field.format();
              } else {
                // Otherwise use formatter function if provided, or use raw value
                const value = data[field.key];
                valueCell.textContent = field.format ? field.format(value) : (value || '');
              }
              row.appendChild(valueCell);
              
              rightTableBody.appendChild(row);
            }
          });

          // If no data was added to either table
          if (leftTableBody.children.length === 0 && rightTableBody.children.length === 0) {
            const row = document.createElement('tr');
            const cell = document.createElement('td');
            cell.colSpan = 2;
            cell.textContent = 'No vessel information available';
            row.appendChild(cell);
            leftTableBody.appendChild(row);
          }
        })
        .catch(err => {
          console.error('Error fetching vessel data:', err);
          document.getElementById('error').textContent = 'Failed to load vessel data.';
        });
    }

    // Fetch receivers data and populate the dropdown
    function fetchReceiversData() {
      fetch('/receivers', { cache: 'no-store' })
        .then(response => response.json())
        .then(data => {
          receiversData = data;
          const receiverSelect = document.getElementById('receiver-select');
          
          // Clear existing options except the "All" option
          while (receiverSelect.options.length > 1) {
            receiverSelect.remove(1);
          }
          
          // Add options for each receiver
          data.forEach(receiver => {
            const option = document.createElement('option');
            option.value = receiver.id;
            option.textContent = receiver.name;
            receiverSelect.appendChild(option);
          });
        })
        .catch(err => {
          console.error('Error fetching receivers data:', err);
        });
    }

    // Initialize date selectors with values from URL parameters or default to last 24 hours
    function initDateSelectors() {
      // Try to get start and end from URL parameters
      const startParam = getQueryParam('start');
      const endParam = getQueryParam('end');
      const receiverIdParam = getQueryParam('ReceiverID');
      
      let end, start;
      
      // If end parameter exists and is valid, use it; otherwise use current time
      if (endParam && !isNaN(new Date(endParam).getTime())) {
        end = new Date(endParam);
      } else {
        end = new Date();
      }
      
      // If start parameter exists and is valid, use it; otherwise use 24 hours before end
      if (startParam && !isNaN(new Date(startParam).getTime())) {
        start = new Date(startParam);
      } else {
        start = new Date(end);
        start.setDate(start.getDate() - 1); // 1 day ago
      }
      
      document.getElementById('end').value = end.toISOString().slice(0, 16);
      document.getElementById('start').value = start.toISOString().slice(0, 16);
      
      // Set receiver dropdown if ReceiverID parameter exists
      if (receiverIdParam) {
        // We'll set this once the receivers are loaded
        const checkReceiverInterval = setInterval(() => {
          const receiverSelect = document.getElementById('receiver-select');
          if (receiverSelect.options.length > 1) {
            // Find the option with the matching value
            for (let i = 0; i < receiverSelect.options.length; i++) {
              if (receiverSelect.options[i].value === receiverIdParam) {
                receiverSelect.selectedIndex = i;
                break;
              }
            }
            clearInterval(checkReceiverInterval);
          }
        }, 100);
      }
    }

    // Initialize map
    let map = null;
    let mapLayerGroup = null;

    function initMap() {
      if (!map) {
        map = L.map('map-container').setView([0, 0], 2);
        L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
          attribution: '&copy; OpenStreetMap contributors'
        }).addTo(map);
        mapLayerGroup = L.layerGroup().addTo(map);
      }
    }

    // Fetch vessel history data
    async function fetchVesselHistory() {
      const startInput = document.getElementById('start');
      const endInput = document.getElementById('end');
      const s = startInput.value, e = endInput.value;
      
      if (!s || !e) {
        alert('Please select From and To dates.');
        return null;
      }

      // Determine message types based on AIS Class
      let positionMessageTypes = [];
      let staticMessageTypes = [];
      
      if (vesselAisClass === 'A') {
        positionMessageTypes = ['1', '2', '3']; // Class A position messages
        staticMessageTypes = ['5'];             // Class A static messages
      } else if (vesselAisClass === 'B') {
        positionMessageTypes = ['18', '19'];    // Class B position messages
        staticMessageTypes = ['24'];            // Class B static messages
      } else {
        // Default to both types if AIS class is unknown
        positionMessageTypes = ['1', '2', '3', '18', '19']; // All position messages
        staticMessageTypes = ['5', '24'];                   // All static messages
      }

      const startTime = new Date(s).toISOString();
      const endTime = new Date(e).toISOString();
      const limit = 2000;

      try {
        // Get selected receiver ID
        const receiverSelect = document.getElementById('receiver-select');
        const selectedReceiverId = receiverSelect.value;
        
        // Create base parameters for both calls
        const positionParams = {
          UserID: userID,
          MessageID: positionMessageTypes.join(','),
          start: startTime,
          end: endTime,
          limit: limit
        };
        
        const staticParams = {
          UserID: userID,
          MessageID: staticMessageTypes.join(','),
          start: startTime,
          end: endTime,
          limit: limit
        };
        
        // Add ReceiverID parameter if a specific receiver is selected
        if (selectedReceiverId) {
          positionParams.ReceiverID = selectedReceiverId;
          staticParams.ReceiverID = selectedReceiverId;
        }
        
        // Make two separate calls for position and static messages
        const [positionResponse, staticResponse] = await Promise.all([
          // Position messages call
          fetch(`/latestmessages?${new URLSearchParams(positionParams)}`, {cache: 'no-store'}),
          
          // Static messages call
          fetch(`/latestmessages?${new URLSearchParams(staticParams)}`, {cache: 'no-store'})
        ]);

        // Parse both responses
        const positionData = await positionResponse.json();
        const staticData = await staticResponse.json();
        
        // Check if either response has the same number of results as the limit
        const positionCount = positionData.length;
        const staticCount = staticData.length;
        const combinedResults = [...positionData, ...staticData];
        
        // If either count matches the limit, show a warning
        if (positionCount === limit || staticCount === limit) {
          const warningDiv = document.getElementById('error');
          warningDiv.textContent = `Warning: Some data may be missing. ${positionCount === limit ? 'Position' : ''} ${positionCount === limit && staticCount === limit ? 'and' : ''} ${staticCount === limit ? 'Static' : ''} data reached the limit of ${limit} records. Try reducing the time range.`;
          warningDiv.style.display = 'block';
        } else {
          // Clear any previous warnings
          document.getElementById('error').textContent = '';
        }
        
        return combinedResults;
      } catch (err) {
        console.error('Error fetching vessel history:', err);
        alert('Failed to fetch vessel history data.');
        return null;
      }
    }

    // Function to get color based on speed
    function getColorForSpeed(speed) {
      const maxSpeed = 40;  // maximum expected speed in knots
      // Clamp the speed value between 0 and maxSpeed
      const clampedSpeed = Math.max(0, Math.min(maxSpeed, speed));
      // Compute a ratio (0 = 0 knots, 1 = maxSpeed)
      const ratio = clampedSpeed / maxSpeed;
      // Calculate hue: 120 (green) at 0 knots to 0 (red) at maxSpeed knots.
      const hue = (1 - ratio) * 120;
      // Return a string with full saturation and 50% lightness.
      return `hsl(${hue}, 100%, 50%)`;
    }

    // Create a colored track with segments colored by speed
    function createColoredTrack(points) {
      const segments = [];
      // Loop through the points to create segments
      for (let i = 0; i < points.length - 1; i++) {
        const pt1 = points[i];
        const pt2 = points[i + 1];
        // Use the speed of the first point for the color
        const speed = pt1.data.Sog != null ? pt1.data.Sog : 0;
        const color = getColorForSpeed(speed);
        // Create a polyline segment with this color
        const segment = L.polyline([[pt1.lat, pt1.lng], [pt2.lat, pt2.lng]], {
          color: color,
          weight: 3,
          opacity: 0.8
        });
        segments.push(segment);
      }
      // Group the segments so they can be treated as one layer
      return L.layerGroup(segments);
    }

    // Display vessel track on map
    function displayVesselTrack(historyData) {
      if (!historyData || !historyData.length) {
        return;
      }

      // Clear existing layers
      mapLayerGroup.clearLayers();
      
      // Prepare points with valid coordinates
      const pts = historyData
        .filter(r => {
          const flat = flatten(r.Packet);
          return flat.Latitude != null && flat.Longitude != null &&
                 !isNaN(flat.Latitude) && !isNaN(flat.Longitude);
        })
        .map(r => {
          const flat = flatten(r.Packet);
          return {
            lat: flat.Latitude,
            lng: flat.Longitude,
            timestamp: r.Timestamp,
            record: r,
            data: flat
          };
        });

      if (!pts.length) {
        console.log('No valid position data found');
        return;
      }
      
      // Sort points by timestamp (newest first)
      pts.sort((a, b) => new Date(b.timestamp) - new Date(a.timestamp));
      
      // Create colored track based on speed
      const coloredTrack = createColoredTrack(pts);
      coloredTrack.addTo(mapLayerGroup);
      
      // Tooltip options
      const tooltipOpts = {
        direction: 'top',
        offset: [0, -6],
        permanent: false,
        sticky: true
      };
      
      // Helper to format one point's tooltip HTML
      function makeTooltipHTML(pt) {
        const timestamp = new Date(pt.timestamp).toLocaleString();
        let html = `<strong>${timestamp}</strong><br/>`;
        html += `<strong>Latitude:</strong> ${pt.lat.toFixed(6)}<br/>`;
        html += `<strong>Longitude:</strong> ${pt.lng.toFixed(6)}<br/>`;
        
        // Add other interesting fields if available
        const fields = ['Sog', 'Cog', 'TrueHeading', 'NavigationalStatus', 'Destination'];
        fields.forEach(field => {
          if (pt.data[field] != null) {
            let value = pt.data[field];
            let displayField = field;
            
            // Rename fields for display
            if (field === 'TrueHeading') {
              displayField = 'Heading';
            } else if (field === 'NavigationalStatus') {
              displayField = 'Status';
              if (navStatusMapping[value]) {
                value = navStatusMapping[value];
              }
            }
            
            html += `<strong>${displayField}:</strong> ${value}<br/>`;
          }
        });
        
        return html;
      }
      
      // Add tooltips to each segment in the colored track
      coloredTrack.eachLayer(segment => {
        segment.bindTooltip('', tooltipOpts);
        
        segment.on('mousemove', e => {
          // Find the nearest point to where the mouse is
          let minDist = Infinity, nearestPoint = null;
          pts.forEach(pt => {
            const ptLatLng = L.latLng(pt.lat, pt.lng);
            const d = e.latlng.distanceTo(ptLatLng);
            if (d < minDist) {
              minDist = d;
              nearestPoint = pt;
            }
          });
          
          if (nearestPoint) {
            const html = makeTooltipHTML(nearestPoint);
            segment.setTooltipContent(html);
            segment.openTooltip(e.latlng);
          }
        });
        
        segment.on('mouseout', () => segment.closeTooltip());
      });
      
      // Add markers at the first and last points with tooltips
      const first = pts[pts.length - 1]; // Oldest point
      const last = pts[0]; // Newest point
      
      const startMarker = L.marker([first.lat, first.lng], {
        icon: L.divIcon({
          className: 'start-marker',
          html: '🔵',
          iconSize: [20, 20],
          iconAnchor: [10, 10]
        })
      }).addTo(mapLayerGroup);
      startMarker.bindTooltip('Start: ' + new Date(first.timestamp).toLocaleString(), tooltipOpts);
      
      const endMarker = L.marker([last.lat, last.lng], {
        icon: L.divIcon({
          className: 'end-marker',
          html: '🔴',
          iconSize: [20, 20],
          iconAnchor: [10, 10]
        })
      }).addTo(mapLayerGroup);
      endMarker.bindTooltip('End: ' + new Date(last.timestamp).toLocaleString(), tooltipOpts);
      
      // Fit map to data
      const latlngs = pts.map(p => [p.lat, p.lng]);
      map.fitBounds(L.latLngBounds(latlngs).pad(0.2));
    }

    // Track changes in destination and navigational status
    function trackChanges(historyData) {
      if (!historyData || !historyData.length) {
        return;
      }
      
      // Sort by timestamp (oldest first)
      const sortedData = [...historyData].sort((a, b) =>
        new Date(a.Timestamp) - new Date(b.Timestamp)
      );
      
      const destinationChanges = [];
      const statusChanges = [];
      
      let lastDestination = null;
      let lastStatus = null;
      let firstRecord = null;
      let firstStaticRecord = null;
      let firstPositionRecord = null;
      
      // Find the first record with static data (containing Destination field)
      // and the first record with position data (containing NavigationalStatus field)
      for (const record of sortedData) {
        const flat = flatten(record.Packet);
        
        // Store the first record for general use
        if (!firstRecord) {
          firstRecord = record;
        }
        
        // Find the first record with Destination field (static message)
        if (!firstStaticRecord && flat.Destination !== undefined) {
          firstStaticRecord = record;
        }
        
        // Find the first record with NavigationalStatus field (position message)
        if (!firstPositionRecord &&
            (record.MessageID === 1 || record.MessageID === 2 || record.MessageID === 3 ||
             record.MessageID === 18 || record.MessageID === 19) &&
            record.Packet && record.Packet.NavigationalStatus !== undefined) {
          firstPositionRecord = record;
          console.log('Found position record with NavigationalStatus:', record);
        }
        
        // If we found both types of records, we can break early
        if (firstStaticRecord && firstPositionRecord) {
          break;
        }
      }
      
      // If we didn't find a record with Destination, use the first record
      if (!firstStaticRecord && sortedData.length > 0) {
        firstStaticRecord = firstRecord;
      }
      
      // If we didn't find a position record, use the first record
      if (!firstPositionRecord && sortedData.length > 0) {
        firstPositionRecord = firstRecord;
      }
      
      sortedData.forEach(record => {
        const flat = flatten(record.Packet);
        const timestamp = record.Timestamp;
        
        // Track destination changes
        if (flat.Destination !== undefined) {
          const currentDestination = flat.Destination || '';
          if (lastDestination !== null && currentDestination !== lastDestination) {
            // Include ETA if available
            let etaStr = '';
            // Access ETA directly from the original packet, not the flattened structure
            if (record.Packet && record.Packet.Eta) {
              etaStr = formatEta(record.Packet.Eta);
            }
            
            destinationChanges.push({
              timestamp,
              from: lastDestination,
              to: currentDestination,
              eta: etaStr
            });
          }
          lastDestination = currentDestination;
        }
        
        // Track navigational status changes
        if (flat.NavigationalStatus !== undefined) {
          const currentStatus = flat.NavigationalStatus;
          if (lastStatus !== null && currentStatus !== lastStatus) {
            statusChanges.push({
              timestamp,
              from: lastStatus,
              to: currentStatus
            });
          }
          lastStatus = currentStatus;
        }
      });
      
      // Display destination changes
      const destTable = document.querySelector('#destination-changes tbody');
      destTable.innerHTML = '';
      
      if (destinationChanges.length > 0) {
        destinationChanges.forEach(change => {
          const row = document.createElement('tr');
          
          const timeCell = document.createElement('td');
          timeCell.textContent = new Date(change.timestamp).toLocaleString();
          row.appendChild(timeCell);
          
          const fromCell = document.createElement('td');
          fromCell.textContent = change.from || '(empty)';
          row.appendChild(fromCell);
          
          const toCell = document.createElement('td');
          toCell.textContent = change.to || '(empty)';
          row.appendChild(toCell);
          
          // Add ETA cell
          const etaCell = document.createElement('td');
          etaCell.textContent = change.eta || '';
          row.appendChild(etaCell);
          
          destTable.appendChild(row);
        });
      } else if (firstStaticRecord) {
        // If no changes but we have static data, show the current value
        const flat = flatten(firstStaticRecord.Packet);
        if (flat.Destination !== undefined) {
          const row = document.createElement('tr');
          
          const timeCell = document.createElement('td');
          timeCell.textContent = new Date(firstStaticRecord.Timestamp).toLocaleString();
          row.appendChild(timeCell);
          
          const fromCell = document.createElement('td');
          fromCell.textContent = '(initial value)';
          row.appendChild(fromCell);
          
          const toCell = document.createElement('td');
          toCell.textContent = flat.Destination || '(empty)';
          row.appendChild(toCell);
          
          // Add ETA cell
          const etaCell = document.createElement('td');
          // Access ETA directly from the original packet, not the flattened structure
          if (firstStaticRecord.Packet && firstStaticRecord.Packet.Eta) {
            etaCell.textContent = formatEta(firstStaticRecord.Packet.Eta);
          }
          row.appendChild(etaCell);
          
          destTable.appendChild(row);
        } else {
          const row = document.createElement('tr');
          const cell = document.createElement('td');
          cell.colSpan = 4;
          cell.className = 'no-changes';
          cell.textContent = 'No destination information available';
          row.appendChild(cell);
          destTable.appendChild(row);
        }
      } else {
        const row = document.createElement('tr');
        const cell = document.createElement('td');
        cell.colSpan = 4;
        cell.className = 'no-changes';
        cell.textContent = 'No destination changes detected';
        row.appendChild(cell);
        destTable.appendChild(row);
      }
      
      // Display navigational status changes
      const statusTable = document.querySelector('#status-changes tbody');
      statusTable.innerHTML = '';
      
      if (statusChanges.length > 0) {
        statusChanges.forEach(change => {
          const row = document.createElement('tr');
          
          const timeCell = document.createElement('td');
          timeCell.textContent = new Date(change.timestamp).toLocaleString();
          row.appendChild(timeCell);
          
          const fromCell = document.createElement('td');
          fromCell.textContent = navStatusMapping[change.from] || change.from || '(unknown)';
          row.appendChild(fromCell);
          
          const toCell = document.createElement('td');
          toCell.textContent = navStatusMapping[change.to] || change.to || '(unknown)';
          row.appendChild(toCell);
          
          statusTable.appendChild(row);
        });
      } else if (firstPositionRecord) {
        // If no changes but we have position data, show the current value
        const row = document.createElement('tr');
        
        const timeCell = document.createElement('td');
        timeCell.textContent = new Date(firstPositionRecord.Timestamp).toLocaleString();
        row.appendChild(timeCell);
        
        const fromCell = document.createElement('td');
        fromCell.textContent = '(initial value)';
        row.appendChild(fromCell);
        
        const toCell = document.createElement('td');
        
        // Get NavigationalStatus directly from the position record
        const navStatus = firstPositionRecord.Packet.NavigationalStatus;
        console.log('Position record:', firstPositionRecord);
        console.log('NavigationalStatus:', navStatus);
        console.log('Mapped value:', navStatusMapping[navStatus]);
        
        // Convert the status code to a readable string
        if (navStatus === 0) {
          // Special case for 0, which is "Using Engine"
          toCell.textContent = navStatusMapping[0] || "Using Engine";
        } else if (navStatus !== undefined) {
          toCell.textContent = navStatusMapping[navStatus] || `${navStatus}`;
        } else {
          toCell.textContent = '(unknown)';
        }
        row.appendChild(toCell);
        
        statusTable.appendChild(row);
      } else {
        const row = document.createElement('tr');
        const cell = document.createElement('td');
        cell.colSpan = 3;
        cell.className = 'no-changes';
        cell.textContent = 'No navigational status changes detected';
        row.appendChild(cell);
        statusTable.appendChild(row);
      }
    }

    // Format ETA from object to readable string
    function formatEta(eta) {
      if (!eta || typeof eta !== 'object') return '';
      
      const { Day, Month, Hour, Minute } = eta;
      if (Day === undefined || Month === undefined) return '';
      
      // Month is 1-based in the data
      const monthNames = [
        'January', 'February', 'March', 'April', 'May', 'June',
        'July', 'August', 'September', 'October', 'November', 'December'
      ];
      
      const monthName = monthNames[Month - 1] || '';
      let timeStr = '';
      
      if (Hour !== undefined && Minute !== undefined) {
        // Pad with leading zeros if needed
        const hourStr = Hour.toString().padStart(2, '0');
        const minStr = Minute.toString().padStart(2, '0');
        timeStr = ` ${hourStr}:${minStr}`;
      }
      
      return `${Day} ${monthName}${timeStr}`;
    }

    // Helper function to flatten nested objects
    function flatten(obj, prefix = '', res = {}) {
      for (const [k, v] of Object.entries(obj || {})) {
        const key = prefix ? `${prefix}.${k}` : k;
        if (v != null && typeof v === 'object' && !Array.isArray(v)) {
          flatten(v, key, res);
        } else {
          res[key] = v;
        }
      }
      return res;
    }

    // Store vessel AIS class globally
    let vesselAisClass = '';

    // Initialize the page
    document.addEventListener('DOMContentLoaded', () => {
      initDateSelectors();
      initMap();
      
      // Fetch receivers data
      fetchReceiversData();
      
      // Automatically load history data with default 1-day range
      setTimeout(async () => {
        const historyData = await fetchVesselHistory();
        if (historyData) {
          displayVesselTrack(historyData);
          displayMessageHistogram(historyData);
          trackChanges(historyData);
        }
      }, 1000); // Small delay to ensure vessel data is loaded first
      
      // Set up event listeners
      document.getElementById('copy-link-btn').addEventListener('click', async () => {
        const currentUrl = window.location.href;
        
        try {
          // Try to use the modern Clipboard API first
          if (navigator.clipboard && navigator.clipboard.writeText) {
            await navigator.clipboard.writeText(currentUrl);
          } else {
            // Fall back to the older method for browsers that don't support Clipboard API
            const tempInput = document.createElement('input');
            tempInput.value = currentUrl;
            document.body.appendChild(tempInput);
            tempInput.select();
            tempInput.setSelectionRange(0, 99999); // For mobile devices
            document.execCommand('copy');
            document.body.removeChild(tempInput);
          }
          
          // Visual feedback
          const btn = document.getElementById('copy-link-btn');
          const originalText = btn.innerHTML;
          btn.innerHTML = `
            <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" class="bi bi-check-lg" viewBox="0 0 16 16">
              <path d="M12.736 3.97a.733.733 0 0 1 1.047 0c.286.289.29.756.01 1.05L7.88 12.01a.733.733 0 0 1-1.065.02L3.217 8.384a.757.757 0 0 1 0-1.06.733.733 0 0 1 1.047 0l3.052 3.093 5.4-6.425a.247.247 0 0 1 .02-.022Z"/>
            </svg>
            Copied!
          `;
          
          // Reset button text after 2 seconds
          setTimeout(() => {
            btn.innerHTML = originalText;
          }, 2000);
        } catch (err) {
          console.error('Failed to copy URL to clipboard:', err);
        }
      });
      
      document.getElementById('receiver-select').addEventListener('change', async () => {
        const historyData = await fetchVesselHistory();
        if (historyData) {
          displayVesselTrack(historyData);
          displayMessageHistogram(historyData);
          trackChanges(historyData);
        }
      });
      
      document.getElementById('apply-btn').addEventListener('click', async () => {
        // Update URL with current date range
        const startInput = document.getElementById('start');
        const endInput = document.getElementById('end');
        
        if (startInput.value && endInput.value) {
          // Create a new URL object based on the current URL
          const url = new URL(window.location.href);
          
          // Update or add the start and end parameters
          url.searchParams.set('start', new Date(startInput.value).toISOString());
          url.searchParams.set('end', new Date(endInput.value).toISOString());
          
          // Add receiver ID to URL if selected
          const receiverSelect = document.getElementById('receiver-select');
          if (receiverSelect.value) {
            url.searchParams.set('ReceiverID', receiverSelect.value);
          } else {
            url.searchParams.delete('ReceiverID');
          }
          
          // Update the browser history without reloading the page
          window.history.replaceState({}, '', url);
        }
        
        const historyData = await fetchVesselHistory();
        if (historyData) {
          displayVesselTrack(historyData);
          displayMessageHistogram(historyData);
          trackChanges(historyData);
        }
      });
      
      document.getElementById('reset-btn').addEventListener('click', () => {
        initDateSelectors();
        
        // Clear map
        if (mapLayerGroup) {
          mapLayerGroup.clearLayers();
        }
        
        // Clear histogram
        document.getElementById('message-histogram').innerHTML = '';
        
        // Clear tables
        document.querySelector('#destination-changes tbody').innerHTML = '';
        document.querySelector('#status-changes tbody').innerHTML = '';
      });
    });

    // Store vessel AIS class globally - moved to loadVesselData function
    
    // Function to display message histogram
    function displayMessageHistogram(historyData) {
      if (!historyData || !historyData.length) {
        return;
      }
      
      const histogramContainer = document.getElementById('message-histogram');
      histogramContainer.innerHTML = '';
      
      // Filter for position messages only
      const positionMessageTypes = ['1', '2', '3', '18', '19'];
      const positionMessages = historyData.filter(msg =>
        positionMessageTypes.includes(msg.MessageID.toString())
      );
      
      if (positionMessages.length === 0) {
        histogramContainer.innerHTML = '<div style="padding: 10px; text-align: center; color: #666;">No position messages available</div>';
        return;
      }
      
      // Sort messages by timestamp (oldest first)
      positionMessages.sort((a, b) => new Date(a.Timestamp) - new Date(b.Timestamp));
      
      // Get time range
      const startTime = new Date(positionMessages[0].Timestamp);
      const endTime = new Date(positionMessages[positionMessages.length - 1].Timestamp);
      const totalDuration = endTime - startTime;
      
      // Target number of bins based on duration
      let targetBins, binLabel;
      if (totalDuration <= 3600000) { // 1 hour or less
        targetBins = 60; // ~1 minute bins for 1 hour
        binLabel = 'interval';
      } else if (totalDuration <= 86400000) { // 1 day or less
        targetBins = 96; // ~15 minute bins for 1 day
        binLabel = 'interval';
      } else {
        targetBins = 100; // ~43 minute bins for 3 days
        binLabel = 'interval';
      }
      
      // Calculate bin size based on target number of bins
      const binSize = Math.max(60000, Math.ceil(totalDuration / targetBins)); // Minimum 1 minute
      
      // Create bins
      const bins = {};
      const numBins = Math.ceil(totalDuration / binSize);
      
      // Initialize bins
      for (let i = 0; i < numBins; i++) {
        const binTime = new Date(startTime.getTime() + (i * binSize));
        bins[i] = {
          count: 0,
          startTime: binTime,
          endTime: new Date(binTime.getTime() + binSize)
        };
      }
      
      // Count messages in each bin
      positionMessages.forEach(msg => {
        const msgTime = new Date(msg.Timestamp);
        const binIndex = Math.floor((msgTime - startTime) / binSize);
        if (bins[binIndex]) {
          bins[binIndex].count++;
        }
      });
      
      // Find maximum count for scaling
      const maxCount = Math.max(...Object.values(bins).map(bin => bin.count));
      
      // Create SVG for histogram
      const svgNS = "http://www.w3.org/2000/svg";
      const svg = document.createElementNS(svgNS, "svg");
      svg.setAttribute("width", "100%");
      svg.setAttribute("height", "100%");
      
      // Calculate bar width based on number of bins
      const barWidth = 100 / numBins;
      
      // Create bars
      Object.values(bins).forEach((bin, index) => {
        const barHeight = bin.count > 0 ? (bin.count / maxCount) * 80 : 0;
        const bar = document.createElementNS(svgNS, "rect");
        
        // Position and size
        bar.setAttribute("x", `${index * barWidth}%`);
        bar.setAttribute("y", `${80 - barHeight}%`);
        bar.setAttribute("width", `${barWidth - 0.1}%`);
        bar.setAttribute("height", `${barHeight}%`);
        
        // Styling - green to red gradient based on count intensity
        const ratio = bin.count / maxCount;
        // Calculate hue: 120 (green) for low counts to 0 (red) for high counts
        const hue = (1 - ratio) * 120;
        bar.setAttribute("fill", `hsl(${hue}, 100%, 50%)`);
        
        // Tooltip
        const title = document.createElementNS(svgNS, "title");
        const formattedStart = bin.startTime.toLocaleString([], {
          month: 'short',
          day: 'numeric',
          hour: '2-digit',
          minute: '2-digit'
        });
        title.textContent = `${bin.count} messages at ${formattedStart}`;
        bar.appendChild(title);
        
        svg.appendChild(bar);
      });
      
      // Add legend
      const legend = document.createElement('div');
      legend.style.position = 'absolute';
      legend.style.top = '5px';
      legend.style.right = '10px';
      legend.style.fontSize = '12px';
      legend.style.background = 'rgba(255, 255, 255, 0.7)';
      legend.style.padding = '3px 6px';
      legend.style.borderRadius = '3px';
      
      // Create legend content with color gradient
      legend.innerHTML = `
        <div style="display: flex; align-items: center; gap: 5px;">
          <div style="font-weight: bold;">Message Count:</div>
          <div style="width: 60px; height: 10px; background: linear-gradient(to right, hsl(120,100%,50%), hsl(60,100%,50%), hsl(0,100%,50%));"></div>
          <div style="display: flex; justify-content: space-between; width: 60px;">
            <span>Low</span>
            <span>High</span>
          </div>
        </div>
      `;
      
      // Add title
      const title = document.createElement('div');
      title.style.position = 'absolute';
      title.style.top = '5px';
      title.style.left = '10px';
      title.style.fontSize = '12px';
      title.style.fontWeight = 'bold';
      title.textContent = `Position Message Frequency (${numBins} intervals)`;
      
      histogramContainer.appendChild(svg);
      histogramContainer.appendChild(title);
      histogramContainer.appendChild(legend);
    }
  </script>
</body>
</html>