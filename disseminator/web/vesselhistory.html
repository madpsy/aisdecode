<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Vessel History</title>
  <!-- Include Bootstrap CSS -->
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/twitter-bootstrap/4.6.0/css/bootstrap.min.css">
  <!-- Include Leaflet CSS -->
  <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.3/dist/leaflet.css"
        integrity="sha256-kLaT2GOSpHechhsozzB+flnD+zUyjE2LlfWPgU04xyI=" crossorigin="" />
  <style>
    body {
      font-family: sans-serif;
      margin: 2rem;
    }
    /* Search styles */
    .search-container {
      position: relative;
      display: flex;
      align-items: center;
    }
    .search-icon {
      cursor: pointer;
      margin-right: 10px;
    }
    .search-box {
      display: none;
      position: relative;
    }
    .search-input {
      padding: 5px 10px;
      border: 1px solid #ccc;
      border-radius: 4px;
      width: 250px;
    }
    .search-results {
      position: absolute;
      top: 100%;
      left: 0;
      width: 100%;
      max-height: 300px;
      overflow-y: auto;
      background-color: white;
      border: 1px solid #ccc;
      border-top: none;
      border-radius: 0 0 4px 4px;
      z-index: 1000;
      display: none;
    }
    .search-result-item {
      padding: 8px 12px;
      border-bottom: 1px solid #eee;
      cursor: pointer;
    }
    .search-result-item:hover {
      background-color: #f5f5f5;
    }
    .search-result-item:last-child {
      border-bottom: none;
    }
    .title-container {
      display: flex;
      align-items: center;
      gap: 10px;
    }
    /* Selection window styles for histogram */
    #message-histogram {
      position: relative;
      user-select: none;
    }
    .selection-window {
      position: absolute;
      top: 0;
      height: 100%;
      background-color: rgba(255, 165, 0, 0.2);
      border-left: 2px solid rgba(255, 165, 0, 0.7);
      border-right: 2px solid rgba(255, 165, 0, 0.7);
      pointer-events: none;
      z-index: 10;
    }
    .selection-handle {
      position: absolute;
      top: 0;
      width: 8px;
      height: 100%;
      background-color: rgba(255, 165, 0, 0.7);
      cursor: ew-resize;
      pointer-events: all;
    }
    .selection-handle-left {
      left: -4px;
    }
    .selection-handle-right {
      right: -4px;
    }
    .selection-info {
      position: absolute;
      top: 5px;
      left: 50%;
      transform: translateX(-50%);
      background-color: rgba(255, 255, 255, 0.8);
      padding: 2px 6px;
      border-radius: 3px;
      font-size: 11px;
      pointer-events: none;
      white-space: nowrap;
    }
    .vessel-header {
      display: flex;
      align-items: flex-start;
      margin-bottom: 2rem;
    }
    .flag-container {
      margin-right: 2rem;
    }
    .flag-img {
      width: 80px;
      height: auto;
      border: 1px solid #ddd;
    }
    .vessel-info {
      flex-grow: 1;
      display: flex;
      flex-wrap: wrap;
      gap: 1rem;
    }
    .vessel-image {
      max-width: 300px;
      max-height: 200px;
      border: 1px solid #ddd;
      margin-left: 1rem;
    }
    .error {
      color: red;
      font-weight: bold;
    }
    .info-column {
      flex: 1;
      min-width: 300px;
    }
    table {
      border-collapse: collapse;
      width: 100%;
      margin-bottom: 1rem;
    }
    th, td {
      border: 1px solid #ddd;
      padding: 6px;
      text-align: left;
    }
    th {
      background-color: #f2f2f2;
    }
    .history-section {
      margin-top: 2rem;
    }
    .date-selector {
      display: flex;
      gap: 1rem;
      margin-bottom: 1rem;
      align-items: center;
    }
    .date-selector label {
      display: flex;
      flex-direction: column;
      margin-bottom: 0;
    }
    .date-selector button {
      margin-top: 1.5rem;
    }
    #receiver-select {
      min-width: 120px;
    }
    #message-histogram {
      height: 80px;
      width: 100%;
      margin-bottom: 1rem;
      border: 1px solid #ddd;
      position: relative;
      background-color: #f9f9f9;
    }
    #map-container {
      height: 400px;
      margin-bottom: 1rem;
      border: 1px solid #ddd;
      position: relative;
      overflow: hidden;
    }
    .changes-container {
      display: flex;
      flex-wrap: wrap;
      gap: 1rem;
      margin-top: 1rem;
    }
    .changes-table {
      flex: 1;
      min-width: 300px;
    }
    .changes-table h3 {
      font-size: 1.2rem;
      margin-bottom: 0.5rem;
    }
    .no-changes {
      font-style: italic;
      color: #666;
    }
    /* Speed legend styles */
    .speed-legend {
      position: absolute;
      top: 10px;
      right: 10px;
      background: rgba(255, 255, 255, 0.6);
      padding: 5px;
      border: 1px solid #ccc;
      border-radius: 3px;
      z-index: 1000;
      font-size: 12px;
      width: 120px;
    }
    
    /* Replay control styles */
    .replay-control {
      position: absolute;
      bottom: 10px;
      left: 10px;
      background: rgba(255, 255, 255, 0.6);
      padding: 5px;
      border: 1px solid #ccc;
      border-radius: 3px;
      z-index: 1000;
      font-size: 12px;
      display: flex;
      align-items: center;
      gap: 5px;
    }
    
    /* Overlay styles for timestamp and distance */
    .map-overlay {
      position: absolute;
      left: 50%;
      transform: translateX(-50%);
      background: rgba(0, 0, 0, 0.5);
      color: white;
      padding: 5px 10px;
      border-radius: 3px;
      z-index: 1000;
      font-size: 14px;
      font-weight: bold;
      display: none;
    }
    
    /* Distance overlay always at top */
    .distance-overlay {
      top: 10px;
      display: block; /* Always visible */
    }
    
    /* Timestamp overlay below distance overlay */
    .timestamp-overlay {
      top: 45px;
    }
    
    /* Replay details overlay */
    .vessel-replay-info-box {
      position: fixed;
      background: rgba(0, 0, 0, 0.7);
      color: white;
      padding: 10px;
      border-radius: 5px;
      font-size: 12px;
      z-index: 2000;
      display: table;
      pointer-events: none;
    }
    .replay-button {
      padding: 4px 8px;
      background-color: #4CAF50;
      color: white;
      border: none;
      border-radius: 3px;
      cursor: pointer;
      font-size: 12px;
      display: flex;
      align-items: center;
      gap: 3px;
    }
    .replay-button:hover {
      background-color: #45a049;
    }
    .replay-button:disabled {
      background-color: #cccccc;
      cursor: not-allowed;
    }
    .replay-duration {
      padding: 2px;
      font-size: 12px;
      border-radius: 3px;
      border: 1px solid #ccc;
    }
    .replay-progress {
      position: absolute;
      bottom: 0;
      left: 0;
      height: 3px;
      background-color: #4CAF50;
      width: 0%;
      transition: width 0.1s linear;
    }
    .speed-scale-container {
      margin-bottom: 6px;
      padding: 0 5px;
      font-family: Arial, sans-serif;
      font-size: 12px;
      line-height: 1;
    }
    .speed-scale-bar {
      height: 6px;
      border-radius: 3px;
      background: linear-gradient(
        to right,
        hsl(120,100%,50%) 0%,    /* green */
        hsl(60, 100%,50%) 50%,   /* yellow */
        hsl(0,  100%,50%) 100%   /* red */
      );
      margin-bottom: 2px;
    }
    .speed-scale-labels {
      display: flex;
      justify-content: space-between;
    }
    #copy-link-btn {
      display: flex;
      align-items: center;
      gap: 5px;
      padding: 5px 10px;
      font-size: 0.9rem;
    }
    #copy-link-btn svg {
      margin-right: 3px;
    }
    
    /* Image overlay styles */
        .image-overlay {
          display: none;
          position: fixed;
          top: 0;
          left: 0;
          width: 100%;
          height: 100%;
          background-color: rgba(0, 0, 0, 0.8);
          z-index: 2000;
          justify-content: center;
          align-items: center;
        }
        
        .image-overlay.active {
          display: flex;
        }
        
        .overlay-content {
          position: relative;
          max-width: 90%;
          max-height: 90%;
        }
        
        .overlay-content img {
          max-width: 100%;
          max-height: 90vh;
          border: 2px solid white;
          box-shadow: 0 0 20px rgba(0, 0, 0, 0.5);
        }
        
        .close-overlay {
          position: absolute;
          top: -20px;
          right: -20px;
          width: 40px;
          height: 40px;
          border-radius: 50%;
          background-color: white;
          color: black;
          font-size: 24px;
          display: flex;
          justify-content: center;
          align-items: center;
          cursor: pointer;
          box-shadow: 0 0 10px rgba(0, 0, 0, 0.5);
          z-index: 2001; /* Ensure it's above the overlay */
        }
        
        /* Specific style for packet overlay close button */
        #packet-overlay .close-overlay {
          top: -20px;
          right: -20px;
          z-index: 3000; /* Even higher z-index */
        }
        
        /* Packet details overlay styles */
        .packet-overlay {
          display: none;
          position: fixed;
          top: 0;
          left: 0;
          width: 100%;
          height: 100%;
          background-color: rgba(0, 0, 0, 0.8);
          z-index: 2000;
          justify-content: center;
          align-items: center;
        }
        
        .packet-overlay.active {
          display: flex;
        }
        
        /* Use the same overlay-content class for both overlays */
        #packet-overlay .overlay-content {
          position: relative;
          max-width: 90%;
          max-height: 90%;
        }
        
        .packet-content {
          background-color: white;
          padding: 20px;
          border-radius: 5px;
          max-width: 100%;
          max-height: 90vh;
          overflow-y: auto;
          box-shadow: 0 0 20px rgba(0, 0, 0, 0.5);
        }
        
        .packet-json {
          margin-bottom: 15px;
          overflow: auto;
          max-height: 300px;
        }
        
        .packet-json table {
          border-collapse: collapse;
          width: 100%;
        }
        
        .packet-json th, .packet-json td {
          border: 1px solid #ddd;
          padding: 8px;
          text-align: left;
        }
        
        .packet-json th {
          background-color: #f2f2f2;
        }
        
        .raw-sentence {
          background-color: #f5f5f5;
          padding: 10px;
          border-radius: 4px;
          font-family: monospace;
          white-space: pre-wrap;
          word-break: break-all;
          margin-bottom: 15px;
        }
        
        .receiver-info {
          padding: 10px;
          background-color: #e8f4ff;
          border-radius: 4px;
        }
    
    #vessel-img {
      cursor: pointer;
    }
  </style>
  
  <!-- Add custom style for receiver tooltips -->
  <style>
    .receiver-tooltip {
      background-color: rgba(255, 255, 255, 0.9);
      border: 1px solid #999;
      border-radius: 3px;
      padding: 2px 5px;
      font-weight: bold;
      font-size: 11px;
      box-shadow: 0 1px 3px rgba(0,0,0,0.3);
    }
    
    .receiver-tooltip-active {
      border: 2px solid #f03;
    }
    
    /* Replay tooltip styles */
    .replay-tooltip {
      z-index: 1000 !important; /* Higher z-index to stay on top */
    }
    
    /* Lower z-index for receiver tooltips during replay */
    .replay-active .receiver-tooltip {
      z-index: 500 !important;
    }
  </style>
</head>
<body>
  <div style="display: flex; justify-content: space-between; align-items: center;">
    <div class="title-container">
      <h1 id="main-title">Vessel History</h1>
      <button id="copy-link-btn" class="btn btn-sm btn-outline-secondary">
        <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" class="bi bi-link-45deg" viewBox="0 0 16 16">
          <path d="M4.715 6.542 3.343 7.914a3 3 0 1 0 4.243 4.243l1.828-1.829A3 3 0 0 0 8.586 5.5L8 6.086a1.002 1.002 0 0 0-.154.199 2 2 0 0 1 .861 3.337L6.88 11.45a2 2 0 1 1-2.83-2.83l.793-.792a4.018 4.018 0 0 1-.128-1.287z"/>
          <path d="M6.586 4.672A3 3 0 0 0 7.414 9.5l.775-.776a2 2 0 0 1-.896-3.346L9.12 3.55a2 2 0 1 1 2.83 2.83l-.793.792c.112.42.155.855.128 1.287l1.372-1.372a3 3 0 1 0-4.243-4.243L6.586 4.672z"/>
        </svg>
        Link
      </button>
    </div>
    <div class="search-container">
      <div class="search-icon">
        <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" fill="currentColor" class="bi bi-search" viewBox="0 0 16 16">
          <path d="M11.742 10.344a6.5 6.5 0 1 0-1.397 1.398h-.001c.03.04.062.078.098.115l3.85 3.85a1 1 0 0 0 1.415-1.414l-3.85-3.85a1.007 1.007 0 0 0-.115-.1zM12 6.5a5.5 5.5 0 1 1-11 0 5.5 5.5 0 0 1 11 0z"/>
        </svg>
      </div>
      <div class="search-box">
        <input type="text" class="search-input" placeholder="Search vessels...">
        <div class="search-results"></div>
      </div>
    </div>
  </div>
  
  <!-- Packet details overlay -->
  <div id="packet-overlay" class="packet-overlay">
    <div class="overlay-content">
      <div class="close-overlay">&times;</div>
      <div class="packet-content">
        <h4>Packet Details</h4>
        <div id="packet-json" class="packet-json"></div>
        <div>
          <pre id="raw-sentence" class="raw-sentence"></pre>
        </div>
        <div id="receiver-info" class="receiver-info"></div>
      </div>
    </div>
  </div>

  <div class="vessel-header">
    <div class="flag-container">
      <img id="flag-img" class="flag-img" src="" alt="Country Flag" style="display: none;">
    </div>
    <div class="vessel-info">
      <div class="info-column">
        <table id="vessel-table-left">
          <tbody>
            <!-- Left column data will be inserted here dynamically -->
          </tbody>
        </table>
      </div>
      <div class="info-column">
        <table id="vessel-table-right">
          <tbody>
            <!-- Right column data will be inserted here dynamically -->
          </tbody>
        </table>
      </div>
    </div>
    <div>
      <img id="vessel-img" class="vessel-image" src="" alt="Vessel Image" style="display: none;">
    </div>
    
    <!-- Image overlay -->
    <div id="image-overlay" class="image-overlay">
      <div class="overlay-content">
        <div class="close-overlay">&times;</div>
        <img id="overlay-img" src="" alt="Vessel Image Full Size">
      </div>
    </div>
  </div>

  <div class="history-section">
    <div class="date-selector">
      <label>From <input type="datetime-local" id="start"/></label>
      <label>To <input type="datetime-local" id="end"/></label>
      <label>Receiver
        <select id="receiver-select" class="form-control">
          <option value="">All</option>
          <!-- Receiver options will be populated dynamically -->
        </select>
      </label>
      <button id="apply-btn" class="btn btn-primary">Search</button>
      <button id="reset-btn" class="btn btn-secondary">Reset</button>
      <button id="download-csv-btn" class="btn btn-outline-secondary" disabled>Download CSV</button>
    </div>
    
    <div id="error" class="error"></div>
    <div id="data-info" class="mt-2 mb-2" style="font-size: 0.9rem; color: #666;"></div>
    
    <div id="message-histogram"></div>
    
    <div id="map-container">
      <div class="speed-legend">
        <div class="speed-scale-container">
          <div class="speed-scale-bar"></div>
          <div class="speed-scale-labels">
            <span>0 kn</span>
            <span>40 kn</span>
          </div>
        </div>
        <div class="map-controls mt-2">
          <label class="d-flex align-items-center">
            <input type="checkbox" id="seamap-toggle" checked>
            <span class="ml-1" style="margin-left: 5px; font-size: 12px;">OpenSeaMap</span>
          </label>
        </div>
      </div>
      <div id="distance-overlay" class="map-overlay distance-overlay"></div>
      <div id="timestamp-overlay" class="map-overlay timestamp-overlay"></div>
      <div class="replay-control">
        <button id="replay-button" class="replay-button">
          <svg xmlns="http://www.w3.org/2000/svg" width="12" height="12" fill="currentColor" viewBox="0 0 16 16">
            <path d="M11.596 8.697l-6.363 3.692c-.54.313-1.233-.066-1.233-.697V4.308c0-.63.692-1.01 1.233-.696l6.363 3.692a.802.802 0 0 1 0 1.393z"/>
          </svg>
          Replay
        </button>
        <select id="replay-duration" class="replay-duration">
          <option value="10">10s</option>
          <option value="20" selected>20s</option>
          <option value="30">30s</option>
          <option value="60">60s</option>
        </select>
        <div id="replay-progress" class="replay-progress"></div>
      </div>
    </div>
    
    <div class="changes-container">
      <div class="changes-table">
        <h3>Destination Changes</h3>
        <table id="destination-changes" class="table table-striped table-bordered">
          <thead>
            <tr>
              <th>Time</th>
              <th>From</th>
              <th>To</th>
              <th>ETA</th>
            </tr>
          </thead>
          <tbody>
            <!-- Destination changes will be inserted here -->
          </tbody>
        </table>
      </div>
      
      <div class="changes-table">
        <h3>Status Changes</h3>
        <table id="status-changes" class="table table-striped table-bordered">
          <thead>
            <tr>
              <th>Time</th>
              <th>From</th>
              <th>To</th>
            </tr>
          </thead>
          <tbody>
            <!-- Status changes will be inserted here -->
          </tbody>
        </table>
      </div>
    </div>
  </div>

  <!-- Include jQuery -->
  <script src="https://code.jquery.com/jquery-3.5.1.min.js"></script>
  <!-- Include Leaflet JS -->
  <script src="https://unpkg.com/leaflet@1.9.3/dist/leaflet.js"
          integrity="sha256-WBkoXOwTeyKclOHuWtc+i2uENFpDZ9YPdf5Hf+D7ewM=" crossorigin=""></script>
  <script>
    // Get UserID from URL query parameter
    function getQueryParam(name) {
      const urlParams = new URLSearchParams(window.location.search);
      return urlParams.get(name);
    }

    const userID = getQueryParam('UserID');
    let midsMapping = {};
    let shipTypeConfig = {};
    let navStatusMapping = {};
    let receiversData = []; // Store receivers data globally
    let lastSeenTime = null; // Store the last seen time globally
    let dateRangeAdjusted = false; // Track if date range was automatically adjusted

    // Format time difference as a human-readable string
    function formatTimeDifference(timestamp) {
      const now = new Date();
      const date = new Date(timestamp);
      const diffMs = now - date;
      
      const seconds = Math.floor(diffMs / 1000);
      const minutes = Math.floor(seconds / 60);
      const hours = Math.floor(minutes / 60);
      const days = Math.floor(hours / 24);
      
      const remainingHours = hours % 24;
      const remainingMinutes = minutes % 60;
      const remainingSeconds = seconds % 60;
      
      let result = '';
      if (days > 0) result += `${days}d `;
      if (remainingHours > 0 || days > 0) result += `${remainingHours}h `;
      if (remainingMinutes > 0 || remainingHours > 0 || days > 0) result += `${remainingMinutes}m `;
      result += `${remainingSeconds}s ago`;
      
      return result;
    }

    // Load MIDs mapping, ship types, and nav status
    Promise.all([
      fetch('/mids.json').then(r => r.json()),
      fetch('/types.json').then(r => r.json()),
      fetch('/navstatus.json').then(r => r.json())
    ])
    .then(([midsData, typesData, navStatusData]) => {
      midsMapping = midsData;
      shipTypeConfig = typesData;
      navStatusMapping = navStatusData;
      loadVesselData();
    })
    .catch(err => {
      console.error('Error loading data:', err);
      document.getElementById('error').textContent = 'Failed to load reference data.';
      loadVesselData(); // Still try to load vessel data even if data loading fails
    });

    // Helper: given a numeric code and the types.json config, return the category name
    function lookupShipType(code) {
      if (!shipTypeConfig.valueLookup || !code) return code;
      
      const categoryId = shipTypeConfig.valueLookup[code];
      if (categoryId == null) return code;
      
      const category = shipTypeConfig.categories.find(cat => cat.id === categoryId);
      return category ? `${category.name} (ID: ${code})` : code;
    }

    // Helper: look up navigational status text
    function lookupNavStatus(code) {
      if (!navStatusMapping || code === undefined || code === null) return "Unknown";
      return navStatusMapping[code] || "Unknown";
    }

    function loadVesselData() {
      if (!userID) {
        document.getElementById('main-title').textContent = 'Error';
        document.getElementById('error').textContent = 'Missing UserID in URL.';
        return;
      }

      fetch(`/state?UserID=${userID}`, { cache: 'no-store' })
        .then(response => response.json())
        .then(data => {
          // Store AIS class globally for use in fetchVesselHistory
          vesselAisClass = data.AISClass || '';
          console.log('Vessel AIS Class:', vesselAisClass);
          
          // Update receiver dropdown based on ReceiverIDs
          if (data.ReceiverIDs && Array.isArray(data.ReceiverIDs) && data.ReceiverIDs.length > 0) {
            console.log('Vessel heard by receivers:', data.ReceiverIDs);
            
            // Ensure receivers data is loaded
            if (receiversData.length === 0) {
              // If receivers data isn't loaded yet, fetch it now
              fetchReceiversData();
            } else {
              // Filter the receiver dropdown to only show receivers that heard this vessel
              const receiverSelect = document.getElementById('receiver-select');
              
              // Keep only the "All" option and receivers that heard this vessel
              while (receiverSelect.options.length > 1) {
                receiverSelect.remove(1);
              }
              
              // Add options for each receiver that heard this vessel
              receiversData.forEach(receiver => {
                if (data.ReceiverIDs.includes(receiver.id)) {
                  const option = document.createElement('option');
                  option.value = receiver.id;
                  option.textContent = receiver.name;
                  receiverSelect.appendChild(option);
                }
              });
            }
          } else {
            // If ReceiverIDs is empty, ensure only the "All" option is shown
            const receiverSelect = document.getElementById('receiver-select');
            
            // Keep only the "All" option
            while (receiverSelect.options.length > 1) {
              receiverSelect.remove(1);
            }
          }
          
          // Update page title with vessel name if available
          if (data.Name) {
            document.getElementById('main-title').textContent = `${data.Name.trim()}`;
          } else {
            document.getElementById('main-title').textContent = `${userID}`;
          }

          // Get country code from MID (first 3 digits of UserID)
          const mid = userID.toString().substring(0, 3);
          if (midsMapping[mid] && midsMapping[mid][0]) {
            const countryCode = midsMapping[mid][0].toLowerCase();
            const flagUrl = `/flags/${countryCode}.svg`;
            const flagImg = document.getElementById('flag-img');
            flagImg.src = flagUrl;
            flagImg.alt = `${midsMapping[mid][3]} Flag`;
            flagImg.style.display = 'block';
          }

          // Display vessel image if available
          if (data.ImageURL) {
            const vesselImg = document.getElementById('vessel-img');
            vesselImg.src = data.ImageURL;
            vesselImg.style.display = 'block';
          }

          // Create table rows for vessel information
          const leftTableBody = document.querySelector('#vessel-table-left tbody');
          const rightTableBody = document.querySelector('#vessel-table-right tbody');
          leftTableBody.innerHTML = ''; // Clear existing rows
          rightTableBody.innerHTML = ''; // Clear existing rows

          // Fields to display (if available)
          const fieldsToDisplay = [
            { key: 'UserID', label: 'MMSI' },
            { key: 'Name', label: 'Name' },
            { key: 'CallSign', label: 'Call Sign' },
            {
              key: 'ImoNumber',
              label: 'IMO Number',
              // Treat IMO Number = 0 as empty
              checkValue: (val) => val !== undefined && val !== null && val !== '' && val !== 0
            },
            { key: 'AISClass', label: 'AIS Class' },
            { key: 'Type', label: 'Type', format: (val) => lookupShipType(val) },
            {
              key: 'Flag',
              label: 'Flag',
              // Custom value that doesn't exist in the data object
              customValue: true,
              format: () => {
                // Get country name from MID (first 3 digits of UserID)
                const mid = userID.toString().substring(0, 3);
                if (midsMapping[mid] && midsMapping[mid][3]) {
                  return midsMapping[mid][3]; // 4th element is the full country name
                }
                return 'Unknown';
              }
            },
            { key: 'NavigationalStatus', label: 'Status', format: (val) => lookupNavStatus(val) },
            { key: 'Destination', label: 'Destination' },
            {
              key: 'MaximumStaticDraught',
              label: 'Max Draught',
              format: (val) => val ? `${val} m` : '',
              checkValue: (val) => val !== undefined && val !== null && val !== '' && val !== 0
            },
            {
              key: 'Dimension',
              label: 'Dimension',
              format: (val) => {
                if (!val || typeof val !== 'object') return '';
                const length = (val.A || 0) + (val.B || 0);
                const width = (val.C || 0) + (val.D || 0);
                return `${length}m × ${width}m`;
              }
            },
            {
              key: 'LastUpdated',
              label: 'Last Seen',
              format: (val) => {
                const localTime = new Date(val).toLocaleString();
                const timeDiff = formatTimeDifference(val);
                // Store the last seen time globally
                lastSeenTime = new Date(val);
                return `${localTime} (${timeDiff})`;
              }
            }
          ];

          // Add rows for each field if it exists and is not empty
          // Manually define which fields go in which table
          const leftTableFields = ['UserID', 'Name', 'CallSign', 'ImoNumber', 'AISClass', 'Type', 'Flag'];
          const rightTableFields = ['NavigationalStatus', 'Destination', 'MaximumStaticDraught', 'Dimension', 'LastUpdated'];
          
          // Process fields for left table
          fieldsToDisplay.filter(field => leftTableFields.includes(field.key)).forEach(field => {
            // Special cases for fields that should always be shown or have custom values
            const shouldDisplay = field.customValue ||
                                 field.key === 'NavigationalStatus' ||
                                 (field.checkValue ? field.checkValue(data[field.key]) :
                                  (data[field.key] !== undefined &&
                                   data[field.key] !== null &&
                                   data[field.key] !== ''));
            
            if (shouldDisplay) {
              const row = document.createElement('tr');
              
              const labelCell = document.createElement('td');
              labelCell.textContent = field.label;
              labelCell.style.fontWeight = 'bold';
              row.appendChild(labelCell);
              
              const valueCell = document.createElement('td');
              // For custom value fields, just call the format function directly
              if (field.customValue && field.format) {
                valueCell.textContent = field.format();
              } else {
                // Otherwise use formatter function if provided, or use raw value
                const value = data[field.key];
                valueCell.textContent = field.format ? field.format(value) : (value || '');
              }
              row.appendChild(valueCell);
              
              leftTableBody.appendChild(row);
            }
          });
          
          // Process fields for right table
          fieldsToDisplay.filter(field => rightTableFields.includes(field.key)).forEach(field => {
            // Special cases for fields that should always be shown or have custom values
            const shouldDisplay = field.customValue ||
                                 field.key === 'NavigationalStatus' ||
                                 (field.checkValue ? field.checkValue(data[field.key]) :
                                  (data[field.key] !== undefined &&
                                   data[field.key] !== null &&
                                   data[field.key] !== ''));
            
            if (shouldDisplay) {
              const row = document.createElement('tr');
              
              const labelCell = document.createElement('td');
              labelCell.textContent = field.label;
              labelCell.style.fontWeight = 'bold';
              row.appendChild(labelCell);
              
              const valueCell = document.createElement('td');
              // For custom value fields, just call the format function directly
              if (field.customValue && field.format) {
                valueCell.textContent = field.format();
              } else {
                // Otherwise use formatter function if provided, or use raw value
                const value = data[field.key];
                valueCell.textContent = field.format ? field.format(value) : (value || '');
              }
              row.appendChild(valueCell);
              
              rightTableBody.appendChild(row);
            }
          });

          // If no data was added to either table
          if (leftTableBody.children.length === 0 && rightTableBody.children.length === 0) {
            const row = document.createElement('tr');
            const cell = document.createElement('td');
            cell.colSpan = 2;
            cell.textContent = 'No vessel information available';
            row.appendChild(cell);
            leftTableBody.appendChild(row);
          }
        })
        .catch(err => {
          console.error('Error fetching vessel data:', err);
          document.getElementById('error').textContent = 'Failed to load vessel data.';
        });
    }

    // Fetch receivers data and populate the dropdown
    function fetchReceiversData() {
      fetch('/receivers', { cache: 'no-store' })
        .then(response => response.json())
        .then(data => {
          receiversData = data;
          const receiverSelect = document.getElementById('receiver-select');
          
          // Clear existing options except the "All" option
          while (receiverSelect.options.length > 1) {
            receiverSelect.remove(1);
          }
          
          // Add options for each receiver
          data.forEach(receiver => {
            const option = document.createElement('option');
            option.value = receiver.id;
            option.textContent = receiver.name;
            receiverSelect.appendChild(option);
          });
        })
        .catch(err => {
          console.error('Error fetching receivers data:', err);
        });
    }

    // Initialize date selectors with values from URL parameters or default to last 24 hours
    function initDateSelectors() {
      // Try to get start and end from URL parameters
      const startParam = getQueryParam('start');
      const endParam = getQueryParam('end');
      const receiverIdParam = getQueryParam('ReceiverID');
      
      let end, start;
      
      // If end parameter exists and is valid, use it; otherwise use current time
      if (endParam && !isNaN(new Date(endParam).getTime())) {
        end = new Date(endParam);
      } else {
        end = new Date();
      }
      
      // If start parameter exists and is valid, use it; otherwise use 24 hours before end
      if (startParam && !isNaN(new Date(startParam).getTime())) {
        start = new Date(startParam);
      } else {
        start = new Date(end);
        start.setDate(start.getDate() - 1); // 1 day ago
      }
      
      // Format the date for the datetime-local input in local time
      document.getElementById('end').value = formatDateForInput(end);
      document.getElementById('start').value = formatDateForInput(start);
      
      // Helper function to format a date for datetime-local input
      function formatDateForInput(date) {
        const year = date.getFullYear();
        const month = String(date.getMonth() + 1).padStart(2, '0');
        const day = String(date.getDate()).padStart(2, '0');
        const hours = String(date.getHours()).padStart(2, '0');
        const minutes = String(date.getMinutes()).padStart(2, '0');
        return `${year}-${month}-${day}T${hours}:${minutes}`;
      }
      
      // Set receiver dropdown if ReceiverID parameter exists
      if (receiverIdParam) {
        console.log('ReceiverID parameter found:', receiverIdParam);
        
        // Track attempts to prevent infinite polling
        let attempts = 0;
        const maxAttempts = 50; // 10 seconds max (50 * 200ms)
        
        // We'll set this once the receivers are fully loaded
        const checkReceiverInterval = setInterval(() => {
          const receiverSelect = document.getElementById('receiver-select');
          attempts++;
          
          // Check if we've reached max attempts
          if (attempts >= maxAttempts) {
            console.log('Max attempts reached, stopping receiver selection check');
            clearInterval(checkReceiverInterval);
            return;
          }
          
          // Only proceed if we have receivers data loaded
          if (receiversData.length > 0 && receiverSelect.options.length > 1) {
            console.log('Checking for receiver option with value:', receiverIdParam);
            let found = false;
            
            // Find the option with the matching value
            for (let i = 0; i < receiverSelect.options.length; i++) {
              if (receiverSelect.options[i].value === receiverIdParam) {
                console.log('Found matching receiver option at index:', i);
                receiverSelect.selectedIndex = i;
                found = true;
                break;
              }
            }
            
            // If we found the option or we've checked multiple times, stop checking
            if (found || attempts > 10) {
              if (!found) {
                console.log('Receiver option not found after multiple attempts');
              }
              clearInterval(checkReceiverInterval);
            }
          } else {
            console.log('Waiting for receivers to load...',
                      'receiversData.length:', receiversData.length,
                      'options.length:', receiverSelect.options.length);
          }
        }, 200); // Increased interval to 200ms to give more time for loading
      }
    }

    // Initialize map
    let map = null;
    let mapLayerGroup = null;

    // Store OpenSeaMap layer globally
    let openSeaMapLayer = null;
    
    function initMap() {
      if (!map) {
        map = L.map('map-container').setView([0, 0], 2);
        
        // Add base OpenStreetMap layer
        L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
          attribution: '&copy; OpenStreetMap'
        }).addTo(map);
        
        // Add OpenSeaMap layer (enabled by default)
        openSeaMapLayer = L.tileLayer('https://tiles.openseamap.org/seamark/{z}/{x}/{y}.png', {
          attribution: '&copy; OpenSeaMap'
        }).addTo(map);
        
        // Add layer for vessel tracks and markers
        mapLayerGroup = L.layerGroup().addTo(map);
        
        // Add event listener for the OpenSeaMap toggle checkbox
        document.getElementById('seamap-toggle').addEventListener('change', function(e) {
          if (e.target.checked) {
            // Add the OpenSeaMap layer if it's not already on the map
            if (openSeaMapLayer && !map.hasLayer(openSeaMapLayer)) {
              openSeaMapLayer.addTo(map);
            }
          } else {
            // Remove the OpenSeaMap layer if it's on the map
            if (openSeaMapLayer && map.hasLayer(openSeaMapLayer)) {
              map.removeLayer(openSeaMapLayer);
            }
          }
        });
      }
    }

    // Fetch vessel history data
    async function fetchVesselHistory() {
      const startInput = document.getElementById('start');
      const endInput = document.getElementById('end');
      const s = startInput.value, e = endInput.value;
      
      if (!s || !e) {
        alert('Please select From and To dates.');
        return null;
      }

      // Always request all message types regardless of AIS Class
      let positionMessageTypes = ['1', '2', '3', '18', '19']; // All position messages (Class A and B)
      let staticMessageTypes = ['5', '24'];                   // All static messages (Class A and B)

      const startTime = new Date(s).toISOString();
      const endTime = new Date(e).toISOString();
      const limit = 10000;

      try {
        // Get selected receiver ID
        const receiverSelect = document.getElementById('receiver-select');
        const selectedReceiverId = receiverSelect.value;
        
        // Create base parameters for both calls
        const positionParams = {
          UserID: userID,
          MessageID: positionMessageTypes.join(','),
          start: startTime,
          end: endTime,
          limit: limit
        };
        
        const staticParams = {
          UserID: userID,
          MessageID: staticMessageTypes.join(','),
          start: startTime,
          end: endTime,
          limit: limit
        };
        
        // Add ReceiverID parameter if a specific receiver is selected
        if (selectedReceiverId) {
          positionParams.ReceiverID = selectedReceiverId;
          staticParams.ReceiverID = selectedReceiverId;
        }
        
        // Make two separate calls for position and static messages
        const [positionResponse, staticResponse] = await Promise.all([
          // Position messages call
          fetch(`/latestmessages?${new URLSearchParams(positionParams)}`, {cache: 'no-store'}),
          
          // Static messages call
          fetch(`/latestmessages?${new URLSearchParams(staticParams)}`, {cache: 'no-store'})
        ]);

        // Parse both responses
        const positionData = await positionResponse.json();
        const staticData = await staticResponse.json();
        
        // Check if either response has the same number of results as the limit
        const positionCount = positionData.length;
        const staticCount = staticData.length;
        const combinedResults = [...positionData, ...staticData];
        
        // If either count matches the limit, show a warning
        if (positionCount === limit || staticCount === limit) {
          const warningDiv = document.getElementById('error');
          warningDiv.textContent = `Warning: Some data may be missing. ${positionCount === limit ? 'Position' : ''} ${positionCount === limit && staticCount === limit ? 'and' : ''} ${staticCount === limit ? 'Static' : ''} data reached the limit of ${limit} records. Try reducing the time range.`;
          warningDiv.style.display = 'block';
        } else if (dateRangeAdjusted) {
          // If date range was adjusted, keep the warning message
          const warningDiv = document.getElementById('error');
          warningDiv.textContent = 'Warning: Start date was too recent - automatically updated to a 24-hour window before the vessel\'s last seen time.';
          warningDiv.style.display = 'block';
          console.log('Warning message maintained in fetchVesselHistory, dateRangeAdjusted =', dateRangeAdjusted);
        } else {
          // Clear any previous warnings
          document.getElementById('error').textContent = '';
        }
        
        // Store position data globally for CSV download
        window.positionData = positionData;
        
        // Update data info
        const dataInfoDiv = document.getElementById('data-info');
        if (dataInfoDiv) {
          if (positionCount > 0) {
            // Sort position data by timestamp to find first and last
            const sortedPositions = [...positionData].sort((a, b) =>
              new Date(a.Timestamp) - new Date(b.Timestamp)
            );
            
            const firstTimestamp = new Date(sortedPositions[0].Timestamp).toLocaleString();
            const lastTimestamp = new Date(sortedPositions[sortedPositions.length - 1].Timestamp).toLocaleString();
            
            dataInfoDiv.textContent = `${positionCount} position messages found. First: ${firstTimestamp}, Last: ${lastTimestamp}`;
            
            // Enable download CSV button
            document.getElementById('download-csv-btn').disabled = false;
          } else {
            dataInfoDiv.textContent = 'No position messages found.';
            // Disable download CSV button
            document.getElementById('download-csv-btn').disabled = true;
          }
        }
        
        return combinedResults;
      } catch (err) {
        console.error('Error fetching vessel history:', err);
        alert('Failed to fetch vessel history data.');
        
        // Clear data info and disable download button
        const dataInfoDiv = document.getElementById('data-info');
        if (dataInfoDiv) {
          dataInfoDiv.textContent = '';
        }
        document.getElementById('download-csv-btn').disabled = true;
        
        return null;
      }
    }

    // Function to get color based on speed
    function getColorForSpeed(speed) {
      const maxSpeed = 40;  // maximum expected speed in knots
      // Clamp the speed value between 0 and maxSpeed
      const clampedSpeed = Math.max(0, Math.min(maxSpeed, speed));
      // Compute a ratio (0 = 0 knots, 1 = maxSpeed)
      const ratio = clampedSpeed / maxSpeed;
      // Calculate hue: 120 (green) at 0 knots to 0 (red) at maxSpeed knots.
      const hue = (1 - ratio) * 120;
      // Return a string with full saturation and 50% lightness.
      return `hsl(${hue}, 100%, 50%)`;
    }

    // Create a colored track with segments colored by speed
    function createColoredTrack(points) {
      const segments = [];
      // Loop through the points to create segments
      for (let i = 0; i < points.length - 1; i++) {
        const pt1 = points[i];
        const pt2 = points[i + 1];
        // Use the speed of the first point for the color
        const speed = pt1.data.Sog != null ? pt1.data.Sog : 0;
        const color = getColorForSpeed(speed);
        // Create a polyline segment with this color
        const segment = L.polyline([[pt1.lat, pt1.lng], [pt2.lat, pt2.lng]], {
          color: color,
          weight: 3,
          opacity: 0.8
        });
        segments.push(segment);
      }
      // Group the segments so they can be treated as one layer
      return L.layerGroup(segments);
    }

    // Helper to format one point's tooltip HTML for replay overlay
    function makeTooltipHTML(pt) {
      // Check for invalid coordinates (91, 181)
      if (pt.lat === 91 && pt.lng === 181) {
        return 'Invalid position data';
      }
      
      let html = '';
      
      // Start with navigational status if available
      if (pt.data.NavigationalStatus != null && navStatusMapping[pt.data.NavigationalStatus]) {
        html += `${navStatusMapping[pt.data.NavigationalStatus]}<br/>`;
      }
      
      // Add position
      html += `<strong>Lat:</strong> ${pt.lat.toFixed(6)}<br/>`;
      html += `<strong>Lon:</strong> ${pt.lng.toFixed(6)}<br/>`;
      
      // Add other interesting fields if available
      const fields = ['Sog', 'Cog', 'TrueHeading', 'Destination'];
      
      // Create a filtered list of fields, excluding TrueHeading if it's 511
      const filteredFields = fields.filter(field =>
        !(field === 'TrueHeading' && pt.data[field] === 511)
      );
      
      filteredFields.forEach((field, index) => {
        if (pt.data[field] != null) {
          let value = pt.data[field];
          let displayField = field;
          
          // Rename fields for display and format values
          if (field === 'TrueHeading') {
            displayField = 'Heading';
            value = `${value}°`;
          } else if (field === 'Sog') {
            displayField = 'Speed';
            value = `${value} kn`;
          } else if (field === 'Cog') {
            displayField = 'Course';
            value = `${value}°`;
          }
          
          html += `<strong>${displayField}:</strong> ${escapeHtml(value)}`;
          
          // Add line break after each field except the last one
          // Only add a line break if this isn't the last field with data
          const isLastFieldWithData = index === filteredFields.length - 1 ||
            filteredFields.slice(index + 1).every(nextField => pt.data[nextField] == null);
          
          if (!isLastFieldWithData) {
            html += '<br/>';
          }
        }
      });
      
      return html;
    }
    
    // Helper to format one point's tooltip HTML specifically for polyline tooltips
    function makePolylineTooltipHTML(pt) {
      // Check for invalid coordinates (91, 181)
      if (pt.lat === 91 && pt.lng === 181) {
        return 'Invalid position data';
      }
      
      let html = '';
      
      // Start with timestamp (no label) - make it bold
      html += `<strong>${new Date(pt.timestamp).toLocaleString()}</strong><br/>`;
      
      // Add navigational status with 'Status' label if available
      if (pt.data.NavigationalStatus != null && navStatusMapping[pt.data.NavigationalStatus]) {
        html += `<strong>Status:</strong> ${navStatusMapping[pt.data.NavigationalStatus]}<br/>`;
      }
      
      // Add position
      html += `<strong>Lat:</strong> ${pt.lat.toFixed(6)}<br/>`;
      html += `<strong>Lon:</strong> ${pt.lng.toFixed(6)}<br/>`;
      
      // Add other interesting fields if available
      const fields = ['Sog', 'Cog', 'TrueHeading', 'Destination'];
      
      // Create a filtered list of fields, excluding TrueHeading if it's 511
      const filteredFields = fields.filter(field =>
        !(field === 'TrueHeading' && pt.data[field] === 511)
      );
      
      filteredFields.forEach((field, index) => {
        if (pt.data[field] != null) {
          let value = pt.data[field];
          let displayField = field;
          
          // Rename fields for display and format values
          if (field === 'TrueHeading') {
            displayField = 'Heading';
            value = `${value}°`;
          } else if (field === 'Sog') {
            displayField = 'Speed';
            value = `${value} kn`;
          } else if (field === 'Cog') {
            displayField = 'Course';
            value = `${value}°`;
          }
          
          html += `<strong>${displayField}:</strong> ${escapeHtml(value)}`;
          
          // Add line break after each field except the last one
          // Only add a line break if this isn't the last field with data
          const isLastFieldWithData = index === filteredFields.length - 1 ||
            filteredFields.slice(index + 1).every(nextField => pt.data[nextField] == null);
          
          if (!isLastFieldWithData) {
            html += '<br/>';
          }
        }
      });
      
      return html;
    }
    
    // Helper function to convert meters to nautical miles
    function metersToNauticalMiles(meters) {
      return (meters / 1852).toFixed(2); // 1 nautical mile = 1852 meters
    }
    
    // Display vessel track on map
    function displayVesselTrack(historyData) {
      if (!historyData || !historyData.length) {
        return;
      }

      // Store the current history data globally for use with time filtering
      window.currentHistoryData = historyData;

      // Clear existing layers
      mapLayerGroup.clearLayers();
      
      // Prepare points with valid coordinates
      const pts = historyData
        .filter(r => {
          const flat = flatten(r.Packet);
          return flat.Latitude != null && flat.Longitude != null &&
                 !isNaN(flat.Latitude) && !isNaN(flat.Longitude) &&
                 !(flat.Latitude === 91 && flat.Longitude === 181); // Filter out invalid coordinates
        })
        .map(r => {
          const flat = flatten(r.Packet);
          return {
            lat: flat.Latitude,
            lng: flat.Longitude,
            timestamp: r.Timestamp,
            record: r,
            data: flat
          };
        });

      if (!pts.length) {
        console.log('No valid position data found');
        return;
      }
      
      // Sort points by timestamp (newest first)
      pts.sort((a, b) => new Date(b.timestamp) - new Date(a.timestamp));
      
      // Calculate total distance between start and end points
      if (pts.length >= 2) {
        const first = pts[pts.length - 1]; // Oldest point
        const last = pts[0]; // Newest point
        
        // Calculate direct distance between first and last points
        const startPoint = L.latLng(first.lat, first.lng);
        const endPoint = L.latLng(last.lat, last.lng);
        const directDistance = startPoint.distanceTo(endPoint);
        
        // Calculate total path distance
        let pathDistance = 0;
        for (let i = 0; i < pts.length - 1; i++) {
          const pt1 = L.latLng(pts[i].lat, pts[i].lng);
          const pt2 = L.latLng(pts[i+1].lat, pts[i+1].lng);
          pathDistance += pt1.distanceTo(pt2);
        }
        
        // Update distance overlay with total path distance in nautical miles
        const distanceOverlay = document.getElementById('distance-overlay');
        if (distanceOverlay) {
          distanceOverlay.textContent = `${metersToNauticalMiles(pathDistance)} NM`;
        }
      }
      
      // Create colored track based on speed
      const coloredTrack = createColoredTrack(pts);
      coloredTrack.addTo(mapLayerGroup);
      
      // Tooltip options
      const tooltipOpts = {
        direction: 'top',
        offset: [0, -6],
        permanent: false,
        sticky: true
      };
      
      // Use the global makeTooltipHTML function
      
      // Create a layer group for temporary connection lines
      const connectionLayerGroup = L.layerGroup().addTo(map);
      
      // Add tooltips to each segment in the colored track
      coloredTrack.eachLayer(segment => {
        segment.bindTooltip('', tooltipOpts);
        
        segment.on('mousemove', e => {
          // Find the nearest point to where the mouse is
          let minDist = Infinity, nearestPoint = null;
          pts.forEach(pt => {
            const ptLatLng = L.latLng(pt.lat, pt.lng);
            const d = e.latlng.distanceTo(ptLatLng);
            if (d < minDist) {
              minDist = d;
              nearestPoint = pt;
            }
          });
          
          if (nearestPoint) {
            // Check for invalid coordinates (91, 181)
            if (nearestPoint.lat === 91 && nearestPoint.lng === 181) {
              segment.setTooltipContent('Invalid position data');
              segment.openTooltip(e.latlng);
              return;
            }
            
            // Use let instead of const for html variable to allow modification
            let html = makePolylineTooltipHTML(nearestPoint);
            
            // Check if the record has a ReceiverID
            const receiverId = nearestPoint.record.ReceiverID;
            if (receiverId && receiversData.length > 0) {
              // Find the receiver in receiversData
              const receiver = receiversData.find(r => r.id === receiverId);
              if (receiver && receiver.latitude && receiver.longitude) {
                // Calculate distance in kilometers
                const pointLatLng = L.latLng(nearestPoint.lat, nearestPoint.lng);
                const receiverLatLng = L.latLng(receiver.latitude, receiver.longitude);
                const distanceKm = (pointLatLng.distanceTo(receiverLatLng) / 1000).toFixed(2);
                
                // Add receiver info to tooltip with proper formatting
                html += `<br/><strong>RX:</strong> ${distanceKm} km`;
                
                // Clear previous connection lines
                connectionLayerGroup.clearLayers();
                
                // Draw a dashed grey line between the point and the receiver
                const connectionLine = L.polyline(
                  [[nearestPoint.lat, nearestPoint.lng], [receiver.latitude, receiver.longitude]],
                  {
                    color: 'grey',
                    weight: 2,
                    opacity: 0.7,
                    dashArray: '5, 7'
                  }
                ).addTo(connectionLayerGroup);
                
                // Find and highlight the active receiver tooltip
                document.querySelectorAll('.leaflet-tooltip').forEach(tooltip => {
                  // Remove active class from all tooltips
                  tooltip.classList.remove('receiver-tooltip-active');
                  
                  // Add active class to the matching receiver tooltip
                  if (tooltip.textContent === receiver.name) {
                    tooltip.classList.add('receiver-tooltip-active');
                  }
                });
              }
            }
            
            segment.setTooltipContent(html);
            segment.openTooltip(e.latlng);
          }
        });
        
        segment.on('mouseout', () => {
          segment.closeTooltip();
          // Clear connection lines when mouse leaves the segment
          connectionLayerGroup.clearLayers();
          
          // Remove active class from all receiver tooltips
          document.querySelectorAll('.leaflet-tooltip').forEach(tooltip => {
            tooltip.classList.remove('receiver-tooltip-active');
          });
        });
      });
      
      // Add markers at the first and last points with tooltips
      const first = pts[pts.length - 1]; // Oldest point
      const last = pts[0]; // Newest point
      
      const startMarker = L.marker([first.lat, first.lng], {
        icon: L.divIcon({
          className: 'start-marker',
          html: '🔵',
          iconSize: [20, 20],
          iconAnchor: [10, 10]
        })
      }).addTo(mapLayerGroup);
      startMarker.bindTooltip('Start: ' + new Date(first.timestamp).toLocaleString(), tooltipOpts);
      
      // Add mouseover event to start marker to show connection to receiver
      startMarker.on('mouseover', () => {
        // Clear previous connection lines
        connectionLayerGroup.clearLayers();
        
        // Check if the record has a ReceiverID
        const receiverId = first.record.ReceiverID;
        if (receiverId && receiversData.length > 0) {
          // Find the receiver in receiversData
          const receiver = receiversData.find(r => r.id === receiverId);
          if (receiver && receiver.latitude && receiver.longitude) {
            // Calculate distance in kilometers
            const pointLatLng = L.latLng(first.lat, first.lng);
            const receiverLatLng = L.latLng(receiver.latitude, receiver.longitude);
            const distanceKm = (pointLatLng.distanceTo(receiverLatLng) / 1000).toFixed(2);
            
            // Update tooltip content
            const tooltipContent = `Start: ${new Date(first.timestamp).toLocaleString()}<br/><strong>Receiver:</strong> ${receiver.name} (${distanceKm} km)`;
            startMarker.setTooltipContent(tooltipContent);
            
            // Draw a dashed grey line between the point and the receiver
            const connectionLine = L.polyline(
              [[first.lat, first.lng], [receiver.latitude, receiver.longitude]],
              {
                color: 'grey',
                weight: 2,
                opacity: 0.7,
                dashArray: '5, 7'
              }
            ).addTo(connectionLayerGroup);
          }
        }
      });
      
      startMarker.on('mouseout', () => {
        // Clear connection lines when mouse leaves the marker
        connectionLayerGroup.clearLayers();
      });
      
      const endMarker = L.marker([last.lat, last.lng], {
        icon: L.divIcon({
          className: 'end-marker',
          html: '🟣',
          iconSize: [20, 20],
          iconAnchor: [10, 10]
        })
      }).addTo(mapLayerGroup);
      endMarker.bindTooltip('End: ' + new Date(last.timestamp).toLocaleString(), tooltipOpts);
      
      // Add mouseover event to end marker to show connection to receiver
      endMarker.on('mouseover', () => {
        // Clear previous connection lines
        connectionLayerGroup.clearLayers();
        
        // Check if the record has a ReceiverID
        const receiverId = last.record.ReceiverID;
        if (receiverId && receiversData.length > 0) {
          // Find the receiver in receiversData
          const receiver = receiversData.find(r => r.id === receiverId);
          if (receiver && receiver.latitude && receiver.longitude) {
            // Calculate distance in kilometers
            const pointLatLng = L.latLng(last.lat, last.lng);
            const receiverLatLng = L.latLng(receiver.latitude, receiver.longitude);
            const distanceKm = (pointLatLng.distanceTo(receiverLatLng) / 1000).toFixed(2);
            
            // Update tooltip content
            const tooltipContent = `End: ${new Date(last.timestamp).toLocaleString()}<br/><strong>Receiver:</strong> ${receiver.name} (${distanceKm} km)`;
            endMarker.setTooltipContent(tooltipContent);
            
            // Draw a dashed grey line between the point and the receiver
            const connectionLine = L.polyline(
              [[last.lat, last.lng], [receiver.latitude, receiver.longitude]],
              {
                color: 'grey',
                weight: 2,
                opacity: 0.7,
                dashArray: '5, 7'
              }
            ).addTo(connectionLayerGroup);
          }
        }
      });
      
      endMarker.on('mouseout', () => {
        // Clear connection lines when mouse leaves the marker
        connectionLayerGroup.clearLayers();
      });
      
      // Add receiver markers for receivers that heard this vessel
      // Get the vessel data to find which receivers heard it
      fetch(`/state?UserID=${userID}`, { cache: 'no-store' })
        .then(response => response.json())
        .then(data => {
          if (data.ReceiverIDs && Array.isArray(data.ReceiverIDs) && data.ReceiverIDs.length > 0) {
            // Filter receivers to only those that heard this vessel
            const relevantReceivers = receiversData.filter(receiver =>
              data.ReceiverIDs.includes(receiver.id)
            );
            
            // Add a marker for each receiver
            relevantReceivers.forEach(receiver => {
              if (receiver.latitude && receiver.longitude) {
                // Create a red circle marker for the receiver
                const receiverMarker = L.circleMarker([receiver.latitude, receiver.longitude], {
                  radius: 6,
                  color: 'red',
                  fillColor: '#f03',
                  fillOpacity: 0.8,
                  weight: 2
                }).addTo(mapLayerGroup);
                
                // Add a permanent tooltip with the receiver name
                receiverMarker.bindTooltip(receiver.name, {
                  permanent: true,
                  direction: 'top',
                  offset: [0, -10],
                  className: 'receiver-tooltip'
                }).openTooltip();
              }
            });
          }
        })
        .catch(err => {
          console.error('Error fetching vessel data for receiver markers:', err);
        });
      
      // Fit map to vessel track data only (not including receivers)
      const latlngs = pts.map(p => [p.lat, p.lng]);
      map.fitBounds(L.latLngBounds(latlngs).pad(0.2));
    }

    // Function to show packet details in overlay
    function showPacketDetails(event) {
      const timestamp = event.currentTarget.dataset.timestamp;
      const record = JSON.parse(event.currentTarget.dataset.record);
      
      // Get the overlay elements
      const overlay = document.getElementById('packet-overlay');
      const jsonContainer = document.getElementById('packet-json');
      const rawSentence = document.getElementById('raw-sentence');
      const receiverInfo = document.getElementById('receiver-info');
      
      // Clear previous content
      jsonContainer.innerHTML = '';
      rawSentence.textContent = '';
      receiverInfo.innerHTML = '';
      
      // Create a table for the packet JSON
      const table = document.createElement('table');
      
      // Create table header
      const thead = document.createElement('thead');
      const headerRow = document.createElement('tr');
      const keyHeader = document.createElement('th');
      keyHeader.textContent = 'Field';
      const valueHeader = document.createElement('th');
      valueHeader.textContent = 'Value';
      headerRow.appendChild(keyHeader);
      headerRow.appendChild(valueHeader);
      thead.appendChild(headerRow);
      table.appendChild(thead);
      
      // Create table body
      const tbody = document.createElement('tbody');
      
      // Flatten the packet for display
      const flatPacket = flatten(record.Packet);
      
      // Add rows for each field in the packet
      Object.entries(flatPacket).forEach(([key, value]) => {
        const row = document.createElement('tr');
        const keyCell = document.createElement('td');
        keyCell.textContent = key;
        const valueCell = document.createElement('td');
        valueCell.textContent = escapeHtml(value);
        row.appendChild(keyCell);
        row.appendChild(valueCell);
        tbody.appendChild(row);
      });
      
      table.appendChild(tbody);
      jsonContainer.appendChild(table);
      
      // Set the raw sentence if available
      if (record.RawSentence) {
        rawSentence.textContent = record.RawSentence;
      } else {
        rawSentence.textContent = 'No raw sentence available';
      }
      
      // Set receiver information if available
      if (record.ReceiverID && receiversData.length > 0) {
        const receiver = receiversData.find(r => r.id === record.ReceiverID);
        if (receiver) {
          receiverInfo.innerHTML = `<strong>Receiver:</strong> ${receiver.name}`;
        } else {
          receiverInfo.innerHTML = `<strong>Receiver ID:</strong> ${record.ReceiverID} (Name not found)`;
        }
      } else {
        receiverInfo.innerHTML = 'No receiver information available';
      }
      
      // Show the overlay
      overlay.classList.add('active');
    }
    
    // Track changes in destination and navigational status
    function trackChanges(historyData) {
      if (!historyData || !historyData.length) {
        return;
      }
      
      // Sort by timestamp (oldest first)
      const sortedData = [...historyData].sort((a, b) =>
        new Date(a.Timestamp) - new Date(b.Timestamp)
      );
      
      const destinationChanges = [];
      const statusChanges = [];
      
      let lastDestination = null;
      let lastStatus = null;
      let firstRecord = null;
      let firstStaticRecord = null;
      let firstPositionRecord = null;
      
      // Find the first record with static data (containing Destination field)
      // and the first record with position data (containing NavigationalStatus field)
      for (const record of sortedData) {
        const flat = flatten(record.Packet);
        
        // Store the first record for general use
        if (!firstRecord) {
          firstRecord = record;
        }
        
        // Find the first record with Destination field (static message)
        if (!firstStaticRecord && flat.Destination !== undefined) {
          firstStaticRecord = record;
        }
        
        // Find the first record with NavigationalStatus field (position message)
        if (!firstPositionRecord &&
            (record.MessageID === 1 || record.MessageID === 2 || record.MessageID === 3 ||
             record.MessageID === 18 || record.MessageID === 19) &&
            record.Packet && record.Packet.NavigationalStatus !== undefined) {
          firstPositionRecord = record;
          console.log('Found position record with NavigationalStatus:', record);
        }
        
        // If we found both types of records, we can break early
        if (firstStaticRecord && firstPositionRecord) {
          break;
        }
      }
      
      // If we didn't find a record with Destination, use the first record
      if (!firstStaticRecord && sortedData.length > 0) {
        firstStaticRecord = firstRecord;
      }
      
      // If we didn't find a position record, use the first record
      if (!firstPositionRecord && sortedData.length > 0) {
        firstPositionRecord = firstRecord;
      }
      
      sortedData.forEach(record => {
        const flat = flatten(record.Packet);
        const timestamp = record.Timestamp;
        
        // Track destination changes
        if (flat.Destination !== undefined) {
          const currentDestination = flat.Destination || '';
          if (lastDestination !== null && currentDestination !== lastDestination) {
            // Include ETA if available
            let etaStr = '';
            // Access ETA directly from the original packet, not the flattened structure
            if (record.Packet && record.Packet.Eta) {
              etaStr = formatEta(record.Packet.Eta);
            }
            
            destinationChanges.push({
              timestamp,
              from: lastDestination,
              to: currentDestination,
              eta: etaStr,
              record: record
            });
          }
          lastDestination = currentDestination;
        }
        
        // Track navigational status changes
        if (flat.NavigationalStatus !== undefined) {
          const currentStatus = flat.NavigationalStatus;
          if (lastStatus !== null && currentStatus !== lastStatus) {
            statusChanges.push({
              timestamp,
              from: lastStatus,
              to: currentStatus,
              record: record
            });
          }
          lastStatus = currentStatus;
        }
      });
      
      // Display destination changes
      const destTable = document.querySelector('#destination-changes tbody');
      destTable.innerHTML = '';
      
      if (destinationChanges.length > 0) {
        // Sort by timestamp (newest first)
        destinationChanges.sort((a, b) => new Date(b.timestamp) - new Date(a.timestamp));
        
        destinationChanges.forEach(change => {
          const row = document.createElement('tr');
          
          const timeCell = document.createElement('td');
          const timeText = new Date(change.timestamp).toLocaleString();
          timeCell.textContent = timeText;
          timeCell.style.cursor = 'pointer';
          timeCell.style.color = '#0066cc';
          timeCell.style.textDecoration = 'underline';
          timeCell.dataset.timestamp = change.timestamp;
          timeCell.dataset.record = JSON.stringify(change.record);
          timeCell.addEventListener('click', showPacketDetails);
          row.appendChild(timeCell);
          
          const fromCell = document.createElement('td');
          fromCell.textContent = change.from || '(empty)';
          row.appendChild(fromCell);
          
          const toCell = document.createElement('td');
          toCell.textContent = change.to || '(empty)';
          row.appendChild(toCell);
          
          // Add ETA cell
          const etaCell = document.createElement('td');
          etaCell.textContent = change.eta || '';
          row.appendChild(etaCell);
          
          destTable.appendChild(row);
        });
      } else if (firstStaticRecord) {
        // If no changes but we have static data, show the current value
        const flat = flatten(firstStaticRecord.Packet);
        if (flat.Destination !== undefined) {
          const row = document.createElement('tr');
          
          const timeCell = document.createElement('td');
          const timeText = new Date(firstStaticRecord.Timestamp).toLocaleString();
          timeCell.textContent = timeText;
          timeCell.style.cursor = 'pointer';
          timeCell.style.color = '#0066cc';
          timeCell.style.textDecoration = 'underline';
          timeCell.dataset.timestamp = firstStaticRecord.Timestamp;
          timeCell.dataset.record = JSON.stringify(firstStaticRecord);
          timeCell.addEventListener('click', showPacketDetails);
          row.appendChild(timeCell);
          
          const fromCell = document.createElement('td');
          fromCell.textContent = '';
          row.appendChild(fromCell);
          
          const toCell = document.createElement('td');
          toCell.textContent = flat.Destination || '(empty)';
          row.appendChild(toCell);
          
          // Add ETA cell
          const etaCell = document.createElement('td');
          // Access ETA directly from the original packet, not the flattened structure
          if (firstStaticRecord.Packet && firstStaticRecord.Packet.Eta) {
            etaCell.textContent = formatEta(firstStaticRecord.Packet.Eta);
          }
          row.appendChild(etaCell);
          
          destTable.appendChild(row);
        } else {
          const row = document.createElement('tr');
          const cell = document.createElement('td');
          cell.colSpan = 4;
          cell.className = 'no-changes';
          cell.textContent = 'No destination information available';
          row.appendChild(cell);
          destTable.appendChild(row);
        }
      } else {
        const row = document.createElement('tr');
        const cell = document.createElement('td');
        cell.colSpan = 4;
        cell.className = 'no-changes';
        cell.textContent = 'No destination changes detected';
        row.appendChild(cell);
        destTable.appendChild(row);
      }
      
      // Display navigational status changes
      const statusTable = document.querySelector('#status-changes tbody');
      statusTable.innerHTML = '';
      
      if (statusChanges.length > 0) {
        // Sort by timestamp (newest first)
        statusChanges.sort((a, b) => new Date(b.timestamp) - new Date(a.timestamp));
        
        statusChanges.forEach(change => {
          const row = document.createElement('tr');
          
          const timeCell = document.createElement('td');
          const timeText = new Date(change.timestamp).toLocaleString();
          timeCell.textContent = timeText;
          timeCell.style.cursor = 'pointer';
          timeCell.style.color = '#0066cc';
          timeCell.style.textDecoration = 'underline';
          timeCell.dataset.timestamp = change.timestamp;
          timeCell.dataset.record = JSON.stringify(change.record);
          timeCell.addEventListener('click', showPacketDetails);
          row.appendChild(timeCell);
          
          const fromCell = document.createElement('td');
          fromCell.textContent = navStatusMapping[change.from] || change.from || '(unknown)';
          row.appendChild(fromCell);
          
          const toCell = document.createElement('td');
          toCell.textContent = navStatusMapping[change.to] || change.to || '(unknown)';
          row.appendChild(toCell);
          
          statusTable.appendChild(row);
        });
      } else if (firstPositionRecord && firstPositionRecord.Packet.NavigationalStatus !== undefined) {
        // If no changes but we have position data with NavigationalStatus, show the current value
        const row = document.createElement('tr');
        
        const timeCell = document.createElement('td');
        const timeText = new Date(firstPositionRecord.Timestamp).toLocaleString();
        timeCell.textContent = timeText;
        timeCell.style.cursor = 'pointer';
        timeCell.style.color = '#0066cc';
        timeCell.style.textDecoration = 'underline';
        timeCell.dataset.timestamp = firstPositionRecord.Timestamp;
        timeCell.dataset.record = JSON.stringify(firstPositionRecord);
        timeCell.addEventListener('click', showPacketDetails);
        row.appendChild(timeCell);
        
        const fromCell = document.createElement('td');
        fromCell.textContent = '';
        row.appendChild(fromCell);
        
        const toCell = document.createElement('td');
        
        // Get NavigationalStatus directly from the position record
        const navStatus = firstPositionRecord.Packet.NavigationalStatus;
        
        // Convert the status code to a readable string
        if (navStatus === 0) {
          // Special case for 0, which is "Using Engine"
          toCell.textContent = navStatusMapping[0] || "Using Engine";
        } else {
          toCell.textContent = navStatusMapping[navStatus] || `${navStatus}`;
        }
        row.appendChild(toCell);
        
        statusTable.appendChild(row);
      } else {
        const row = document.createElement('tr');
        const cell = document.createElement('td');
        cell.colSpan = 3;
        cell.className = 'no-changes';
        cell.textContent = 'No navigational status changes detected';
        row.appendChild(cell);
        statusTable.appendChild(row);
      }
    }

    // Format ETA from object to readable string
    function formatEta(eta) {
      if (!eta || typeof eta !== 'object') return '';
      
      const { Day, Month, Hour, Minute } = eta;
      if (Day === undefined || Month === undefined) return '';
      
      // Month is 1-based in the data
      const monthNames = [
        'January', 'February', 'March', 'April', 'May', 'June',
        'July', 'August', 'September', 'October', 'November', 'December'
      ];
      
      const monthName = monthNames[Month - 1] || '';
      let timeStr = '';
      
      if (Hour !== undefined && Minute !== undefined) {
        // Pad with leading zeros if needed
        const hourStr = Hour.toString().padStart(2, '0');
        const minStr = Minute.toString().padStart(2, '0');
        timeStr = ` ${hourStr}:${minStr}`;
      }
      
      return `${Day} ${monthName}${timeStr}`;
    }

    // Helper function to escape HTML special characters
    function escapeHtml(unsafe) {
      if (unsafe === null || unsafe === undefined) return '';
      return String(unsafe)
        .replace(/&/g, "&amp;")
        .replace(/</g, "&lt;")
        .replace(/>/g, "&gt;")
        .replace(/"/g, "&quot;")
        .replace(/'/g, "&#039;");
    }
    
    // Helper function to flatten nested objects
    function flatten(obj, prefix = '', res = {}) {
      for (const [k, v] of Object.entries(obj || {})) {
        const key = prefix ? `${prefix}.${k}` : k;
        if (v != null && typeof v === 'object' && !Array.isArray(v)) {
          flatten(v, key, res);
        } else {
          res[key] = v;
        }
      }
      return res;
    }

    // Store vessel AIS class globally
    let vesselAisClass = '';

    // Initialize the page
    document.addEventListener('DOMContentLoaded', () => {
      initDateSelectors();
      initMap();
      
      // Fetch receivers data and ensure loadVesselData is called after
      // to properly update the dropdown based on ReceiverIDs
      fetchReceiversData();
      
      // Make sure vessel data is loaded again to properly update the receiver dropdown
      // This ensures that if ReceiverIDs is empty, only the "All" option is shown
      loadVesselData();
      
      // Add event listeners to date inputs to clear warning when user changes dates
      document.getElementById('start').addEventListener('change', () => {
        if (dateRangeAdjusted) {
          dateRangeAdjusted = false;
          document.getElementById('error').textContent = '';
        }
      });
      
      document.getElementById('end').addEventListener('change', () => {
        if (dateRangeAdjusted) {
          dateRangeAdjusted = false;
          document.getElementById('error').textContent = '';
        }
      });
      
      // Automatically load history data with default 1-day range
      setTimeout(async () => {
        console.log('Checking if date range needs adjustment, lastSeenTime =', lastSeenTime);
        // Check if we need to adjust the date range based on last seen time
        if (lastSeenTime) {
          const startInput = document.getElementById('start');
          const endInput = document.getElementById('end');
          const startDate = new Date(startInput.value);
          const endDate = new Date(endInput.value);
          
          // If the start date is after or too close to the last seen time,
          // adjust the date range to 24 hours before the last seen time
          if (startDate >= lastSeenTime) {
            console.log('Selected dates are too recent compared to last seen time. Adjusting...');
            
            // Set end date to last seen time plus 1 hour leeway
            const adjustedEndDate = new Date(lastSeenTime);
            adjustedEndDate.setHours(adjustedEndDate.getHours() + 1);
            
            // Set start date to 23 hours before last seen time (for a 24-hour window with 1 hour leeway)
            const adjustedStartDate = new Date(lastSeenTime);
            adjustedStartDate.setHours(adjustedStartDate.getHours() - 23);
            
            // Format dates for the datetime-local inputs
            function formatDateForInput(date) {
              const year = date.getFullYear();
              const month = String(date.getMonth() + 1).padStart(2, '0');
              const day = String(date.getDate()).padStart(2, '0');
              const hours = String(date.getHours()).padStart(2, '0');
              const minutes = String(date.getMinutes()).padStart(2, '0');
              return `${year}-${month}-${day}T${hours}:${minutes}`;
            }
            
            // Update the input fields
            startInput.value = formatDateForInput(adjustedStartDate);
            endInput.value = formatDateForInput(adjustedEndDate);
            
            // Update URL with adjusted date range
            const url = new URL(window.location.href);
            url.searchParams.set('start', adjustedStartDate.toISOString());
            url.searchParams.set('end', adjustedEndDate.toISOString());
            window.history.replaceState({}, '', url);
            
            console.log('Date range adjusted to:', adjustedStartDate, 'to', adjustedEndDate);
            
            // Set flag that date range was adjusted and display warning message
            dateRangeAdjusted = true;
            const warningDiv = document.getElementById('error');
            warningDiv.textContent = 'Warning: Start date was too recent - automatically updated to a 24-hour window before the vessel\'s last seen time.';
            warningDiv.style.display = 'block';
            console.log('Warning message set:', warningDiv.textContent);
            
            // Force the warning to be visible
            setTimeout(() => {
              if (dateRangeAdjusted) {
                const warningDiv = document.getElementById('error');
                if (!warningDiv.textContent) {
                  warningDiv.textContent = 'Warning: Automatically updated to a 24-hour window around the vessel\'s last seen time.';
                  warningDiv.style.display = 'block';
                  console.log('Warning message re-set after timeout');
                }
              }
            }, 500);
            
            // Instead of triggering the search button click, call fetchVesselHistory directly
            // to avoid clearing the warning message in the apply-btn click handler
            setTimeout(async () => {
              console.log('Fetching vessel history with dateRangeAdjusted =', dateRangeAdjusted);
              const historyData = await fetchVesselHistory();
              if (historyData) {
                displayVesselTrack(historyData);
                displayMessageHistogram(historyData);
                trackChanges(historyData);
                
                // Check if warning is still visible after processing
                console.log('After processing, warning text =', document.getElementById('error').textContent);
                console.log('After processing, dateRangeAdjusted =', dateRangeAdjusted);
                
                // Force the warning to be visible again if needed
                if (dateRangeAdjusted && !document.getElementById('error').textContent) {
                  const warningDiv = document.getElementById('error');
                  warningDiv.textContent = 'Warning: Start date was too recent - automatically updated to a 24-hour window before the vessel\'s last seen time.';
                  warningDiv.style.display = 'block';
                  console.log('Warning message re-set after processing');
                }
              }
            }, 100);
            return; // Exit early as the click handler will fetch the data
          }
        }
        
        // If no adjustment was needed, fetch history data normally
        const historyData = await fetchVesselHistory();
        if (historyData) {
          // Store the original history data
          window.originalHistoryData = historyData;
          window.currentHistoryData = historyData;
          
          displayVesselTrack(historyData);
          displayMessageHistogram(historyData);
          trackChanges(historyData);
          
          // Check for filter parameters in URL and restore if present
          checkForTimeFilterInUrl(historyData);
        }
      }, 1000); // Small delay to ensure vessel data is loaded first
      
      // Set up event listeners
      document.getElementById('copy-link-btn').addEventListener('click', async () => {
        const currentUrl = window.location.href;
        
        try {
          // Try to use the modern Clipboard API first
          if (navigator.clipboard && navigator.clipboard.writeText) {
            await navigator.clipboard.writeText(currentUrl);
          } else {
            // Fall back to the older method for browsers that don't support Clipboard API
            const tempInput = document.createElement('input');
            tempInput.value = currentUrl;
            document.body.appendChild(tempInput);
            tempInput.select();
            tempInput.setSelectionRange(0, 99999); // For mobile devices
            document.execCommand('copy');
            document.body.removeChild(tempInput);
          }
          
          // Visual feedback
          const btn = document.getElementById('copy-link-btn');
          const originalText = btn.innerHTML;
          btn.innerHTML = `
            <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" class="bi bi-check-lg" viewBox="0 0 16 16">
              <path d="M12.736 3.97a.733.733 0 0 1 1.047 0c.286.289.29.756.01 1.05L7.88 12.01a.733.733 0 0 1-1.065.02L3.217 8.384a.757.757 0 0 1 0-1.06.733.733 0 0 1 1.047 0l3.052 3.093 5.4-6.425a.247.247 0 0 1 .02-.022Z"/>
            </svg>
            Copied!
          `;
          
          // Reset button text after 2 seconds
          setTimeout(() => {
            btn.innerHTML = originalText;
          }, 2000);
        } catch (err) {
          console.error('Failed to copy URL to clipboard:', err);
        }
      });
      
      // Image overlay functionality
      const vesselImg = document.getElementById('vessel-img');
      const imageOverlay = document.getElementById('image-overlay');
      const overlayImg = document.getElementById('overlay-img');
      const closeOverlay = document.querySelector('#image-overlay .close-overlay');
      
      // Open overlay when clicking on vessel image
      vesselImg.addEventListener('click', () => {
        if (vesselImg.src) {
          overlayImg.src = vesselImg.src;
          imageOverlay.classList.add('active');
        }
      });
      
      // Close overlay when clicking on X button
      closeOverlay.addEventListener('click', () => {
        imageOverlay.classList.remove('active');
      });
      
      // Close overlay when clicking outside the image
      imageOverlay.addEventListener('click', (e) => {
        if (e.target === imageOverlay) {
          imageOverlay.classList.remove('active');
        }
      });
      
      // Setup packet overlay close functionality
      document.querySelector('#packet-overlay .close-overlay').addEventListener('click', () => {
        document.getElementById('packet-overlay').classList.remove('active');
      });
      
      // Close packet overlay when clicking outside the content
      document.getElementById('packet-overlay').addEventListener('click', (e) => {
        if (e.target === document.getElementById('packet-overlay')) {
          document.getElementById('packet-overlay').classList.remove('active');
        }
      });
      
      document.getElementById('receiver-select').addEventListener('change', async () => {
        const historyData = await fetchVesselHistory();
        if (historyData) {
          displayVesselTrack(historyData);
          displayMessageHistogram(historyData);
          trackChanges(historyData);
        }
      });
      
      document.getElementById('apply-btn').addEventListener('click', async () => {
        // Only clear the warning message if this is a manual search (not an automatic one)
        if (!dateRangeAdjusted) {
          document.getElementById('error').textContent = '';
        }
        
        // Update URL with current date range
        const startInput = document.getElementById('start');
        const endInput = document.getElementById('end');
        
        if (startInput.value && endInput.value) {
          // Create a new URL object based on the current URL
          const url = new URL(window.location.href);
          
          // Update or add the start and end parameters
          // Use the input values directly to preserve the exact selected time without timezone conversion
          const startDate = new Date(startInput.value);
          const endDate = new Date(endInput.value);
          
          // Format dates in a way that preserves the local time information
          url.searchParams.set('start', startDate.toISOString());
          url.searchParams.set('end', endDate.toISOString());
          
          // Add receiver ID to URL if selected
          const receiverSelect = document.getElementById('receiver-select');
          if (receiverSelect.value) {
            url.searchParams.set('ReceiverID', receiverSelect.value);
          } else {
            url.searchParams.delete('ReceiverID');
          }
          
          // Update the browser history without reloading the page
          window.history.replaceState({}, '', url);
        }
        
        const historyData = await fetchVesselHistory();
        if (historyData) {
          displayVesselTrack(historyData);
          displayMessageHistogram(historyData);
          trackChanges(historyData);
        }
      });
      
      document.getElementById('reset-btn').addEventListener('click', () => {
        // Reset the date range adjusted flag
        dateRangeAdjusted = false;
        
        initDateSelectors();
        
        // Clear map
        if (mapLayerGroup) {
          mapLayerGroup.clearLayers();
        }
        
        // Clear histogram
        document.getElementById('message-histogram').innerHTML = '';
        
        // Clear tables
        document.querySelector('#destination-changes tbody').innerHTML = '';
        document.querySelector('#status-changes tbody').innerHTML = '';
        
        // Clear data info and disable download button
        document.getElementById('data-info').textContent = '';
        document.getElementById('download-csv-btn').disabled = true;
        
        // Clear any warning messages
        document.getElementById('error').textContent = '';
      });
      
      // Add event listener for Download CSV button
      document.getElementById('download-csv-btn').addEventListener('click', () => {
        if (!window.positionData || window.positionData.length === 0) {
          alert('No position data available to download.');
          return;
        }
        
        // Convert position data to CSV
        const csvContent = convertPositionDataToCsv(window.positionData);
        
        // Create a blob and download link
        const blob = new Blob([csvContent], { type: 'text/csv;charset=utf-8;' });
        const url = URL.createObjectURL(blob);
        
        // Create a temporary link and trigger download
        const link = document.createElement('a');
        link.href = url;
        link.setAttribute('download', `vessel_${userID}_positions.csv`);
        document.body.appendChild(link);
        link.click();
        
        // Clean up
        document.body.removeChild(link);
        URL.revokeObjectURL(url);
      });
    });
    
    // Function to convert position data to CSV
    function convertPositionDataToCsv(positionData) {
      if (!positionData || positionData.length === 0) {
        return '';
      }
      
      // Define CSV headers
      const headers = [
        'Timestamp',
        'Latitude',
        'Longitude',
        'Speed (knots)',
        'Course',
        'Heading',
        'NavigationalStatus',
        'ReceiverID',
        'MessageID'
      ];
      
      // Create CSV content with headers
      let csvContent = headers.join(',') + '\n';
      
      // Add data rows
      positionData.forEach(record => {
        const flat = flatten(record.Packet);
        
        // Extract values, handling missing data
        const timestamp = record.Timestamp || '';
        const latitude = flat.Latitude !== undefined ? flat.Latitude : '';
        const longitude = flat.Longitude !== undefined ? flat.Longitude : '';
        const speed = flat.Sog !== undefined ? flat.Sog : '';
        const course = flat.Cog !== undefined ? flat.Cog : '';
        const heading = flat.TrueHeading !== undefined && flat.TrueHeading !== 511 ? flat.TrueHeading : '';
        const navStatus = flat.NavigationalStatus !== undefined ? flat.NavigationalStatus : '';
        const receiverId = record.ReceiverID || '';
        const messageId = record.MessageID || '';
        
        // Create CSV row with proper escaping
        const row = [
          `"${timestamp}"`,
          latitude,
          longitude,
          speed,
          course,
          heading,
          navStatus,
          `"${receiverId}"`,
          messageId
        ].join(',');
        
        csvContent += row + '\n';
      });
      
      return csvContent;
    }

    // Store vessel AIS class globally - moved to loadVesselData function
    
    // Store the current time filter globally
    let timeFilter = {
      active: false,
      startTime: null,
      endTime: null
    };
    
    // Function to display message histogram
    function displayMessageHistogram(historyData) {
      if (!historyData || !historyData.length) {
        return;
      }
      
      const histogramContainer = document.getElementById('message-histogram');
      histogramContainer.innerHTML = '';
      
      // Filter for position messages only
      const positionMessageTypes = ['1', '2', '3', '18', '19'];
      const positionMessages = historyData.filter(msg =>
        positionMessageTypes.includes(msg.MessageID.toString())
      );
      
      if (positionMessages.length === 0) {
        histogramContainer.innerHTML = '<div style="padding: 10px; text-align: center; color: #666;">No position messages available</div>';
        return;
      }
      
      // Sort messages by timestamp (oldest first)
      positionMessages.sort((a, b) => new Date(a.Timestamp) - new Date(b.Timestamp));
      
      // Get time range
      const startTime = new Date(positionMessages[0].Timestamp);
      const endTime = new Date(positionMessages[positionMessages.length - 1].Timestamp);
      const totalDuration = endTime - startTime;
      
      // Target number of bins based on duration
      let targetBins, binLabel;
      if (totalDuration <= 3600000) { // 1 hour or less
        targetBins = 60; // ~1 minute bins for 1 hour
        binLabel = 'interval';
      } else if (totalDuration <= 86400000) { // 1 day or less
        targetBins = 96; // ~15 minute bins for 1 day
        binLabel = 'interval';
      } else {
        targetBins = 100; // ~43 minute bins for 3 days
        binLabel = 'interval';
      }
      
      // Calculate bin size based on target number of bins
      const binSize = Math.max(60000, Math.ceil(totalDuration / targetBins)); // Minimum 1 minute
      
      // Create bins
      const bins = {};
      const numBins = Math.ceil(totalDuration / binSize);
      
      // Initialize bins
      for (let i = 0; i < numBins; i++) {
        const binTime = new Date(startTime.getTime() + (i * binSize));
        bins[i] = {
          count: 0,
          startTime: binTime,
          endTime: new Date(binTime.getTime() + binSize)
        };
      }
      
      // Count messages in each bin
      positionMessages.forEach(msg => {
        const msgTime = new Date(msg.Timestamp);
        const binIndex = Math.floor((msgTime - startTime) / binSize);
        if (bins[binIndex]) {
          bins[binIndex].count++;
        }
      });
      
      // Find maximum count for scaling
      const maxCount = Math.max(...Object.values(bins).map(bin => bin.count));
      
      // Create SVG for histogram
      const svgNS = "http://www.w3.org/2000/svg";
      const svg = document.createElementNS(svgNS, "svg");
      svg.setAttribute("width", "100%");
      svg.setAttribute("height", "100%");
      
      // Calculate bar width based on number of bins
      const barWidth = 100 / numBins;
      
      // Create bars
      Object.values(bins).forEach((bin, index) => {
        const barHeight = bin.count > 0 ? (bin.count / maxCount) * 100 : 0;
        const bar = document.createElementNS(svgNS, "rect");
        
        // Position and size - ensure bars start from bottom (100%) and go up
        bar.setAttribute("x", `${index * barWidth}%`);
        bar.setAttribute("y", `${100 - barHeight}%`);
        bar.setAttribute("width", `${barWidth - 0.1}%`);
        bar.setAttribute("height", `${barHeight}%`);
        
        // Styling - blue scale based on count intensity
        const ratio = bin.count / maxCount;
        // Use a blue scale from light blue (low counts) to dark blue (high counts)
        const lightness = 80 - (ratio * 60); // 80% lightness (light blue) to 20% lightness (dark blue)
        bar.setAttribute("fill", `hsl(210, 100%, ${lightness}%)`);
        
        // Tooltip
        const title = document.createElementNS(svgNS, "title");
        
        // Format start date/time
        const formattedStart = bin.startTime.toLocaleString([], {
          day: 'numeric',
          month: 'short',
          hour: '2-digit',
          minute: '2-digit'
        });
        
        // Format end date/time
        const formattedEnd = bin.endTime.toLocaleString([], {
          day: 'numeric',
          month: 'short',
          hour: '2-digit',
          minute: '2-digit'
        });
        
        title.textContent = `${bin.count} position reports ${formattedStart} - ${formattedEnd}`;
        bar.appendChild(title);
        
        svg.appendChild(bar);
      });
      
      histogramContainer.appendChild(svg);
      
      // Store the time range data for selection functionality
      histogramContainer.dataset.startTime = startTime.toISOString();
      histogramContainer.dataset.endTime = endTime.toISOString();
      histogramContainer.dataset.numBins = numBins;
      
      // Add selection functionality
      setupHistogramSelection(histogramContainer, startTime, endTime, historyData);
    }
    
    // Setup selection functionality for the histogram
    function setupHistogramSelection(container, startTime, endTime, historyData) {
      // Remove any existing selection window
      const existingSelection = container.querySelector('.selection-window');
      if (existingSelection) {
        container.removeChild(existingSelection);
      }
      
      // Create selection window if there's an active filter
      if (timeFilter.active) {
        createSelectionWindow(container, startTime, endTime);
      }
      
      // Add click handler to create a new selection
      container.addEventListener('mousedown', function(e) {
        // Ignore if clicking on a handle
        if (e.target.classList.contains('selection-handle')) {
          return;
        }
        
        // Double click to remove selection
        if (e.detail === 2) {
          removeSelectionWindow();
          return;
        }
        
        // Remove any existing selection window first to ensure only one at a time
        removeSelectionWindow();
        
        // Calculate position as percentage
        const rect = container.getBoundingClientRect();
        const x = e.clientX - rect.left;
        const percentage = (x / rect.width) * 100;
        
        // Calculate time at click position
        const timeRange = endTime - startTime;
        const clickTime = new Date(startTime.getTime() + (timeRange * percentage / 100));
        
        // Create a small initial selection window (10% width)
        const halfWidth = 5; // 5% on each side
        const selectionStartTime = new Date(clickTime.getTime() - (timeRange * halfWidth / 100));
        const selectionEndTime = new Date(clickTime.getTime() + (timeRange * halfWidth / 100));
        
        // Set the time filter
        timeFilter = {
          active: true,
          startTime: selectionStartTime,
          endTime: selectionEndTime
        };
        
        // Create the selection window
        createSelectionWindow(container, startTime, endTime);
        
        // Apply the filter to the map
        applyTimeFilter(historyData);
        
        // Update URL with filter window parameters
        updateUrlWithTimeFilter();
      });
    }
    
    // Create a selection window based on the current time filter
    function createSelectionWindow(container, startTime, endTime) {
      if (!timeFilter.active) return;
      
      const totalDuration = endTime - startTime;
      
      // Calculate positions as percentages
      const startPercentage = ((timeFilter.startTime - startTime) / totalDuration) * 100;
      const endPercentage = ((timeFilter.endTime - startTime) / totalDuration) * 100;
      
      // Create selection window element
      const selectionWindow = document.createElement('div');
      selectionWindow.className = 'selection-window';
      selectionWindow.style.left = `${startPercentage}%`;
      selectionWindow.style.width = `${endPercentage - startPercentage}%`;
      
      // Create left handle
      const leftHandle = document.createElement('div');
      leftHandle.className = 'selection-handle selection-handle-left';
      selectionWindow.appendChild(leftHandle);
      
      // Create right handle
      const rightHandle = document.createElement('div');
      rightHandle.className = 'selection-handle selection-handle-right';
      selectionWindow.appendChild(rightHandle);
      
      // Create info label
      const infoLabel = document.createElement('div');
      infoLabel.className = 'selection-info';
      infoLabel.textContent = formatTimeRange(timeFilter.startTime, timeFilter.endTime);
      selectionWindow.appendChild(infoLabel);
      
      // Add to container
      container.appendChild(selectionWindow);
      
      // Setup drag handlers for the handles
      setupDragHandlers(container, leftHandle, rightHandle, startTime, endTime);
    }
    
    // Format a time range for display
    function formatTimeRange(start, end) {
      const formatOptions = {
        month: 'short',
        day: 'numeric',
        hour: '2-digit',
        minute: '2-digit'
      };
      return `${start.toLocaleString([], formatOptions)} - ${end.toLocaleString([], formatOptions)}`;
    }
    
    // Setup drag handlers for the selection window handles
    function setupDragHandlers(container, leftHandle, rightHandle, startTime, endTime) {
      const totalDuration = endTime - startTime;
      let isDragging = false;
      let currentHandle = null;
      
      // Function to handle mouse move during drag
      function handleDrag(e) {
        if (!isDragging || !currentHandle) return;
        
        const rect = container.getBoundingClientRect();
        const x = Math.max(0, Math.min(e.clientX - rect.left, rect.width));
        const percentage = (x / rect.width) * 100;
        
        // Calculate time at drag position
        const dragTime = new Date(startTime.getTime() + (totalDuration * percentage / 100));
        
        const selectionWindow = container.querySelector('.selection-window');
        const infoLabel = selectionWindow.querySelector('.selection-info');
        
        if (currentHandle.classList.contains('selection-handle-left')) {
          // Update left handle position
          if (dragTime < timeFilter.endTime) {
            timeFilter.startTime = dragTime;
            const startPercentage = ((timeFilter.startTime - startTime) / totalDuration) * 100;
            const endPercentage = ((timeFilter.endTime - startTime) / totalDuration) * 100;
            selectionWindow.style.left = `${startPercentage}%`;
            selectionWindow.style.width = `${endPercentage - startPercentage}%`;
          }
        } else {
          // Update right handle position
          if (dragTime > timeFilter.startTime) {
            timeFilter.endTime = dragTime;
            const startPercentage = ((timeFilter.startTime - startTime) / totalDuration) * 100;
            const endPercentage = ((timeFilter.endTime - startTime) / totalDuration) * 100;
            selectionWindow.style.width = `${endPercentage - startPercentage}%`;
          }
        }
        
        // Update info label
        infoLabel.textContent = formatTimeRange(timeFilter.startTime, timeFilter.endTime);
      }
      
      // Function to end dragging
      function endDrag() {
        if (isDragging) {
          isDragging = false;
          document.removeEventListener('mousemove', handleDrag);
          document.removeEventListener('mouseup', endDrag);
          
          // Apply the filter to the map
          const historyData = window.originalHistoryData || window.currentHistoryData;
          if (historyData) {
            applyTimeFilter(historyData);
            
            // Update URL with filter window parameters
            updateUrlWithTimeFilter();
          }
        }
      }
      
      // Set up left handle drag
      leftHandle.addEventListener('mousedown', function(e) {
        e.stopPropagation();
        isDragging = true;
        currentHandle = leftHandle;
        document.addEventListener('mousemove', handleDrag);
        document.addEventListener('mouseup', endDrag);
      });
      
      // Set up right handle drag
      rightHandle.addEventListener('mousedown', function(e) {
        e.stopPropagation();
        isDragging = true;
        currentHandle = rightHandle;
        document.addEventListener('mousemove', handleDrag);
        document.addEventListener('mouseup', endDrag);
      });
    }
    
    // Remove the selection window and clear the time filter
    function removeSelectionWindow() {
      const container = document.getElementById('message-histogram');
      const selectionWindow = container.querySelector('.selection-window');
      if (selectionWindow) {
        container.removeChild(selectionWindow);
      }
      
      // Clear the time filter
      timeFilter = {
        active: false,
        startTime: null,
        endTime: null
      };
      
      // Store the original data back to currentHistoryData
      const originalHistoryData = window.originalHistoryData || window.currentHistoryData;
      
      // Restore the original map display
      if (originalHistoryData) {
        // Reset currentHistoryData to the original data
        window.currentHistoryData = originalHistoryData;
        
        // Display the original data
        displayVesselTrack(originalHistoryData);
        
        // Remove filter parameters from URL
        removeTimeFilterFromUrl();
      }
    }
    
    // Update URL with time filter parameters
    function updateUrlWithTimeFilter() {
      if (!timeFilter.active) return;
      
      // Create a new URL object based on the current URL
      const url = new URL(window.location.href);
      
      // Add or update the filter parameters
      url.searchParams.set('filterStart', timeFilter.startTime.toISOString());
      url.searchParams.set('filterEnd', timeFilter.endTime.toISOString());
      
      // Update the browser history without reloading the page
      window.history.replaceState({}, '', url);
    }
    
    // Remove time filter parameters from URL
    function removeTimeFilterFromUrl() {
      // Create a new URL object based on the current URL
      const url = new URL(window.location.href);
      
      // Remove the filter parameters
      url.searchParams.delete('filterStart');
      url.searchParams.delete('filterEnd');
      
      // Update the browser history without reloading the page
      window.history.replaceState({}, '', url);
    }
    
    // Apply time filter to the map
    function applyTimeFilter(historyData) {
      if (!timeFilter.active || !historyData) return;
      
      // Store the original data if not already stored
      if (!window.originalHistoryData) {
        window.originalHistoryData = historyData;
      }
      
      // Filter the data based on the time range
      const filteredData = historyData.filter(record => {
        const timestamp = new Date(record.Timestamp);
        return timestamp >= timeFilter.startTime && timestamp <= timeFilter.endTime;
      });
      
      // Store the filtered data globally so it can be accessed by the connection line code
      window.currentHistoryData = filteredData;
      
      // Update the map with filtered data but don't store as current data
      displayVesselTrackFiltered(filteredData);
    }
    
    // Display filtered vessel track on map without changing the original data
    function displayVesselTrackFiltered(historyData) {
      if (!historyData || !historyData.length) {
        return;
      }

      // Clear existing layers
      mapLayerGroup.clearLayers();
      
      // Prepare points with valid coordinates
      const pts = historyData
        .filter(r => {
          const flat = flatten(r.Packet);
          return flat.Latitude != null && flat.Longitude != null &&
                 !isNaN(flat.Latitude) && !isNaN(flat.Longitude) &&
                 !(flat.Latitude === 91 && flat.Longitude === 181); // Filter out invalid coordinates
        })
        .map(r => {
          const flat = flatten(r.Packet);
          return {
            lat: flat.Latitude,
            lng: flat.Longitude,
            timestamp: r.Timestamp,
            record: r,
            data: flat
          };
        });

      if (!pts.length) {
        console.log('No valid position data found');
        return;
      }
      
      // Sort points by timestamp (newest first)
      pts.sort((a, b) => new Date(b.timestamp) - new Date(a.timestamp));
      
      // Calculate total distance between start and end points
      if (pts.length >= 2) {
        const first = pts[pts.length - 1]; // Oldest point
        const last = pts[0]; // Newest point
        
        // Calculate direct distance between first and last points
        const startPoint = L.latLng(first.lat, first.lng);
        const endPoint = L.latLng(last.lat, last.lng);
        const directDistance = startPoint.distanceTo(endPoint);
        
        // Calculate total path distance
        let pathDistance = 0;
        for (let i = 0; i < pts.length - 1; i++) {
          const pt1 = L.latLng(pts[i].lat, pts[i].lng);
          const pt2 = L.latLng(pts[i+1].lat, pts[i+1].lng);
          pathDistance += pt1.distanceTo(pt2);
        }
        
        // Update distance overlay with total path distance in nautical miles
        const distanceOverlay = document.getElementById('distance-overlay');
        if (distanceOverlay) {
          distanceOverlay.textContent = `${metersToNauticalMiles(pathDistance)} NM`;
        }
      }
      
      // Create colored track based on speed
      const coloredTrack = createColoredTrack(pts);
      coloredTrack.addTo(mapLayerGroup);
      
      // Tooltip options
      const tooltipOpts = {
        direction: 'top',
        offset: [0, -6],
        permanent: false,
        sticky: true
      };
      
      // Create a layer group for temporary connection lines
      const connectionLayerGroup = L.layerGroup().addTo(map);
      
      // Add tooltips to each segment in the colored track
      coloredTrack.eachLayer(segment => {
        segment.bindTooltip('', tooltipOpts);
        
        segment.on('mousemove', e => {
          // Find the nearest point to where the mouse is
          let minDist = Infinity, nearestPoint = null;
          pts.forEach(pt => {
            const ptLatLng = L.latLng(pt.lat, pt.lng);
            const d = e.latlng.distanceTo(ptLatLng);
            if (d < minDist) {
              minDist = d;
              nearestPoint = pt;
            }
          });
          
          if (nearestPoint) {
            // Check for invalid coordinates (91, 181)
            if (nearestPoint.lat === 91 && nearestPoint.lng === 181) {
              segment.setTooltipContent('Invalid position data');
              segment.openTooltip(e.latlng);
              return;
            }
            
            let html = makePolylineTooltipHTML(nearestPoint);
            
            // Clear previous connection lines
            connectionLayerGroup.clearLayers();
            
            // Check if the record has a ReceiverID
            const receiverId = nearestPoint.record.ReceiverID;
            if (receiverId && receiversData.length > 0) {
              // Find the receiver in receiversData
              const receiver = receiversData.find(r => r.id === receiverId);
              if (receiver && receiver.latitude && receiver.longitude) {
                // Draw a dashed grey line between the point and the receiver
                const connectionLine = L.polyline(
                  [[nearestPoint.lat, nearestPoint.lng], [receiver.latitude, receiver.longitude]],
                  {
                    color: 'grey',
                    weight: 2,
                    opacity: 0.7,
                    dashArray: '5, 7'
                  }
                ).addTo(connectionLayerGroup);
                
                // Calculate distance in kilometers
                const pointLatLng = L.latLng(nearestPoint.lat, nearestPoint.lng);
                const receiverLatLng = L.latLng(receiver.latitude, receiver.longitude);
                const distanceKm = (pointLatLng.distanceTo(receiverLatLng) / 1000).toFixed(2);
                
                // Add receiver info to tooltip with proper formatting
                html += `<br/><strong>Receiver:</strong> ${receiver.name} (${distanceKm} km)`;
                
                // Find and highlight the active receiver tooltip
                document.querySelectorAll('.leaflet-tooltip').forEach(tooltip => {
                  // Remove active class from all tooltips
                  tooltip.classList.remove('receiver-tooltip-active');
                  
                  // Add active class to the matching receiver tooltip
                  if (tooltip.textContent === receiver.name) {
                    tooltip.classList.add('receiver-tooltip-active');
                  }
                });
              }
            }
            
            // Update tooltip content with the complete HTML including receiver info
            segment.setTooltipContent(html);
            segment.openTooltip(e.latlng);
          }
        });
        
        segment.on('mouseout', () => {
          segment.closeTooltip();
          // Clear connection lines when mouse leaves the segment
          connectionLayerGroup.clearLayers();
          
          // Remove active class from all receiver tooltips
          document.querySelectorAll('.leaflet-tooltip').forEach(tooltip => {
            tooltip.classList.remove('receiver-tooltip-active');
          });
        });
      });
      
      // Add markers at the first and last points with tooltips
      const first = pts[pts.length - 1]; // Oldest point
      const last = pts[0]; // Newest point
      
      const startMarker = L.marker([first.lat, first.lng], {
        icon: L.divIcon({
          className: 'start-marker',
          html: '🔵',
          iconSize: [20, 20],
          iconAnchor: [10, 10]
        })
      }).addTo(mapLayerGroup);
      startMarker.bindTooltip('Start: ' + new Date(first.timestamp).toLocaleString(), tooltipOpts);
      
      // Add mouseover event to start marker to show connection to receiver
      startMarker.on('mouseover', () => {
        // Clear previous connection lines
        connectionLayerGroup.clearLayers();
        
        // Check if the record has a ReceiverID
        const receiverId = first.record.ReceiverID;
        if (receiverId && receiversData.length > 0) {
          // Find the receiver in receiversData
          const receiver = receiversData.find(r => r.id === receiverId);
          if (receiver && receiver.latitude && receiver.longitude) {
            // Calculate distance in kilometers
            const pointLatLng = L.latLng(first.lat, first.lng);
            const receiverLatLng = L.latLng(receiver.latitude, receiver.longitude);
            const distanceKm = (pointLatLng.distanceTo(receiverLatLng) / 1000).toFixed(2);
            
            // Update tooltip content
            const tooltipContent = `Start: ${new Date(first.timestamp).toLocaleString()}<br/><strong>Receiver:</strong> ${receiver.name} / ${distanceKm} km`;
            startMarker.setTooltipContent(tooltipContent);
            
            // Draw a dashed grey line between the point and the receiver
            const connectionLine = L.polyline(
              [[first.lat, first.lng], [receiver.latitude, receiver.longitude]],
              {
                color: 'grey',
                weight: 2,
                opacity: 0.7,
                dashArray: '5, 7'
              }
            ).addTo(connectionLayerGroup);
          }
        }
      });
      
      startMarker.on('mouseout', () => {
        // Clear connection lines when mouse leaves the marker
        connectionLayerGroup.clearLayers();
      });
      
      const endMarker = L.marker([last.lat, last.lng], {
        icon: L.divIcon({
          className: 'end-marker',
          html: '🟣',
          iconSize: [20, 20],
          iconAnchor: [10, 10]
        })
      }).addTo(mapLayerGroup);
      endMarker.bindTooltip('End: ' + new Date(last.timestamp).toLocaleString(), tooltipOpts);
      
      // Add mouseover event to end marker to show connection to receiver
      endMarker.on('mouseover', () => {
        // Clear previous connection lines
        connectionLayerGroup.clearLayers();
        
        // Check if the record has a ReceiverID
        const receiverId = last.record.ReceiverID;
        if (receiverId && receiversData.length > 0) {
          // Find the receiver in receiversData
          const receiver = receiversData.find(r => r.id === receiverId);
          if (receiver && receiver.latitude && receiver.longitude) {
            // Calculate distance in kilometers
            const pointLatLng = L.latLng(last.lat, last.lng);
            const receiverLatLng = L.latLng(receiver.latitude, receiver.longitude);
            const distanceKm = (pointLatLng.distanceTo(receiverLatLng) / 1000).toFixed(2);
            
            // Update tooltip content
            const tooltipContent = `End: ${new Date(last.timestamp).toLocaleString()}<br/><strong>Receiver:</strong> ${receiver.name} / ${distanceKm} km`;
            endMarker.setTooltipContent(tooltipContent);
            
            // Draw a dashed grey line between the point and the receiver
            const connectionLine = L.polyline(
              [[last.lat, last.lng], [receiver.latitude, receiver.longitude]],
              {
                color: 'grey',
                weight: 2,
                opacity: 0.7,
                dashArray: '5, 7'
              }
            ).addTo(connectionLayerGroup);
          }
        }
      });
      
      endMarker.on('mouseout', () => {
        // Clear connection lines when mouse leaves the marker
        connectionLayerGroup.clearLayers();
      });
      
      // Add receiver markers for receivers that heard this vessel
      // Get the vessel data to find which receivers heard it
      fetch(`/state?UserID=${userID}`, { cache: 'no-store' })
        .then(response => response.json())
        .then(data => {
          if (data.ReceiverIDs && Array.isArray(data.ReceiverIDs) && data.ReceiverIDs.length > 0) {
            // Filter receivers to only those that heard this vessel
            const relevantReceivers = receiversData.filter(receiver =>
              data.ReceiverIDs.includes(receiver.id)
            );
            
            // Add a marker for each receiver
            relevantReceivers.forEach(receiver => {
              if (receiver.latitude && receiver.longitude) {
                // Create a red circle marker for the receiver
                const receiverMarker = L.circleMarker([receiver.latitude, receiver.longitude], {
                  radius: 6,
                  color: 'red',
                  fillColor: '#f03',
                  fillOpacity: 0.8,
                  weight: 2
                }).addTo(mapLayerGroup);
                
                // Add a permanent tooltip with the receiver name
                receiverMarker.bindTooltip(receiver.name, {
                  permanent: true,
                  direction: 'top',
                  offset: [0, -10],
                  className: 'receiver-tooltip'
                }).openTooltip();
              }
            });
          }
        })
        .catch(err => {
          console.error('Error fetching vessel data for receiver markers:', err);
        });
      
      // Fit map to vessel track data only (not including receivers)
      const latlngs = pts.map(p => [p.lat, p.lng]);
      map.fitBounds(L.latLngBounds(latlngs).pad(0.2));
    }
    
    // Check for time filter parameters in URL and restore if present
    function checkForTimeFilterInUrl(historyData) {
      const urlParams = new URLSearchParams(window.location.search);
      const filterStart = urlParams.get('filterStart');
      const filterEnd = urlParams.get('filterEnd');
      
      if (filterStart && filterEnd) {
        try {
          const startTime = new Date(filterStart);
          const endTime = new Date(filterEnd);
          
          // Validate dates
          if (!isNaN(startTime.getTime()) && !isNaN(endTime.getTime())) {
            // Set the time filter
            timeFilter = {
              active: true,
              startTime: startTime,
              endTime: endTime
            };
            
            // Add a small delay to ensure the histogram is fully rendered
            setTimeout(() => {
              // Get the actual data time range from the histogram
              const container = document.getElementById('message-histogram');
              const histogramStartTime = container.dataset.startTime ? new Date(container.dataset.startTime) : new Date(historyData[0].Timestamp);
              const histogramEndTime = container.dataset.endTime ? new Date(container.dataset.endTime) : new Date(historyData[historyData.length - 1].Timestamp);
              
              // Create the selection window
              createSelectionWindow(container, histogramStartTime, histogramEndTime);
              
              // Apply the filter to the map
              applyTimeFilter(historyData);
            }, 100);
          }
        } catch (e) {
          console.error('Error restoring time filter from URL:', e);
        }
      }
    }
    
    // Replay functionality
    let replayInProgress = false;
    let replayAnimationId = null;
    let replayTooltip = null;
    let replayPolyline = null;
    let tooltipVisible = true; // Track tooltip visibility
    let totalDistance = 0; // Track total distance
    let currentDistance = 0; // Track current distance during replay
    let detailsOverlay = null; // Store reference to the overlay globally
    
    // Function to update the overlay position
    function updateOverlayPosition() {
      // Use replayTooltip as the source of truth for the overlay
      if (!replayTooltip) return;
      
      const mapContainer = document.getElementById('map-container');
      const mapRect = mapContainer.getBoundingClientRect();
      
      // Set position
      replayTooltip.style.left = 'auto';
      replayTooltip.style.top = 'auto';
      replayTooltip.style.right = (window.innerWidth - mapRect.right + 10) + 'px';
      replayTooltip.style.bottom = (window.innerHeight - mapRect.bottom + 10) + 'px';
    }
    
    // Function to toggle overlay visibility
    function toggleTooltipVisibility() {
      if (replayTooltip) {
        if (tooltipVisible) {
          // Hide overlay
          replayTooltip.style.display = 'none';
          tooltipVisible = false;
        } else {
          // Show overlay
          replayTooltip.style.display = 'table';
          tooltipVisible = true;
        }
      }
    }
    
    // Initialize replay button
    document.addEventListener('DOMContentLoaded', () => {
          const replayButton = document.getElementById('replay-button');
          if (replayButton) {
            replayButton.addEventListener('click', function(e) {
              // Stop event propagation to prevent the map click handler from being triggered
              e.stopPropagation();
              startReplay();
            });
          }
          
          // Also prevent propagation for the replay duration dropdown
          const replayDuration = document.getElementById('replay-duration');
          if (replayDuration) {
            replayDuration.addEventListener('click', function(e) {
              e.stopPropagation();
            });
            
            // Also prevent propagation for change events
            replayDuration.addEventListener('change', function(e) {
              e.stopPropagation();
            });
          }
        });
    
    function startReplay() {
      // If replay is in progress, stop it instead
      if (replayInProgress) {
        stopReplay();
        return;
      }
      
      // Get current points from the map
      const historyData = window.currentHistoryData;
      if (!historyData || !historyData.length) {
        console.log('No data to replay');
        alert('No data available to replay');
        return;
      }
      
      // Prepare points with valid coordinates
      const pts = historyData
        .filter(r => {
          const flat = flatten(r.Packet);
          return flat && flat.Latitude != null && flat.Longitude != null &&
                 !isNaN(flat.Latitude) && !isNaN(flat.Longitude) &&
                 !(flat.Latitude === 91 && flat.Longitude === 181); // Filter out invalid coordinates
        })
        .map(r => {
          const flat = flatten(r.Packet);
          return {
            lat: flat.Latitude,
            lng: flat.Longitude,
            timestamp: r.Timestamp,
            record: r,
            data: flat
          };
        });
      
      if (!pts.length) {
        console.log('No valid position data found for replay');
        alert('No valid position data found for replay');
        return;
      }
      
      // Sort points by timestamp (oldest first)
      pts.sort((a, b) => new Date(a.timestamp) - new Date(b.timestamp));
      
      // Calculate total distance between all points
      totalDistance = 0;
      for (let i = 0; i < pts.length - 1; i++) {
        const pt1 = L.latLng(pts[i].lat, pts[i].lng);
        const pt2 = L.latLng(pts[i+1].lat, pts[i+1].lng);
        totalDistance += pt1.distanceTo(pt2);
      }
      // Convert to nautical miles and round to 2 decimal places
      totalDistance = metersToNauticalMiles(totalDistance);
      
      // Reset current distance
      currentDistance = 0;
      
      // Get selected duration
      const durationSelect = document.getElementById('replay-duration');
      const durationSeconds = parseInt(durationSelect.value, 10);
      
      // Update UI
      const replayButton = document.getElementById('replay-button');
      replayButton.innerHTML = `
        <svg xmlns="http://www.w3.org/2000/svg" width="12" height="12" fill="currentColor" viewBox="0 0 16 16">
          <path d="M5.5 3.5A1.5 1.5 0 0 1 7 5v6a1.5 1.5 0 0 1-3 0V5a1.5 1.5 0 0 1 1.5-1.5zm5 0A1.5 1.5 0 0 1 12 5v6a1.5 1.5 0 0 1-3 0V5a1.5 1.5 0 0 1 1.5-1.5z"/>
        </svg>
        Stop
      `;
      
      // Clear existing layers but keep the base map
      mapLayerGroup.clearLayers();
      
      // Add a class to the map container to indicate replay is active
      document.getElementById('map-container').classList.add('replay-active');
      
      // Create a layer group for the replay animation segments
      replayPolyline = L.layerGroup().addTo(mapLayerGroup);
      
      // Create a layer group for receiver connection lines
      const connectionLayerGroup = L.layerGroup().addTo(mapLayerGroup);
      
      // Show distance overlay with initial distance (0 NM)
      const distanceOverlay = document.getElementById('distance-overlay');
      if (distanceOverlay) {
        distanceOverlay.textContent = `0.00 NM / ${totalDistance} NM`;
      }
      
      // Show timestamp overlay with initial timestamp
      const timestampOverlay = document.getElementById('timestamp-overlay');
      if (timestampOverlay) {
        timestampOverlay.textContent = new Date(pts[0].timestamp).toLocaleString();
        timestampOverlay.style.display = 'block';
      }
      
      // Add receiver markers for receivers that heard this vessel
      addReceiverMarkers();
      
      // Ensure we have at least one valid point
      if (!pts[0] || pts[0].lat === undefined || pts[0].lng === undefined) {
        console.error('First point is invalid:', pts[0]);
        finishReplay([]);
        return;
      }
      
      // Pre-calculate all polyline segments for better performance
      const segments = [];
      for (let i = 0; i < pts.length - 1; i++) {
        const pt1 = pts[i];
        const pt2 = pts[i + 1];
        
        if (pt1 && pt2 && pt1.lat !== undefined && pt1.lng !== undefined &&
            pt2.lat !== undefined && pt2.lng !== undefined) {
          // Use the speed of the first point for the color
          const speed = pt1.data.Sog != null ? pt1.data.Sog : 0;
          const color = getColorForSpeed(speed);
          
          segments.push({
            points: [[pt1.lat, pt1.lng], [pt2.lat, pt2.lng]],
            color: color
          });
        }
      }
      
      // Create a marker for the current position
      const currentMarker = L.marker([pts[0].lat, pts[0].lng], {
        icon: L.divIcon({
          className: 'current-marker',
          html: '🔷',
          iconSize: [20, 20],
          iconAnchor: [10, 10]
        })
      }).addTo(mapLayerGroup);
      
      // Create tooltip for the current position
      try {
        let tooltipContent = '';
        try {
          tooltipContent = makeTooltipHTML(pts[0]);
          
          // Add receiver information to tooltip if available
          const receiverId = pts[0].record.ReceiverID;
          if (receiverId && receiversData.length > 0) {
            // Find the receiver in receiversData
            const receiver = receiversData.find(r => r.id === receiverId);
            if (receiver && receiver.latitude && receiver.longitude) {
              // Calculate distance in kilometers
              const pointLatLng = L.latLng(pts[0].lat, pts[0].lng);
              const receiverLatLng = L.latLng(receiver.latitude, receiver.longitude);
              const distanceKm = (pointLatLng.distanceTo(receiverLatLng) / 1000).toFixed(2);
              
              // Add receiver info to tooltip with proper formatting
              tooltipContent += `<br/><strong>RX:</strong> ${escapeHtml(distanceKm)} km`;
            }
          }
        } catch (e) {
          console.error('Error creating tooltip content:', e);
          // Create a simple fallback tooltip content
          tooltipContent = `<strong>${new Date(pts[0].timestamp).toLocaleString()}</strong><br/>` +
                          `<strong>Latitude:</strong> ${pts[0].lat.toFixed(6)}<br/>` +
                          `<strong>Longitude:</strong> ${pts[0].lng.toFixed(6)}`;
        }
        
        // Create a completely new approach for the overlay
        const overlay = document.createElement('div');
        overlay.className = 'vessel-replay-info-box';
        overlay.innerHTML = tooltipContent;
        
        // Make sure it's visible by default
        overlay.style.display = 'table';
        
        // Add to body instead of map container
        document.body.appendChild(overlay);
        
        // Store reference to the overlay
        replayTooltip = overlay;
        detailsOverlay = overlay;
        
        // Initial positioning
        updateOverlayPosition();
        
        // Add event listeners to update position when map moves or window resizes
        map.on('move', updateOverlayPosition);
        map.on('zoom', updateOverlayPosition);
        window.addEventListener('resize', updateOverlayPosition);
        
        // Add click handler to map to toggle overlay visibility
        map.on('click', toggleTooltipVisibility);
      } catch (e) {
        console.error('Error creating tooltip:', e);
        // Continue without tooltip if there's an error
        replayTooltip = null;
      }
      
      // Set up the animation
      replayInProgress = true;
      const startTime = performance.now();
      const totalDuration = durationSeconds * 1000; // convert to milliseconds
      const progressBar = document.getElementById('replay-progress');
      
      // Animation function
      function animate(currentTime) {
        // Safety check - if replay was cancelled
        if (!replayInProgress) {
          return;
        }
        
        const elapsedTime = currentTime - startTime;
        const progress = Math.min(elapsedTime / totalDuration, 1);
        
        // Update progress bar
        if (progressBar) {
          progressBar.style.width = `${progress * 100}%`;
        }
        
        if (progress < 1 && pts.length > 0) {
          try {
            // Calculate the current point index based on progress
            // Ensure it's never negative and always within bounds
            const rawIndex = Math.floor(progress * pts.length);
            const pointIndex = Math.max(0, Math.min(rawIndex, pts.length - 1));
            
            // Log if we calculated an invalid index (for debugging)
            if (rawIndex < 0 || rawIndex >= pts.length) {
              console.log('Adjusted invalid point index:', rawIndex, 'to', pointIndex, 'pts length:', pts.length);
            }
            
            // Get current point and verify it's valid
            const currentPoint = pts[pointIndex];
            if (!currentPoint || currentPoint.lat === undefined || currentPoint.lng === undefined) {
              console.error('Invalid point at index:', pointIndex, currentPoint);
              finishReplay(pts);
              return;
            }
            
            // Calculate the segment index (one less than point index)
            const segmentIndex = Math.min(pointIndex, segments.length);
            
            // Calculate current distance traveled
            currentDistance = 0;
            for (let i = 0; i < pointIndex && i < pts.length - 1; i++) {
              const pt1 = L.latLng(pts[i].lat, pts[i].lng);
              const pt2 = L.latLng(pts[i+1].lat, pts[i+1].lng);
              currentDistance += pt1.distanceTo(pt2);
            }
            // Convert to nautical miles
            const currentDistanceNM = metersToNauticalMiles(currentDistance);
            
            // Update distance overlay
            const distanceOverlay = document.getElementById('distance-overlay');
            if (distanceOverlay) {
              distanceOverlay.textContent = `${currentDistanceNM} NM / ${totalDistance} NM`;
            }
            
            // Add segments that haven't been added yet
            // We use a static variable to keep track of the last drawn segment
            if (!animate.lastDrawnSegment) {
              animate.lastDrawnSegment = -1;
            }
            
            // Only draw new segments (from last drawn + 1 to current segment index)
            for (let i = animate.lastDrawnSegment + 1; i < segmentIndex; i++) {
              if (i >= 0 && i < segments.length) {
                const segment = segments[i];
                L.polyline(segment.points, {
                  color: segment.color,
                  weight: 3,
                  opacity: 0.8
                }).addTo(replayPolyline);
              }
            }
            
            // Update the last drawn segment
            animate.lastDrawnSegment = segmentIndex - 1;
            
            // Update marker position
            if (currentMarker) {
              currentMarker.setLatLng([currentPoint.lat, currentPoint.lng]);
            }
            
            // Update overlay content (but keep visibility state)
            if (replayTooltip) {
              try {
                let tooltipContent = makeTooltipHTML(currentPoint);
                
                // Add receiver information to overlay if available
                const receiverId = currentPoint.record.ReceiverID;
                if (receiverId && receiversData.length > 0) {
                  // Find the receiver in receiversData
                  const receiver = receiversData.find(r => r.id === receiverId);
                  if (receiver && receiver.latitude && receiver.longitude) {
                    // Calculate distance in kilometers
                    const pointLatLng = L.latLng(currentPoint.lat, currentPoint.lng);
                    const receiverLatLng = L.latLng(receiver.latitude, receiver.longitude);
                    const distanceKm = (pointLatLng.distanceTo(receiverLatLng) / 1000).toFixed(2);
                    
                    // Add receiver info to overlay with proper formatting
                    tooltipContent += `<br/><strong>RX:</strong> ${escapeHtml(distanceKm)} km`;
                  }
                }
                
                replayTooltip.innerHTML = tooltipContent;
                
                // Maintain visibility state
                replayTooltip.style.display = tooltipVisible ? 'table' : 'none';
              } catch (e) {
                console.error('Error updating overlay content:', e);
                // Use a simple fallback content
                const fallbackContent = `<strong>${new Date(currentPoint.timestamp).toLocaleString()}</strong><br/>` +
                                      `<strong>Latitude:</strong> ${currentPoint.lat.toFixed(6)}<br/>` +
                                      `<strong>Longitude:</strong> ${currentPoint.lng.toFixed(6)}`;
                replayTooltip.innerHTML = fallbackContent;
              }
            }
            
            // Update timestamp overlay with current timestamp
            const timestampOverlay = document.getElementById('timestamp-overlay');
            if (timestampOverlay) {
              timestampOverlay.textContent = new Date(currentPoint.timestamp).toLocaleString();
            }
            
            // Show connection to receiver if available
            connectionLayerGroup.clearLayers();
            const receiverId = currentPoint.record.ReceiverID;
            if (receiverId && receiversData.length > 0) {
              // Find the receiver in receiversData
              const receiver = receiversData.find(r => r.id === receiverId);
              if (receiver && receiver.latitude && receiver.longitude) {
                // Draw a dashed grey line between the point and the receiver
                const connectionLine = L.polyline(
                  [[currentPoint.lat, currentPoint.lng], [receiver.latitude, receiver.longitude]],
                  {
                    color: 'grey',
                    weight: 2,
                    opacity: 0.7,
                    dashArray: '5, 7'
                  }
                ).addTo(connectionLayerGroup);
                
                // Find and highlight the active receiver tooltip
                document.querySelectorAll('.leaflet-tooltip').forEach(tooltip => {
                  // Remove active class from all tooltips
                  tooltip.classList.remove('receiver-tooltip-active');
                  
                  // Add active class to the matching receiver tooltip
                  if (tooltip.textContent === receiver.name) {
                    tooltip.classList.add('receiver-tooltip-active');
                  }
                });
              }
            }
            
            // Continue animation
            replayAnimationId = requestAnimationFrame(animate);
          } catch (error) {
            console.error('Error during replay animation:', error);
            finishReplay(pts);
          }
        } else {
          // Animation complete
          finishReplay(pts);
        }
      }
      
      // Start the animation
      // Reset the last drawn segment counter
      animate.lastDrawnSegment = -1;
      replayAnimationId = requestAnimationFrame(animate);
    }
    
    // Function to stop replay
    function stopReplay() {
      if (!replayInProgress) return;
      
      // Cancel animation
      if (replayAnimationId) {
        cancelAnimationFrame(replayAnimationId);
        replayAnimationId = null;
      }
      
      // Call finishReplay to clean up
      finishReplay(window.currentHistoryData || []);
      
      // Reset the static variable for the animation function
      if (animate.lastDrawnSegment !== undefined) {
        animate.lastDrawnSegment = -1;
      }
    }
    
    function finishReplay(pts) {
      // Reset UI
      const replayButton = document.getElementById('replay-button');
      if (replayButton) {
        replayButton.innerHTML = `
          <svg xmlns="http://www.w3.org/2000/svg" width="12" height="12" fill="currentColor" viewBox="0 0 16 16">
            <path d="M11.596 8.697l-6.363 3.692c-.54.313-1.233-.066-1.233-.697V4.308c0-.63.692-1.01 1.233-.696l6.363 3.692a.802.802 0 0 1 0 1.393z"/>
          </svg>
          Replay
        `;
      }
      
      // Reset progress bar
      const progressBar = document.getElementById('replay-progress');
      if (progressBar) {
        progressBar.style.width = '0%';
      }
      
      // Clean up
      replayInProgress = false;
      
      // Remove the replay-active class from the map container
      document.getElementById('map-container').classList.remove('replay-active');
      if (replayAnimationId) {
        cancelAnimationFrame(replayAnimationId);
        replayAnimationId = null;
      }
      
      // Reset distance overlay to show total path distance
      const distanceOverlay = document.getElementById('distance-overlay');
      if (distanceOverlay && window.currentHistoryData && window.currentHistoryData.length > 0) {
        // Recalculate total path distance
        const pts = window.currentHistoryData
          .filter(r => {
            const flat = flatten(r.Packet);
            return flat.Latitude != null && flat.Longitude != null &&
                   !isNaN(flat.Latitude) && !isNaN(flat.Longitude) &&
                   !(flat.Latitude === 91 && flat.Longitude === 181); // Filter out invalid coordinates
          })
          .map(r => {
            const flat = flatten(r.Packet);
            return {
              lat: flat.Latitude,
              lng: flat.Longitude
            };
          });
          
        if (pts.length >= 2) {
          // Calculate total path distance
          let pathDistance = 0;
          for (let i = 0; i < pts.length - 1; i++) {
            const pt1 = L.latLng(pts[i].lat, pts[i].lng);
            const pt2 = L.latLng(pts[i+1].lat, pts[i+1].lng);
            pathDistance += pt1.distanceTo(pt2);
          }
          
          // Update distance overlay with total path distance in nautical miles
          distanceOverlay.textContent = `${metersToNauticalMiles(pathDistance)} NM`;
        }
      }
      
      const timestampOverlay = document.getElementById('timestamp-overlay');
      if (timestampOverlay) {
        timestampOverlay.style.display = 'none';
      }
      
      // Remove overlay
      if (replayTooltip) {
        try {
          // Remove the overlay element from the DOM
          document.body.removeChild(replayTooltip);
        } catch (e) {
          console.error('Error removing overlay:', e);
        }
        replayTooltip = null;
        detailsOverlay = null; // Also reset detailsOverlay
        tooltipVisible = true; // Reset overlay visibility state
        
        // Remove event listeners
        map.off('move', updateOverlayPosition);
        map.off('zoom', updateOverlayPosition);
        window.removeEventListener('resize', updateOverlayPosition);
        
        // Remove map click handler
        map.off('click', toggleTooltipVisibility);
      }
      
      // Redisplay the full track if we have data
      if (window.currentHistoryData && window.currentHistoryData.length > 0) {
        // Reset detailsOverlay reference
        // Don't set detailsOverlay to null here, it will be handled when replayTooltip is removed
        try {
          // Redisplay the track and ensure tooltips are properly initialized
          displayVesselTrack(window.currentHistoryData);
          
          // Force a small delay to ensure all map elements are properly reinitialized
          setTimeout(() => {
            // Ensure all polyline segments have proper tooltip event handlers
            if (mapLayerGroup) {
              mapLayerGroup.eachLayer(layer => {
                if (layer instanceof L.LayerGroup) {
                  layer.eachLayer(segment => {
                    if (segment instanceof L.Polyline) {
                      // Refresh tooltip bindings if needed
                      if (!segment.getTooltip()) {
                        segment.bindTooltip('', {
                          direction: 'top',
                          offset: [0, -6],
                          permanent: false,
                          sticky: true
                        });
                      }
                    }
                  });
                }
              });
            }
          }, 100);
        } catch (e) {
          console.error('Error redisplaying track:', e);
        }
      }
    }
    
    // Function to add receiver markers to the map
    function addReceiverMarkers() {
      // Get the vessel data to find which receivers heard it
      fetch(`/state?UserID=${userID}`, { cache: 'no-store' })
        .then(response => response.json())
        .then(data => {
          if (data.ReceiverIDs && Array.isArray(data.ReceiverIDs) && data.ReceiverIDs.length > 0) {
            // Filter receivers to only those that heard this vessel
            const relevantReceivers = receiversData.filter(receiver =>
              data.ReceiverIDs.includes(receiver.id)
            );
            
            // Add a marker for each receiver
            relevantReceivers.forEach(receiver => {
              if (receiver.latitude && receiver.longitude) {
                // Create a red circle marker for the receiver
                const receiverMarker = L.circleMarker([receiver.latitude, receiver.longitude], {
                  radius: 6,
                  color: 'red',
                  fillColor: '#f03',
                  fillOpacity: 0.8,
                  weight: 2
                }).addTo(mapLayerGroup);
                
                // Add a permanent tooltip with the receiver name
                receiverMarker.bindTooltip(receiver.name, {
                  permanent: true,
                  direction: 'top',
                  offset: [0, -10],
                  className: 'receiver-tooltip'
                }).openTooltip();
              }
            });
          }
        })
        .catch(err => {
          console.error('Error fetching vessel data for receiver markers:', err);
        });
    }
    
    // Search functionality
    document.addEventListener('DOMContentLoaded', function() {
      const searchIcon = document.querySelector('.search-icon');
      const searchBox = document.querySelector('.search-box');
      const searchInput = document.querySelector('.search-input');
      const searchResults = document.querySelector('.search-results');
      let searchTimeout = null;
      
      // Toggle search box visibility when clicking the search icon
      searchIcon.addEventListener('click', function() {
        const isVisible = searchBox.style.display === 'block';
        searchBox.style.display = isVisible ? 'none' : 'block';
        if (!isVisible) {
          searchInput.focus();
        } else {
          searchResults.style.display = 'none';
        }
      });
      
      // Close search results when clicking outside
      document.addEventListener('click', function(event) {
        if (!event.target.closest('.search-container')) {
          searchResults.style.display = 'none';
        }
      });
      
      // Handle search input
      searchInput.addEventListener('input', function() {
        const query = this.value.trim();
        
        // Clear previous timeout
        if (searchTimeout) {
          clearTimeout(searchTimeout);
        }
        
        // Hide results if query is too short
        if (query.length < 3) {
          searchResults.style.display = 'none';
          return;
        }
        
        // Set a small delay to avoid sending too many requests
        searchTimeout = setTimeout(() => {
          performSearch(query);
        }, 300);
      });
      
      // Perform search request
      function performSearch(query) {
        fetch('/search', {
          method: 'POST',
          headers: {
            'Content-Type': 'application/json'
          },
          body: JSON.stringify({
            query: query,
            maxAge: 0,
            maxResults: 100
          })
        })
        .then(response => response.json())
        .then(results => {
          displaySearchResults(results);
        })
        .catch(error => {
          console.error('Search error:', error);
        });
      }
      
      // Display search results
      function displaySearchResults(results) {
        // Clear previous results
        searchResults.innerHTML = '';
        
        if (results.length === 0) {
          const noResults = document.createElement('div');
          noResults.className = 'search-result-item';
          noResults.textContent = 'No results found';
          searchResults.appendChild(noResults);
        } else {
          // Reverse the results to show most recently seen first
          results.reverse().forEach(result => {
            const item = document.createElement('div');
            item.className = 'search-result-item';
            
            // Format the last updated time
            const lastUpdated = new Date(result.LastUpdated);
            const timeAgo = formatTimeDifference(result.LastUpdated);
            const formattedTime = lastUpdated.toLocaleString();
            
            // Create content with all required fields
            let content = `<strong>${result.Name}</strong>`;
            content += `<br>MMSI: ${result.UserID}`;
            
            if (result.CallSign && result.CallSign !== "") {
              content += `<br>Call Sign: ${result.CallSign}`;
            }
            
            if (result.ImoNumber && result.ImoNumber !== 0) {
              content += `<br>IMO: ${result.ImoNumber}`;
            }
            
            content += `<br>Seen: ${formattedTime} (${timeAgo})`;
            content += `<br>Messages: ${result.NumMessages}`;
            
            item.innerHTML = content;
            
            // Add click event to load vessel history
            item.addEventListener('click', function() {
              window.location.href = `?UserID=${result.UserID}`;
            });
            
            searchResults.appendChild(item);
          });
        }
        
        // Show results
        searchResults.style.display = 'block';
      }
    });
  </script>
</body>
</html>
