<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Vessel History</title>
  <!-- Include Bootstrap CSS -->
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/twitter-bootstrap/4.6.0/css/bootstrap.min.css">
  <!-- Include Leaflet CSS -->
  <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.3/dist/leaflet.css"
        integrity="sha256-kLaT2GOSpHechhsozzB+flnD+zUyjE2LlfWPgU04xyI=" crossorigin="" />
  <style>
    body {
      font-family: sans-serif;
      margin: 2rem;
    }
    .vessel-header {
      display: flex;
      align-items: flex-start;
      margin-bottom: 2rem;
    }
    .flag-container {
      margin-right: 2rem;
    }
    .flag-img {
      width: 80px;
      height: auto;
      border: 1px solid #ddd;
    }
    .vessel-info {
      flex-grow: 1;
      display: flex;
      flex-wrap: wrap;
      gap: 1rem;
    }
    .vessel-image {
      max-width: 300px;
      max-height: 200px;
      border: 1px solid #ddd;
      margin-left: 1rem;
    }
    .error {
      color: red;
      font-weight: bold;
    }
    .info-column {
      flex: 1;
      min-width: 300px;
    }
    table {
      border-collapse: collapse;
      width: 100%;
      margin-bottom: 1rem;
    }
    th, td {
      border: 1px solid #ddd;
      padding: 6px;
      text-align: left;
    }
    th {
      background-color: #f2f2f2;
    }
    .history-section {
      margin-top: 2rem;
    }
    .date-selector {
      display: flex;
      gap: 1rem;
      margin-bottom: 1rem;
      align-items: center;
    }
    .date-selector label {
      display: flex;
      flex-direction: column;
      margin-bottom: 0;
    }
    .date-selector button {
      margin-top: 1.5rem;
    }
    #map-container {
      height: 400px;
      margin-bottom: 1rem;
      border: 1px solid #ddd;
      position: relative;
    }
    .changes-container {
      display: flex;
      flex-wrap: wrap;
      gap: 1rem;
      margin-top: 1rem;
    }
    .changes-table {
      flex: 1;
      min-width: 300px;
    }
    .changes-table h3 {
      font-size: 1.2rem;
      margin-bottom: 0.5rem;
    }
    .no-changes {
      font-style: italic;
      color: #666;
    }
    /* Speed legend styles */
    .speed-legend {
      position: absolute;
      top: 10px;
      right: 10px;
      background: rgba(255, 255, 255, 0.9);
      padding: 5px;
      border: 1px solid #ccc;
      border-radius: 3px;
      z-index: 1000;
      font-size: 12px;
      width: 120px;
    }
    .speed-scale-container {
      margin-bottom: 6px;
      padding: 0 5px;
      font-family: Arial, sans-serif;
      font-size: 12px;
      line-height: 1;
    }
    .speed-scale-bar {
      height: 6px;
      border-radius: 3px;
      background: linear-gradient(
        to right,
        hsl(120,100%,50%) 0%,    /* green */
        hsl(60, 100%,50%) 50%,   /* yellow */
        hsl(0,  100%,50%) 100%   /* red */
      );
      margin-bottom: 2px;
    }
    .speed-scale-labels {
      display: flex;
      justify-content: space-between;
    }
  </style>
</head>
<body>
  <h1 id="main-title">Vessel History</h1>

  <div class="vessel-header">
    <div class="flag-container">
      <img id="flag-img" class="flag-img" src="" alt="Country Flag" style="display: none;">
    </div>
    <div class="vessel-info">
      <div class="info-column">
        <table id="vessel-table-left">
          <tbody>
            <!-- Left column data will be inserted here dynamically -->
          </tbody>
        </table>
      </div>
      <div class="info-column">
        <table id="vessel-table-right">
          <tbody>
            <!-- Right column data will be inserted here dynamically -->
          </tbody>
        </table>
      </div>
    </div>
    <div>
      <img id="vessel-img" class="vessel-image" src="" alt="Vessel Image" style="display: none;">
    </div>
  </div>

  <div class="history-section">
    <div class="date-selector">
      <label>From <input type="datetime-local" id="start"/></label>
      <label>To <input type="datetime-local" id="end"/></label>
      <button id="apply-btn" class="btn btn-primary">Search</button>
      <button id="reset-btn" class="btn btn-secondary">Reset</button>
    </div>
    
    <div id="error" class="error"></div>
    
    <div id="map-container">
      <div class="speed-legend">
        <div class="speed-scale-container">
          <div class="speed-scale-bar"></div>
          <div class="speed-scale-labels">
            <span>0 kn</span>
            <span>40 kn</span>
          </div>
        </div>
      </div>
    </div>
    
    <div class="changes-container">
      <div class="changes-table">
        <h3>Destination Changes</h3>
        <table id="destination-changes" class="table table-striped table-bordered">
          <thead>
            <tr>
              <th>Time</th>
              <th>From</th>
              <th>To</th>
              <th>ETA</th>
            </tr>
          </thead>
          <tbody>
            <!-- Destination changes will be inserted here -->
          </tbody>
        </table>
      </div>
      
      <div class="changes-table">
        <h3>Status Changes</h3>
        <table id="status-changes" class="table table-striped table-bordered">
          <thead>
            <tr>
              <th>Time</th>
              <th>From</th>
              <th>To</th>
            </tr>
          </thead>
          <tbody>
            <!-- Status changes will be inserted here -->
          </tbody>
        </table>
      </div>
    </div>
  </div>

  <!-- Include jQuery -->
  <script src="https://code.jquery.com/jquery-3.5.1.min.js"></script>
  <!-- Include Leaflet JS -->
  <script src="https://unpkg.com/leaflet@1.9.3/dist/leaflet.js"
          integrity="sha256-WBkoXOwTeyKclOHuWtc+i2uENFpDZ9YPdf5Hf+D7ewM=" crossorigin=""></script>
  <script>
    // Get UserID from URL query parameter
    function getQueryParam(name) {
      const urlParams = new URLSearchParams(window.location.search);
      return urlParams.get(name);
    }

    const userID = getQueryParam('UserID');
    let midsMapping = {};
    let shipTypeConfig = {};
    let navStatusMapping = {};

    // Format time difference as a human-readable string
    function formatTimeDifference(timestamp) {
      const now = new Date();
      const date = new Date(timestamp);
      const diffMs = now - date;
      
      const seconds = Math.floor(diffMs / 1000);
      const minutes = Math.floor(seconds / 60);
      const hours = Math.floor(minutes / 60);
      const days = Math.floor(hours / 24);
      
      const remainingHours = hours % 24;
      const remainingMinutes = minutes % 60;
      const remainingSeconds = seconds % 60;
      
      let result = '';
      if (days > 0) result += `${days}d `;
      if (remainingHours > 0 || days > 0) result += `${remainingHours}h `;
      if (remainingMinutes > 0 || remainingHours > 0 || days > 0) result += `${remainingMinutes}m `;
      result += `${remainingSeconds}s ago`;
      
      return result;
    }

    // Load MIDs mapping, ship types, and nav status
    Promise.all([
      fetch('/mids.json').then(r => r.json()),
      fetch('/types.json').then(r => r.json()),
      fetch('/navstatus.json').then(r => r.json())
    ])
    .then(([midsData, typesData, navStatusData]) => {
      midsMapping = midsData;
      shipTypeConfig = typesData;
      navStatusMapping = navStatusData;
      loadVesselData();
    })
    .catch(err => {
      console.error('Error loading data:', err);
      document.getElementById('error').textContent = 'Failed to load reference data.';
      loadVesselData(); // Still try to load vessel data even if data loading fails
    });

    // Helper: given a numeric code and the types.json config, return the category name
    function lookupShipType(code) {
      if (!shipTypeConfig.valueLookup || !code) return code;
      
      const categoryId = shipTypeConfig.valueLookup[code];
      if (categoryId == null) return code;
      
      const category = shipTypeConfig.categories.find(cat => cat.id === categoryId);
      return category ? `${category.name} (ID: ${code})` : code;
    }

    // Helper: look up navigational status text
    function lookupNavStatus(code) {
      if (!navStatusMapping || code === undefined || code === null) return "Unknown";
      return navStatusMapping[code] || "Unknown";
    }

    function loadVesselData() {
      if (!userID) {
        document.getElementById('main-title').textContent = 'Error';
        document.getElementById('error').textContent = 'Missing UserID in URL.';
        return;
      }

      fetch(`/state?UserID=${userID}`, { cache: 'no-store' })
        .then(response => response.json())
        .then(data => {
          // Store AIS class globally for use in fetchVesselHistory
          vesselAisClass = data.AISClass || '';
          console.log('Vessel AIS Class:', vesselAisClass);
          
          // Update page title with vessel name if available
          if (data.Name) {
            document.getElementById('main-title').textContent = `Vessel History: ${data.Name.trim()}`;
          } else {
            document.getElementById('main-title').textContent = `Vessel History: ${userID}`;
          }

          // Get country code from MID (first 3 digits of UserID)
          const mid = userID.toString().substring(0, 3);
          if (midsMapping[mid] && midsMapping[mid][0]) {
            const countryCode = midsMapping[mid][0].toLowerCase();
            const flagUrl = `/flags/${countryCode}.svg`;
            const flagImg = document.getElementById('flag-img');
            flagImg.src = flagUrl;
            flagImg.alt = `${midsMapping[mid][3]} Flag`;
            flagImg.style.display = 'block';
          }

          // Display vessel image if available
          if (data.ImageURL) {
            const vesselImg = document.getElementById('vessel-img');
            vesselImg.src = data.ImageURL;
            vesselImg.style.display = 'block';
          }

          // Create table rows for vessel information
          const leftTableBody = document.querySelector('#vessel-table-left tbody');
          const rightTableBody = document.querySelector('#vessel-table-right tbody');
          leftTableBody.innerHTML = ''; // Clear existing rows
          rightTableBody.innerHTML = ''; // Clear existing rows

          // Fields to display (if available)
          const fieldsToDisplay = [
            { key: 'UserID', label: 'MMSI' },
            { key: 'Name', label: 'Name' },
            { key: 'CallSign', label: 'Call Sign' },
            {
              key: 'ImoNumber',
              label: 'IMO Number',
              // Treat IMO Number = 0 as empty
              checkValue: (val) => val !== undefined && val !== null && val !== '' && val !== 0
            },
            { key: 'AISClass', label: 'AIS Class' },
            { key: 'Type', label: 'Type', format: (val) => lookupShipType(val) },
            { key: 'NavigationalStatus', label: 'Status', format: (val) => lookupNavStatus(val) },
            { key: 'Destination', label: 'Destination' },
            { key: 'MaximumStaticDraught', label: 'Max Draught', format: (val) => val ? `${val} m` : '' },
            {
              key: 'Dimension',
              label: 'Dimension',
              format: (val) => {
                if (!val || typeof val !== 'object') return '';
                const length = (val.A || 0) + (val.B || 0);
                const width = (val.C || 0) + (val.D || 0);
                return `${length}m × ${width}m`;
              }
            },
            {
              key: 'LastUpdated',
              label: 'Last Seen',
              format: (val) => {
                const localTime = new Date(val).toLocaleString();
                const timeDiff = formatTimeDifference(val);
                return `${localTime} (${timeDiff})`;
              }
            }
          ];

          // Add rows for each field if it exists and is not empty
          // Split fields between left and right tables
          const midpoint = Math.ceil(fieldsToDisplay.length / 2);
          
          // Process first half of fields for left table
          fieldsToDisplay.slice(0, midpoint).forEach(field => {
            // Special case for NavigationalStatus which might not exist but we still want to show
            const shouldDisplay = field.key === 'NavigationalStatus' ||
                                 (field.checkValue ? field.checkValue(data[field.key]) :
                                  (data[field.key] !== undefined &&
                                   data[field.key] !== null &&
                                   data[field.key] !== ''));
            
            if (shouldDisplay) {
              const row = document.createElement('tr');
              
              const labelCell = document.createElement('td');
              labelCell.textContent = field.label;
              labelCell.style.fontWeight = 'bold';
              row.appendChild(labelCell);
              
              const valueCell = document.createElement('td');
              // Use formatter function if provided, otherwise use raw value
              const value = data[field.key];
              valueCell.textContent = field.format ? field.format(value) : (value || '');
              row.appendChild(valueCell);
              
              leftTableBody.appendChild(row);
            }
          });
          
          // Process second half of fields for right table
          fieldsToDisplay.slice(midpoint).forEach(field => {
            // Special case for NavigationalStatus which might not exist but we still want to show
            const shouldDisplay = field.key === 'NavigationalStatus' ||
                                 (field.checkValue ? field.checkValue(data[field.key]) :
                                  (data[field.key] !== undefined &&
                                   data[field.key] !== null &&
                                   data[field.key] !== ''));
            
            if (shouldDisplay) {
              const row = document.createElement('tr');
              
              const labelCell = document.createElement('td');
              labelCell.textContent = field.label;
              labelCell.style.fontWeight = 'bold';
              row.appendChild(labelCell);
              
              const valueCell = document.createElement('td');
              // Use formatter function if provided, otherwise use raw value
              const value = data[field.key];
              valueCell.textContent = field.format ? field.format(value) : (value || '');
              row.appendChild(valueCell);
              
              rightTableBody.appendChild(row);
            }
          });

          // If no data was added to either table
          if (leftTableBody.children.length === 0 && rightTableBody.children.length === 0) {
            const row = document.createElement('tr');
            const cell = document.createElement('td');
            cell.colSpan = 2;
            cell.textContent = 'No vessel information available';
            row.appendChild(cell);
            leftTableBody.appendChild(row);
          }
        })
        .catch(err => {
          console.error('Error fetching vessel data:', err);
          document.getElementById('error').textContent = 'Failed to load vessel data.';
        });
    }

    // Initialize date selectors with values from URL parameters or default to last 24 hours
    function initDateSelectors() {
      // Try to get start and end from URL parameters
      const startParam = getQueryParam('start');
      const endParam = getQueryParam('end');
      
      let end, start;
      
      // If end parameter exists and is valid, use it; otherwise use current time
      if (endParam && !isNaN(new Date(endParam).getTime())) {
        end = new Date(endParam);
      } else {
        end = new Date();
      }
      
      // If start parameter exists and is valid, use it; otherwise use 24 hours before end
      if (startParam && !isNaN(new Date(startParam).getTime())) {
        start = new Date(startParam);
      } else {
        start = new Date(end);
        start.setDate(start.getDate() - 1); // 1 day ago
      }
      
      document.getElementById('end').value = end.toISOString().slice(0, 16);
      document.getElementById('start').value = start.toISOString().slice(0, 16);
    }

    // Initialize map
    let map = null;
    let mapLayerGroup = null;

    function initMap() {
      if (!map) {
        map = L.map('map-container').setView([0, 0], 2);
        L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
          attribution: '&copy; OpenStreetMap contributors'
        }).addTo(map);
        mapLayerGroup = L.layerGroup().addTo(map);
      }
    }

    // Fetch vessel history data
    async function fetchVesselHistory() {
      const startInput = document.getElementById('start');
      const endInput = document.getElementById('end');
      const s = startInput.value, e = endInput.value;
      
      if (!s || !e) {
        alert('Please select From and To dates.');
        return null;
      }

      // Determine message types based on AIS Class
      let positionMessageTypes = [];
      let staticMessageTypes = [];
      
      if (vesselAisClass === 'A') {
        positionMessageTypes = ['1', '2', '3']; // Class A position messages
        staticMessageTypes = ['5'];             // Class A static messages
      } else if (vesselAisClass === 'B') {
        positionMessageTypes = ['18', '19'];    // Class B position messages
        staticMessageTypes = ['24'];            // Class B static messages
      } else {
        // Default to both types if AIS class is unknown
        positionMessageTypes = ['1', '2', '3', '18', '19']; // All position messages
        staticMessageTypes = ['5', '24'];                   // All static messages
      }

      const startTime = new Date(s).toISOString();
      const endTime = new Date(e).toISOString();
      const limit = 2000;

      try {
        // Make two separate calls for position and static messages
        const [positionResponse, staticResponse] = await Promise.all([
          // Position messages call
          fetch(`/latestmessages?${new URLSearchParams({
            UserID: userID,
            MessageID: positionMessageTypes.join(','),
            start: startTime,
            end: endTime,
            limit: limit
          })}`, {cache: 'no-store'}),
          
          // Static messages call
          fetch(`/latestmessages?${new URLSearchParams({
            UserID: userID,
            MessageID: staticMessageTypes.join(','),
            start: startTime,
            end: endTime,
            limit: limit
          })}`, {cache: 'no-store'})
        ]);

        // Parse both responses
        const positionData = await positionResponse.json();
        const staticData = await staticResponse.json();
        
        // Check if either response has the same number of results as the limit
        const positionCount = positionData.length;
        const staticCount = staticData.length;
        const combinedResults = [...positionData, ...staticData];
        
        // If either count matches the limit, show a warning
        if (positionCount === limit || staticCount === limit) {
          const warningDiv = document.getElementById('error');
          warningDiv.textContent = `Warning: Some data may be missing. ${positionCount === limit ? 'Position' : ''} ${positionCount === limit && staticCount === limit ? 'and' : ''} ${staticCount === limit ? 'Static' : ''} data reached the limit of ${limit} records. Try reducing the time range.`;
          warningDiv.style.display = 'block';
        } else {
          // Clear any previous warnings
          document.getElementById('error').textContent = '';
        }
        
        return combinedResults;
      } catch (err) {
        console.error('Error fetching vessel history:', err);
        alert('Failed to fetch vessel history data.');
        return null;
      }
    }

    // Function to get color based on speed
    function getColorForSpeed(speed) {
      const maxSpeed = 40;  // maximum expected speed in knots
      // Clamp the speed value between 0 and maxSpeed
      const clampedSpeed = Math.max(0, Math.min(maxSpeed, speed));
      // Compute a ratio (0 = 0 knots, 1 = maxSpeed)
      const ratio = clampedSpeed / maxSpeed;
      // Calculate hue: 120 (green) at 0 knots to 0 (red) at maxSpeed knots.
      const hue = (1 - ratio) * 120;
      // Return a string with full saturation and 50% lightness.
      return `hsl(${hue}, 100%, 50%)`;
    }

    // Create a colored track with segments colored by speed
    function createColoredTrack(points) {
      const segments = [];
      // Loop through the points to create segments
      for (let i = 0; i < points.length - 1; i++) {
        const pt1 = points[i];
        const pt2 = points[i + 1];
        // Use the speed of the first point for the color
        const speed = pt1.data.Sog != null ? pt1.data.Sog : 0;
        const color = getColorForSpeed(speed);
        // Create a polyline segment with this color
        const segment = L.polyline([[pt1.lat, pt1.lng], [pt2.lat, pt2.lng]], {
          color: color,
          weight: 3,
          opacity: 0.8
        });
        segments.push(segment);
      }
      // Group the segments so they can be treated as one layer
      return L.layerGroup(segments);
    }

    // Display vessel track on map
    function displayVesselTrack(historyData) {
      if (!historyData || !historyData.length) {
        return;
      }

      // Clear existing layers
      mapLayerGroup.clearLayers();
      
      // Prepare points with valid coordinates
      const pts = historyData
        .filter(r => {
          const flat = flatten(r.Packet);
          return flat.Latitude != null && flat.Longitude != null &&
                 !isNaN(flat.Latitude) && !isNaN(flat.Longitude);
        })
        .map(r => {
          const flat = flatten(r.Packet);
          return {
            lat: flat.Latitude,
            lng: flat.Longitude,
            timestamp: r.Timestamp,
            record: r,
            data: flat
          };
        });

      if (!pts.length) {
        console.log('No valid position data found');
        return;
      }
      
      // Sort points by timestamp (newest first)
      pts.sort((a, b) => new Date(b.timestamp) - new Date(a.timestamp));
      
      // Create colored track based on speed
      const coloredTrack = createColoredTrack(pts);
      coloredTrack.addTo(mapLayerGroup);
      
      // Tooltip options
      const tooltipOpts = {
        direction: 'top',
        offset: [0, -6],
        permanent: false,
        sticky: true
      };
      
      // Helper to format one point's tooltip HTML
      function makeTooltipHTML(pt) {
        const timestamp = new Date(pt.timestamp).toLocaleString();
        let html = `<strong>${timestamp}</strong><br/>`;
        html += `<strong>Latitude:</strong> ${pt.lat.toFixed(6)}<br/>`;
        html += `<strong>Longitude:</strong> ${pt.lng.toFixed(6)}<br/>`;
        
        // Add other interesting fields if available
        const fields = ['Sog', 'Cog', 'TrueHeading', 'NavigationalStatus', 'Destination'];
        fields.forEach(field => {
          if (pt.data[field] != null) {
            let value = pt.data[field];
            if (field === 'NavigationalStatus' && navStatusMapping[value]) {
              value = navStatusMapping[value];
            }
            html += `<strong>${field}:</strong> ${value}<br/>`;
          }
        });
        
        return html;
      }
      
      // Add tooltips to each segment in the colored track
      coloredTrack.eachLayer(segment => {
        segment.bindTooltip('', tooltipOpts);
        
        segment.on('mousemove', e => {
          // Find the nearest point to where the mouse is
          let minDist = Infinity, nearestPoint = null;
          pts.forEach(pt => {
            const ptLatLng = L.latLng(pt.lat, pt.lng);
            const d = e.latlng.distanceTo(ptLatLng);
            if (d < minDist) {
              minDist = d;
              nearestPoint = pt;
            }
          });
          
          if (nearestPoint) {
            const html = makeTooltipHTML(nearestPoint);
            segment.setTooltipContent(html);
            segment.openTooltip(e.latlng);
          }
        });
        
        segment.on('mouseout', () => segment.closeTooltip());
      });
      
      // Add markers at the first and last points with tooltips
      const first = pts[pts.length - 1]; // Oldest point
      const last = pts[0]; // Newest point
      
      const startMarker = L.marker([first.lat, first.lng], {
        icon: L.divIcon({
          className: 'start-marker',
          html: '🔵',
          iconSize: [20, 20],
          iconAnchor: [10, 10]
        })
      }).addTo(mapLayerGroup);
      startMarker.bindTooltip('Start: ' + new Date(first.timestamp).toLocaleString(), tooltipOpts);
      
      const endMarker = L.marker([last.lat, last.lng], {
        icon: L.divIcon({
          className: 'end-marker',
          html: '🔴',
          iconSize: [20, 20],
          iconAnchor: [10, 10]
        })
      }).addTo(mapLayerGroup);
      endMarker.bindTooltip('End: ' + new Date(last.timestamp).toLocaleString(), tooltipOpts);
      
      // Fit map to data
      const latlngs = pts.map(p => [p.lat, p.lng]);
      map.fitBounds(L.latLngBounds(latlngs).pad(0.2));
    }

    // Track changes in destination and navigational status
    function trackChanges(historyData) {
      if (!historyData || !historyData.length) {
        return;
      }
      
      // Sort by timestamp (oldest first)
      const sortedData = [...historyData].sort((a, b) =>
        new Date(a.Timestamp) - new Date(b.Timestamp)
      );
      
      const destinationChanges = [];
      const statusChanges = [];
      
      let lastDestination = null;
      let lastStatus = null;
      let firstRecord = null;
      let firstStaticRecord = null;
      let firstPositionRecord = null;
      
      // Find the first record with static data (containing Destination field)
      // and the first record with position data (containing NavigationalStatus field)
      for (const record of sortedData) {
        const flat = flatten(record.Packet);
        
        // Store the first record for general use
        if (!firstRecord) {
          firstRecord = record;
        }
        
        // Find the first record with Destination field (static message)
        if (!firstStaticRecord && flat.Destination !== undefined) {
          firstStaticRecord = record;
        }
        
        // Find the first record with NavigationalStatus field (position message)
        if (!firstPositionRecord &&
            (record.MessageID === 1 || record.MessageID === 2 || record.MessageID === 3 ||
             record.MessageID === 18 || record.MessageID === 19) &&
            record.Packet && record.Packet.NavigationalStatus !== undefined) {
          firstPositionRecord = record;
          console.log('Found position record with NavigationalStatus:', record);
        }
        
        // If we found both types of records, we can break early
        if (firstStaticRecord && firstPositionRecord) {
          break;
        }
      }
      
      // If we didn't find a record with Destination, use the first record
      if (!firstStaticRecord && sortedData.length > 0) {
        firstStaticRecord = firstRecord;
      }
      
      // If we didn't find a position record, use the first record
      if (!firstPositionRecord && sortedData.length > 0) {
        firstPositionRecord = firstRecord;
      }
      
      sortedData.forEach(record => {
        const flat = flatten(record.Packet);
        const timestamp = record.Timestamp;
        
        // Track destination changes
        if (flat.Destination !== undefined) {
          const currentDestination = flat.Destination || '';
          if (lastDestination !== null && currentDestination !== lastDestination) {
            // Include ETA if available
            let etaStr = '';
            // Access ETA directly from the original packet, not the flattened structure
            if (record.Packet && record.Packet.Eta) {
              etaStr = formatEta(record.Packet.Eta);
            }
            
            destinationChanges.push({
              timestamp,
              from: lastDestination,
              to: currentDestination,
              eta: etaStr
            });
          }
          lastDestination = currentDestination;
        }
        
        // Track navigational status changes
        if (flat.NavigationalStatus !== undefined) {
          const currentStatus = flat.NavigationalStatus;
          if (lastStatus !== null && currentStatus !== lastStatus) {
            statusChanges.push({
              timestamp,
              from: lastStatus,
              to: currentStatus
            });
          }
          lastStatus = currentStatus;
        }
      });
      
      // Display destination changes
      const destTable = document.querySelector('#destination-changes tbody');
      destTable.innerHTML = '';
      
      if (destinationChanges.length > 0) {
        destinationChanges.forEach(change => {
          const row = document.createElement('tr');
          
          const timeCell = document.createElement('td');
          timeCell.textContent = new Date(change.timestamp).toLocaleString();
          row.appendChild(timeCell);
          
          const fromCell = document.createElement('td');
          fromCell.textContent = change.from || '(empty)';
          row.appendChild(fromCell);
          
          const toCell = document.createElement('td');
          toCell.textContent = change.to || '(empty)';
          row.appendChild(toCell);
          
          // Add ETA cell
          const etaCell = document.createElement('td');
          etaCell.textContent = change.eta || '';
          row.appendChild(etaCell);
          
          destTable.appendChild(row);
        });
      } else if (firstStaticRecord) {
        // If no changes but we have static data, show the current value
        const flat = flatten(firstStaticRecord.Packet);
        if (flat.Destination !== undefined) {
          const row = document.createElement('tr');
          
          const timeCell = document.createElement('td');
          timeCell.textContent = new Date(firstStaticRecord.Timestamp).toLocaleString();
          row.appendChild(timeCell);
          
          const fromCell = document.createElement('td');
          fromCell.textContent = '(initial value)';
          row.appendChild(fromCell);
          
          const toCell = document.createElement('td');
          toCell.textContent = flat.Destination || '(empty)';
          row.appendChild(toCell);
          
          // Add ETA cell
          const etaCell = document.createElement('td');
          // Access ETA directly from the original packet, not the flattened structure
          if (firstStaticRecord.Packet && firstStaticRecord.Packet.Eta) {
            etaCell.textContent = formatEta(firstStaticRecord.Packet.Eta);
          }
          row.appendChild(etaCell);
          
          destTable.appendChild(row);
        } else {
          const row = document.createElement('tr');
          const cell = document.createElement('td');
          cell.colSpan = 4;
          cell.className = 'no-changes';
          cell.textContent = 'No destination information available';
          row.appendChild(cell);
          destTable.appendChild(row);
        }
      } else {
        const row = document.createElement('tr');
        const cell = document.createElement('td');
        cell.colSpan = 4;
        cell.className = 'no-changes';
        cell.textContent = 'No destination changes detected';
        row.appendChild(cell);
        destTable.appendChild(row);
      }
      
      // Display navigational status changes
      const statusTable = document.querySelector('#status-changes tbody');
      statusTable.innerHTML = '';
      
      if (statusChanges.length > 0) {
        statusChanges.forEach(change => {
          const row = document.createElement('tr');
          
          const timeCell = document.createElement('td');
          timeCell.textContent = new Date(change.timestamp).toLocaleString();
          row.appendChild(timeCell);
          
          const fromCell = document.createElement('td');
          fromCell.textContent = navStatusMapping[change.from] || change.from || '(unknown)';
          row.appendChild(fromCell);
          
          const toCell = document.createElement('td');
          toCell.textContent = navStatusMapping[change.to] || change.to || '(unknown)';
          row.appendChild(toCell);
          
          statusTable.appendChild(row);
        });
      } else if (firstPositionRecord) {
        // If no changes but we have position data, show the current value
        const row = document.createElement('tr');
        
        const timeCell = document.createElement('td');
        timeCell.textContent = new Date(firstPositionRecord.Timestamp).toLocaleString();
        row.appendChild(timeCell);
        
        const fromCell = document.createElement('td');
        fromCell.textContent = '(initial value)';
        row.appendChild(fromCell);
        
        const toCell = document.createElement('td');
        
        // Get NavigationalStatus directly from the position record
        const navStatus = firstPositionRecord.Packet.NavigationalStatus;
        console.log('Position record:', firstPositionRecord);
        console.log('NavigationalStatus:', navStatus);
        console.log('Mapped value:', navStatusMapping[navStatus]);
        
        // Convert the status code to a readable string
        if (navStatus === 0) {
          // Special case for 0, which is "Using Engine"
          toCell.textContent = navStatusMapping[0] || "Using Engine";
        } else if (navStatus !== undefined) {
          toCell.textContent = navStatusMapping[navStatus] || `${navStatus}`;
        } else {
          toCell.textContent = '(unknown)';
        }
        row.appendChild(toCell);
        
        statusTable.appendChild(row);
      } else {
        const row = document.createElement('tr');
        const cell = document.createElement('td');
        cell.colSpan = 3;
        cell.className = 'no-changes';
        cell.textContent = 'No navigational status changes detected';
        row.appendChild(cell);
        statusTable.appendChild(row);
      }
    }

    // Format ETA from object to readable string
    function formatEta(eta) {
      if (!eta || typeof eta !== 'object') return '';
      
      const { Day, Month, Hour, Minute } = eta;
      if (Day === undefined || Month === undefined) return '';
      
      // Month is 1-based in the data
      const monthNames = [
        'January', 'February', 'March', 'April', 'May', 'June',
        'July', 'August', 'September', 'October', 'November', 'December'
      ];
      
      const monthName = monthNames[Month - 1] || '';
      let timeStr = '';
      
      if (Hour !== undefined && Minute !== undefined) {
        // Pad with leading zeros if needed
        const hourStr = Hour.toString().padStart(2, '0');
        const minStr = Minute.toString().padStart(2, '0');
        timeStr = ` ${hourStr}:${minStr}`;
      }
      
      return `${Day} ${monthName}${timeStr}`;
    }

    // Helper function to flatten nested objects
    function flatten(obj, prefix = '', res = {}) {
      for (const [k, v] of Object.entries(obj || {})) {
        const key = prefix ? `${prefix}.${k}` : k;
        if (v != null && typeof v === 'object' && !Array.isArray(v)) {
          flatten(v, key, res);
        } else {
          res[key] = v;
        }
      }
      return res;
    }

    // Store vessel AIS class globally
    let vesselAisClass = '';

    // Initialize the page
    document.addEventListener('DOMContentLoaded', () => {
      initDateSelectors();
      initMap();
      
      // Automatically load history data with default 1-day range
      setTimeout(async () => {
        const historyData = await fetchVesselHistory();
        if (historyData) {
          displayVesselTrack(historyData);
          trackChanges(historyData);
        }
      }, 1000); // Small delay to ensure vessel data is loaded first
      
      // Set up event listeners
      document.getElementById('apply-btn').addEventListener('click', async () => {
        // Update URL with current date range
        const startInput = document.getElementById('start');
        const endInput = document.getElementById('end');
        
        if (startInput.value && endInput.value) {
          // Create a new URL object based on the current URL
          const url = new URL(window.location.href);
          
          // Update or add the start and end parameters
          url.searchParams.set('start', new Date(startInput.value).toISOString());
          url.searchParams.set('end', new Date(endInput.value).toISOString());
          
          // Update the browser history without reloading the page
          window.history.replaceState({}, '', url);
        }
        
        const historyData = await fetchVesselHistory();
        if (historyData) {
          displayVesselTrack(historyData);
          trackChanges(historyData);
        }
      });
      
      document.getElementById('reset-btn').addEventListener('click', () => {
        initDateSelectors();
        
        // Clear map
        if (mapLayerGroup) {
          mapLayerGroup.clearLayers();
        }
        
        // Clear tables
        document.querySelector('#destination-changes tbody').innerHTML = '';
        document.querySelector('#status-changes tbody').innerHTML = '';
      });
    });

    // Store vessel AIS class globally - moved to loadVesselData function
  </script>
</body>
</html>