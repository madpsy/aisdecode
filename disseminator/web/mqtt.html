<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>MQTT</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/mqtt/4.3.7/mqtt.min.js"></script>
    <style>
        html, body {
            height: 100vh;
            margin: 0;
            padding: 0;
            overflow: hidden;
        }
        body {
            font-family: Arial, sans-serif;
            padding: 20px;
            line-height: 1.6;
            box-sizing: border-box;
            display: flex;
            flex-direction: column;
        }
        #messages {
            border: 1px solid #ccc;
            padding: 10px;
            flex: 1;
            overflow-y: auto;
            margin-top: 20px;
            font-family: monospace;
            background-color: #f5f5f5;
        }
        .message {
            border-bottom: 1px solid #eee;
            padding: 5px 0;
        }
        .message:nth-child(odd) {
            background-color: #f9f9f9;
        }
        .timestamp {
            color: #666;
            font-size: 0.8em;
            display: inline-block;
            margin-right: 10px;
            min-width: 80px;
            vertical-align: top;
        }
        .message-content {
            display: inline-block;
            width: calc(100% - 100px); /* Adjust based on timestamp width + margin */
            word-break: break-all; /* Break words at any character */
        }
        .json-content {
            white-space: pre; /* Preserve whitespace for JSON formatting */
            font-family: monospace;
        }
        .status {
            margin-bottom: 10px;
            padding: 10px;
            border-radius: 4px;
        }
        .connected {
            background-color: #d4edda;
            color: #155724;
        }
        .disconnected {
            background-color: #f8d7da;
            color: #721c24;
        }
        .connecting {
            background-color: #fff3cd;
            color: #856404;
        }
        h1 {
            color: #333;
            margin-top: 0;
        }
        .controls {
            margin: 20px 0;
            display: flex;
            align-items: center;
        }
        .radio-group {
            margin-left: 15px;
            display: flex;
            align-items: center;
        }
        .radio-group label {
            margin-right: 10px;
            display: inline-flex;
            align-items: center;
            cursor: pointer;
        }
        .radio-group input[type="radio"] {
            margin: 0;
            margin-right: 2px;
            vertical-align: middle;
        }
        button {
            padding: 8px 16px;
            background-color: #4CAF50;
            color: white;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            margin-right: 5px;
        }
        button:hover {
            background-color: #45a049;
        }
        #clearMessages {
            background-color: #f44336; /* Red */
        }
        #clearMessages:hover {
            background-color: #d32f2f; /* Darker red */
        }
        .paused {
            background-color: #2196F3 !important; /* Blue */
        }
        .paused:hover {
            background-color: #0b7dda !important; /* Darker blue */
        }
        input {
            padding: 8px;
            border: 1px solid #ddd;
            border-radius: 4px;
            width: 100px;
        }
    </style>
</head>
<body>
    <h1>MQTT</h1>
    
    <div id="statusDisplay" class="status connecting">Connecting to MQTT broker...</div>
    
    <div class="controls">
        <button id="clearMessages">Clear Messages</button>
        <button id="pauseMessages">Pause</button>
        <div class="radio-group">
            <label><input type="radio" name="displayMode" value="sentences" checked>Sentences</label>
            <label><input type="radio" name="displayMode" value="decoded">Decoded</label>
        </div>
    </div>
    
    <div id="messages"></div>

    <script>
        // Get receiver ID from query parameter or default to 0
        const urlParams = new URLSearchParams(window.location.search);
        let receiverId = parseInt(urlParams.get('receiver') || '0', 10);
        
        // MQTT connection settings
        let mqttHost = '';
        let mqttPort = 0;
        let mqttTopic = '';
        let client = null;
        let currentSubscription = null;
        let receiversMap = {}; // Map of receiver IDs to receiver names
        let isPaused = false; // Track if message updates are paused
        let displayMode = 'sentences'; // Default display mode
        
        // Fetch receivers data from the server
        async function fetchReceivers() {
            try {
                const response = await fetch('/receivers');
                if (!response.ok) {
                    throw new Error(`HTTP error! status: ${response.status}`);
                }
                const receivers = await response.json();
                
                // Create a map of receiver IDs to names
                receivers.forEach(receiver => {
                    receiversMap[receiver.id] = receiver.name;
                });
                
                console.log('Fetched receivers:', receiversMap);
                
                // After fetching receivers, get MQTT config
                fetchMQTTConfig();
            } catch (error) {
                updateStatus('disconnected', `Failed to fetch receivers: ${error.message}`);
                console.error('Error fetching receivers:', error);
            }
        }
        
        // Fetch MQTT configuration from the server
        async function fetchMQTTConfig() {
            try {
                const response = await fetch('/mqtt');
                if (!response.ok) {
                    throw new Error(`HTTP error! status: ${response.status}`);
                }
                const config = await response.json();
                mqttHost = config.mqtt_host;
                mqttPort = config.mqtt_port;
                mqttTopic = config.mqtt_topic;
                updateStatus('connecting', `Fetched MQTT config: ${mqttHost}:${mqttPort}`);
                
                // Now that we have the config, connect to MQTT
                connectMQTT();
            } catch (error) {
                updateStatus('disconnected', `Failed to fetch MQTT config: ${error.message}`);
                console.error('Error fetching MQTT config:', error);
            }
        }
        
        // Message display element
        const messagesDiv = document.getElementById('messages');
        const statusDisplay = document.getElementById('statusDisplay');
        
        // Connect to MQTT broker
        function connectMQTT() {
            updateStatus('connecting', `Connecting to MQTT broker at ${mqttHost}:${mqttPort}...`);
            
            // Create MQTT client
            const serverUrl = `wss://${mqttHost}:${mqttPort}`;
            client = mqtt.connect(serverUrl, {
                clientId: 'web_client_' + Math.random().toString(16).substr(2, 8),
                clean: true
            });
            
            // Handle connection events
            client.on('connect', function() {
                updateStatus('connected', 'Connected to MQTT broker');
                subscribeToReceiver(receiverId);
            });
            
            client.on('error', function(error) {
                updateStatus('disconnected', 'Connection error: ' + error.message);
                console.error('MQTT error:', error);
            });
            
            client.on('offline', function() {
                updateStatus('disconnected', 'Disconnected from MQTT broker');
            });
            
            client.on('message', function(topic, message) {
                try {
                    const payload = JSON.parse(message.toString());
                    
                    if (displayMode === 'sentences' && payload.raw_sentence) {
                        addMessage(payload.raw_sentence, payload.timestamp, false);
                    } else if (displayMode === 'decoded' && payload.message && payload.message.packet) {
                        // Pretty print the packet JSON
                        addMessage(JSON.stringify(payload.message.packet, null, 2), payload.timestamp, true);
                    }
                } catch (e) {
                    console.error('Error parsing message:', e);
                    addMessage('Error parsing message: ' + e.message);
                }
            });
        }
        
        // Subscribe to messages for a specific receiver
        function subscribeToReceiver(id) {
            if (!client || !client.connected) {
                updateStatus('disconnected', 'Not connected to MQTT broker');
                return;
            }
            
            // Unsubscribe from previous topic if any
            if (currentSubscription) {
                client.unsubscribe(currentSubscription);
            }
            
            // Subscribe to all messages for this receiver ID
            // The + wildcards match any shard_id, user_id, and message_id
            const topic = `${mqttTopic}/+/+/${id}/+/message`;
            client.subscribe(topic, function(err) {
                if (err) {
                    updateStatus('disconnected', 'Failed to subscribe: ' + err.message);
                    console.error('Subscription error:', err);
                } else {
                    const receiverName = receiversMap[id] || `Unknown (ID: ${id})`;
                    updateStatus('connected', `Subscribed to receiver: ${receiverName}`);
                    currentSubscription = topic;
                    
                    // Update URL without reloading the page
                    const url = new URL(window.location);
                    url.searchParams.set('receiver', id);
                    window.history.pushState({}, '', url);
                }
            });
        }
        
        // Add a message to the display
        function addMessage(message, timestamp = null, isJson = false) {
            // Skip adding messages if paused
            if (isPaused) return;
            
            const messageElement = document.createElement('div');
            messageElement.className = 'message';
            
            if (timestamp) {
                const timeElement = document.createElement('span');
                timeElement.className = 'timestamp';
                timeElement.textContent = new Date(timestamp).toLocaleTimeString();
                messageElement.appendChild(timeElement);
            }
            
            const contentElement = document.createElement('span');
            contentElement.className = isJson ? 'message-content json-content' : 'message-content';
            contentElement.textContent = message;
            messageElement.appendChild(contentElement);
            
            // Insert at the beginning (newest at top)
            messagesDiv.insertBefore(messageElement, messagesDiv.firstChild);
            messagesDiv.scrollTop = 0;
        }
        
        // Update connection status display
        function updateStatus(status, message) {
            statusDisplay.className = `status ${status}`;
            statusDisplay.textContent = message;
        }
        
        // Event listeners
        document.getElementById('clearMessages').addEventListener('click', function() {
            messagesDiv.innerHTML = '';
        });
        
        // Pause/Resume button functionality
        const pauseButton = document.getElementById('pauseMessages');
        pauseButton.addEventListener('click', function() {
            isPaused = !isPaused;
            pauseButton.textContent = isPaused ? 'Resume' : 'Pause';
            
            // Toggle the blue color class when paused
            if (isPaused) {
                pauseButton.classList.add('paused');
            } else {
                pauseButton.classList.remove('paused');
            }
        });
        
        // Radio button event listeners
        document.querySelectorAll('input[name="displayMode"]').forEach(radio => {
            radio.addEventListener('change', function() {
                displayMode = this.value;
                // Clear messages when switching display modes
                messagesDiv.innerHTML = '';
            });
        });
        
        // Initialize by fetching receivers first, then MQTT config
        fetchReceivers();
    </script>
</body>
</html>