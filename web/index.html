<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>AIS Tracker</title>
    <!-- Leaflet CSS (from CDN, without integrity) -->
    <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.3/dist/leaflet.css" crossorigin="" />
    <style>
        html, body, #map {
          height: 100%;
          margin: 0;
          padding: 0;
        }
        .popup-content {
          font-family: Arial, sans-serif;
          font-size: 14px;
          line-height: 1.3;
        }
        .boat-icon {
          background: transparent;
          border: none;
          transition: transform 0.5s ease-out;
        }
	.leaflet-div-icon.non-vessel-icon {
	  width: 30px !important;
	  height: 30px !important;
	  padding: 0 !important;
	  margin: 0 !important;
	  text-align: center;
	  line-height: 30px;
	}
	#vessel-detail a {
	  text-decoration: none;
	}
	.port-marker-tooltip {
	  border: none;
	  box-shadow: none;
	  background: white;
	  padding: 2px 4px;
	  z-index: 1100;
	}	
        /* CSS for the enlargement animation */
        .boat-icon.enlarge {
          transform: scale(1.5);
        }
        .vessel-tooltip {
          font-family: Arial, sans-serif;
          font-size: 10px;
          font-weight: bold;
          background: rgba(255, 255, 255, 0.9);
          padding: 2px 4px;
          border: 1px solid #aaa;
          border-radius: 3px;
          cursor: pointer;
        }
        .receiver-tooltip {
          font-family: Arial, sans-serif;
          font-size: 10px;
          font-weight: bold;
          background: rgba(255, 255, 255, 0.9);
          padding: 2px 4px;
          border: 1px solid #aaa;
          border-radius: 3px;
          cursor: pointer;
        }
        /* Style for the Clear History button */
        #clear-history {
          position: absolute;
          bottom: 25px;
          left: 10px;
          background: yellow;
          border: none;
          padding: 5px 5px;
          cursor: pointer;
          font-weight: bold;
          z-index: 1000;
        }
        /* Style for the known vessels overlay (bottom left) */
        #vessel-overlay {
          position: absolute;
          bottom: 85px;
          left: 10px;
          background: rgba(255, 255, 255, 0.95);
          border: 1px solid #ccc;
          border-radius: 5px;
          padding: 5px;
          height: 300px;
          width: 150px;
          overflow-y: auto;
          z-index: 1000;
          font-family: Arial, sans-serif;
          font-size: 13px;
          line-height: 1.4;
        }
        #vessel-overlay h4 {
          margin: 5px 0;
          text-align: center;
          font-size: 14px;
        }
        /* Style for the filter input box */
        #vessel-filter {
          width: 90%;
          margin: 5px auto;
          display: block;
          padding: 3px;
          font-size: 13px;
        }
        #vessel-overlay .vessel-entry {
          border-bottom: 1px solid #eee;
          padding: 4px 0;
          cursor: pointer;
        }
        #vessel-overlay .vessel-entry:last-child {
          border-bottom: none;
        }
        #vessel-overlay .vessel-name {
          font-weight: bold;
          text-decoration: underline;
        }
        #vessel-overlay .vessel-callsign {
          color: #555;
        }
        #vessel-overlay .vessel-timestamp {
          color: #888;
          font-size: 12px;
        }
        /* New Style for the vessel detail overlay (bottom right) */
        #vessel-detail {
          position: absolute;
          bottom: 80px;
          right: 10px;
          background: rgba(255, 255, 255, 0.95);
          border: 1px solid #ccc;
          border-radius: 5px;
          padding: 5px;
          max-height: 300px;
          min-width: 200px;
	  max-width: 200px;
          width: auto;
          overflow-y: auto;
          z-index: 1500;
          font-family: Arial, sans-serif;
          font-size: 13px;
          line-height: 1.4;
          display: none;
          white-space: nowrap;
        }
        #vessel-detail h4 {
          margin: 5px 0;
          text-align: center;
          font-size: 14px;
        }
        /* Style for the controls overlay */
        #controls {
          position: absolute;
          top: 10px;
          right: 10px;
          background: rgba(255, 255, 255, 0.95);
          border: 1px solid #ccc;
          border-radius: 5px;
          padding: 10px;
          z-index: 1000;
          font-family: Arial, sans-serif;
          font-size: 14px;
        }
        #controls label {
          cursor: pointer;
          display: block;
          margin-bottom: 5px;
        }
        /* Styles for the new toggle buttons */
        .toggle-button {
          position: absolute;
          background: #f0f0f0;
          border: 1px solid #ccc;
          border-radius: 3px;
          padding: 3px 6px;
          font-family: Arial, sans-serif;
          font-size: 13px;
          cursor: pointer;
          z-index: 1100;
        }
        #toggle-known-overlay {
          bottom: 60px;
          left: 10px;
        }
        #toggle-detail-overlay {
          bottom: 50px;
          right: 10px;
          display: none;
        }
        /* Live Logs button styling (positioned to the left of Show/Hide Details) */
        #live-logs {
          position: absolute;
          bottom: 50px;
          right: 100px;
          background: #f0f0f0;
          border: 1px solid #ccc;
          border-radius: 3px;
          padding: 3px 6px;
          font-family: Arial, sans-serif;
          font-size: 13px;
          cursor: pointer;
          z-index: 1100;
          display: none;
        }
        /* Live Logs overlay styling */
        #live-logs-overlay {
          display: none;
          position: absolute;
          top: 100px;
          left: 50px;
          background: rgba(255,255,255,0.95);
          border: 1px solid #ccc;
          border-radius: 5px;
          padding: 10px;
          width: 290px;
          max-height: 400px;
          overflow-y: auto;
          z-index: 1200;
        }
        #live-logs-header {
          cursor: move;
          font-weight: bold;
          margin-bottom: 5px;
        }
        #live-logs-header button {
          float: right;
          cursor: pointer;
        }
        .log-entry {
          border-bottom: 1px solid #eee;
          padding: 5px 0;
          font-family: monospace;
          font-size: 12px;
        }
        .log-entry:last-child {
          border-bottom: none;
        }
        .log-field {
          font-weight: bold;
        }
        #stats-button {
          position: absolute;
          bottom: 50px;
          right: 180px;  /* Adjust as needed so it appears left of the "Messages" button */
          background: #f0f0f0;
          border: 1px solid #ccc;
          border-radius: 3px;
          padding: 3px 6px;
          font-family: Arial, sans-serif;
          font-size: 13px;
          cursor: pointer;
          z-index: 1100;
          display: none;  /* Hidden by default */
    }

#vessel-legend {
  font-family: Arial, sans-serif;
  font-size: 14px;
  padding: 5px;
  background-color: rgba(255, 255, 255, 0.95);
  border: 1px solid #ccc;
  border-radius: 5px;
  width: 150px;
  height: 200px;
  overflow-y: auto;
  z-index: 1000;
}

#vessel-legend .legend-item {
  display: flex;
  align-items: center;
  margin: 4px 0;  
  padding: 0;
  line-height: 1;
}

#vessel-legend .legend-item svg {
  margin-right: 5px; 
  width: 20px;   
  height: 20px;
}

#vessel-legend .legend-item span {
  flex: 1;
  font-size: 14px;
  line-height: 1;
}


#slider-container {
  position: absolute;
  bottom: 20px;  
  left: 50%;
  transform: translateX(-50%);
  background: rgba(255, 255, 255, 0.8);
  border-radius: 5px;
  padding: 0px;
  z-index: 1000;
  font-family: Arial, sans-serif;
  font-size: 12px;
  text-align: center;
}

#slider-container label {
  display: block;
  margin: 0 5px 0 0;
}

#slider-container input {
  width: 100%;
  margin: 0 10px 0 0;
}
#github-link {
  position: absolute;
  bottom: 5px; /* Adjust as needed */
  left: 50%;
  transform: translateX(-50%);
  color: black;
  text-decoration: none;
  font-size: 12px;
  z-index: 1500;
  font-weight: bold;
}
    </style>
</head>

<body>
    <div id="map"></div>
    <div id="latlong-display" style="
	    position: absolute;
	    top: 10px;
	    left: 50%;
	    transform: translateX(-50%);
	    background: rgba(255, 255, 255, 0.8);
	    padding: 5px 10px;
	    border-radius: 5px;
	    z-index: 1100;
	    font-family: Arial, sans-serif;
	    font-size: 14px;
	">
        0, 0
    </div>
    <div id="nm-scale" style="
    position: absolute;
    top: 40px;
    left: 50%;
    transform: translateX(-50%);
    background: rgba(255, 255, 255, 0.8);
    padding: 5px 10px;
    border-radius: 5px;
    z-index: 1100;
    font-family: Arial, sans-serif;
    font-size: 12px;
    text-align: center;
">
        <div id="scale-bar" style="
      position: relative;
      width: 100px;
      height: 4px;
      background: black;
      margin-bottom: 2px;
  ">
            <!-- Left tick -->
            <div style="
        position: absolute;
        left: 0;
        top: -4px;
        width: 2px;
        height: 12px;
        background: black;
    "></div>
            <!-- Right tick -->
            <div style="
        position: absolute;
        right: 0;
        top: -4px;
        width: 2px;
        height: 12px;
        background: black;
    "></div>
        </div>
        <div id="scale-label">0 NM</div>
    </div>

    <!-- Controls Overlay -->
    <div id="controls">
        <label>
  <div id="connection-status" style="display: flex; align-items: center; margin-bottom: 5px; margin-left: 5px;">
    <span id="status-dot" style="width: 10px; height: 10px; border-radius: 50%; background: red; display: inline-block; margin-right: 5px;"></span>
    <span id="status-text">Disconnected</span>
  </div>
        <label>
    <input type="checkbox" id="only-focussed">
    Only Tracked
  </label>
        <label>
    <input type="checkbox" id="openseamap-overlay" checked>
    Map Overlay
  </label>
  <label>
    <input type="checkbox" id="show-ports">
    Show Ports
  </label>
  <label>
    <input type="checkbox" id="show-paths">
    History
  </label>
        <label>
    <input type="checkbox" id="stationary" checked>
    Stationary
  </label>
        <button id="toggle-legend" class="toggle-button" style="margin-top: 15px;">Show Legend</button>
    </div>

    <div id="vessel-legend" style="display: none; position: absolute; top: 220px; right: 5px; background: rgba(255, 255, 255, 0.9); border: 1px solid #ccc; border-radius: 5px; padding: 5px; z-index: 1000; font-family: Arial, sans-serif; font-size: 13px; max-height: 400px; overflow-y: auto; display: none;">
        <div id="legend-content"></div>
    </div>

    <!-- Known vessels overlay (bottom left) -->
    <div id="vessel-overlay" style="display: none;">
        <!-- Filter input box -->
        <input type="text" id="vessel-filter" placeholder="Filter vessels...">
        <div id="vessel-count" style="text-align: left; margin-bottom: 0px;">Total: 0</div>
        <div id="overlay-content"></div>
    </div>

    <!-- Vessel detail overlay (bottom right) -->
    <div id="vessel-detail">
        <div id="vessel-detail-header">
	  <div id="vessel-header-text"></div>
	  <div id="vessel-header-image"></div>
	</div>
        <div id="detail-content"></div>
    </div>

    <div id="image-modal-overlay" style="display:none; position:fixed; top:0; left:0; width:100%; height:100%; background:rgba(0,0,0,0.8); z-index:1500; align-items:center; justify-content:center;">
      <div id="image-modal-content" style="position:relative;">
        <button id="modal-close" style="position:absolute; top:10px; right:10px; font-size:20px; background:transparent; border:none; color:white; cursor:pointer;">X</button>
        <img id="modal-image" src="" alt="Full-size Vessel Image" style="max-width:90vw; max-height:90vh; display:block; margin:0 auto;">
      </div>
    </div>

    <!-- Toggle Buttons -->
    <button id="toggle-known-overlay" class="toggle-button">Show Vessels</button>
    <button id="toggle-detail-overlay" class="toggle-button">Hide Details</button>

    <button id="stats-button">Watch</button>
    <button id="live-logs">Messages</button>
    <button id="clear-history">Clear History</button>
    <div id="slider-container">
        <label for="history-slider">
  	    History: <span id="history-value">1</span> hrs
 	 </label>
        <input type="range" id="history-slider" min="1" max="24" value="1" step="1">
        <label for="age-slider">
	    Age: <span id="age-value">1</span> hrs
 	</label>
        <input type="range" id="age-slider" min="1" max="24" value="1" step="1">
    </div>
    <a href="https://github.com/madpsy/aisdecode" target="_blank" id="github-link">GitHub</a>
    <!-- Live Logs Overlay (draggable) -->
    <div id="live-logs-overlay">
        <div id="live-logs-header">
            <span id="live-logs-title">Live Messages</span>
            <button id="close-live-logs">X</button>
        </div>
	<div id="live-logs-filters" style="padding: 2px; border-bottom: 1px solid #ccc; font-size: 12px;">
	  <label style="white-space: nowrap;">
	    <input type="checkbox" id="log-filter-all" checked> All
	  </label>
	  <label style="white-space: nowrap;">
	    <input type="checkbox" class="log-filter" value="PositionReport" checked> Position A
	  </label>
	  <label style="white-space: nowrap;">
	    <input type="checkbox" class="log-filter" value="StandardClassBPositionReport" checked> Position B
	  </label>
	  <label style="white-space: nowrap;">
	    <input type="checkbox" class="log-filter" value="ExtendedClassBPositionReport" checked> Extended B
	  </label>
	  <label style="white-space: nowrap;">
	    <input type="checkbox" class="log-filter" value="ShipStaticData" checked> Static A
	  </label>
	  <label style="white-space: nowrap;">
	    <input type="checkbox" class="log-filter" value="StaticDataReport" checked> Static B
	  </label>
	  <label style="white-space: nowrap;">
	    <input type="checkbox" class="log-filter" value="AidsToNavigationReport" checked> AtoN
	  </label>
	  <label style="white-space: nowrap;">
	    <input type="checkbox" class="log-filter" value="BaseStationReport" checked> Base Stn
	  </label>
	  <label style="white-space: nowrap;">
	    <input type="checkbox" class="log-filter" value="BinaryBroadcastMessage" checked> Binary
	  </label>
	  <label style="white-space: nowrap;">
	    <input type="checkbox" class="log-filter" value="StandardSearchAndRescueAircraftReport" checked> SAR
	  </label>
	  <input type="text" id="live-log-search" placeholder="Search logs..." style="width:100%; margin-top:5px; padding:3px; font-size:12px;">
</div>

        <div id="live-logs-content"></div>
    </div>

    <!-- Socket.IO client (local copy) -->
    <script src="socket.io.min.js"></script>
    <!-- Leaflet JS (from CDN, without integrity) -->
    <script src="https://unpkg.com/leaflet@1.9.3/dist/leaflet.js" crossorigin=""></script>
    <script>
	 // Clear vessel data from localStorage immediately
	 localStorage.removeItem('vesselData');
        // Detect if the device is touch capable.
        const isMobile = ('ontouchstart' in window || navigator.maxTouchPoints > 0);

	const TOOLTIP_ZOOM_THRESHOLD = 12;

	let currentLoadedImageUrl = '';

	const vesselSolidTracks = {};
	const vesselColoredTracks = {};

        // Flag to track if the user manually hid the details overlay.
        let detailsOverlayHidden = false;
	let userLatLng = null;

	let mids = {};
	fetch('mids.json')
	  .then(response => {
	    if (!response.ok) {
	      throw new Error(`Network error: ${response.status}`);
	    }
	    return response.json();
	  })
	  .then(data => {
	    mids = data;
	  })
	  .catch(error => {
	    console.error('Error loading mids.json:', error);
	  });

        // Global variable to store the currently focused vessel (if any).
        let focusedVessel = null;

	const receiverData = {};    // Stores receiver info keyed by receiver ID.

	// Create the base layers
	const googleSat = L.tileLayer('https://{s}.google.com/vt/lyrs=s,h&x={x}&y={y}&z={z}', {
	  maxZoom: 20,
	  subdomains: ['mt0', 'mt1', 'mt2', 'mt3'],
	  attribution: '&copy; Google'
	});

	const osm = L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
	  attribution: '&copy; OpenStreetMap'
	});

	// Object to hold your base layers.
	const baseLayers = {
	  "Google": googleSat,
	  "OSM": osm
	};

	// Initialize the map with a default base layer
	const map = L.map('map').setView([55.0, -3.0], 5);
	osm.addTo(map);

	// Add the layers control.
	L.control.layers(baseLayers, null, { position: 'topleft' }).addTo(map);

	// Listen for the base layer change event.
	map.on('baselayerchange', function(e) {
	  // 'e.name' holds the key ("Google" or "OSM")
	  localStorage.setItem('selectedBasemap', e.name);
	  if (map.hasLayer(openSeaMapLayer)) {
	    openSeaMapLayer.bringToFront();
	  }
	});

        // OpenSeaMap overlay layer (enabled by default).
        const openSeaMapLayer = L.tileLayer('https://tiles.openseamap.org/seamark/{z}/{x}/{y}.png', {
          attribution: 'Map data: &copy; OpenSeaMap'
        }).addTo(map);
	openSeaMapLayer.bringToFront();

    const allowedMessageTypes = {
      "PositionReport": true,
      "ShipStaticData": true,
      "StaticDataReport": true,
      "StandardClassBPositionReport": true,
      "ExtendedClassBPositionReport": true,
      "AidsToNavigationReport": true,
      "BaseStationReport": true,
      "BinaryBroadcastMessage": true,
      "StandardSearchAndRescueAircraftReport": true
    };

	map.on('mousemove', function(e) {
	  if (!focusedVessel) {
	    document.getElementById('latlong-display').textContent =
	      `${e.latlng.lat.toFixed(5)}, ${e.latlng.lng.toFixed(5)}`;
	  }
	});

        // Helper function to clear all live logs and show a placeholder.
        function clearLiveLogs() {
          liveLogsContent.innerHTML = "<div class='placeholder' style='font-family: monospace; font-size: 12px; color: #888; text-align: center; padding: 10px;'>Waiting for next message...</div>";
        }


map.on('click', () => {
  if (focusedVessel) {
    document.getElementById('show-paths').checked = false;
    const vessel = vesselData[focusedVessel];
    vesselMarkers[focusedVessel].getTooltip().setContent(vessel.Name);
    vesselMarkers[focusedVessel].setZIndexOffset(0);
    focusedVessel = null;
    unsubscribeInstantUpdates();

    // Hide detail overlay and all related buttons when no vessel is focused.
    document.getElementById('vessel-detail').style.display = 'none';
    document.getElementById('toggle-detail-overlay').style.display = 'none';
    document.getElementById('live-logs').style.display = 'none';
    document.getElementById('stats-button').style.display = 'none';

    clearLiveLogs();
    updateFocussedVisibility();
    updateStationaryMarkers();
  }
  sendSummaryRequest();
});

function sendSummaryRequest() {
  const onlyTracked = document.getElementById('only-focussed').checked;
  
  if (onlyTracked && focusedVessel) {
    const filterParams = { userID: focusedVessel };
    const jsonPayload = JSON.stringify(filterParams);
    //console.log("Emitting requestSummary (Only Tracked):", jsonPayload);
    socket.emit("requestSummary", jsonPayload);
    updateOverlay();
    return;
  }
  
  const center = map.getCenter();
  const bounds = map.getBounds();
  const radius = center.distanceTo(bounds.getNorthEast()) * 1.5;
  const ageSlider = document.getElementById("age-slider");
  const maxAge = parseInt(ageSlider.value, 10);
  
  const filterParams = {
    latitude: center.lat,
    longitude: center.lng,
    radius: radius,      // in meters
    maxResults: 500,     // fixed limit
    maxAge: maxAge,      // in hours
    updatePeriod: 5      // in seconds
  };

  if (!document.getElementById('stationary').checked) {
    filterParams.minSpeed = 1;
  }
  
  const jsonPayload = JSON.stringify(filterParams);
  //console.log("Emitting requestSummary:", jsonPayload);
  socket.emit("requestSummary", jsonPayload);
  updateOverlay();
}

        // Mapping objects for Fix Type, Nav Status, and Static Message Types.
        const fixTypeMapping = { 0: "No Fix", 1: "GPS Fix", 2: "DGPS Fix" };

        const navigationalStatusMapping = {
          0: "Using Engine",
          1: "At Anchor",
          2: "Not Under Command",
          3: "Restricted Manoeuvrability",
          4: "Constrained by Draft",
          5: "Moored",
          6: "Aground",
          7: "Engaged in Fishing",
          8: "Under Way Sailing",
          15: "Unknown"
        };

        const staticTypeMapping = {
          0: "Not available",
          1: "Reserved",
          2: "Reserved",
          3: "Reserved",
          4: "Reserved",
          5: "Reserved",
          6: "Reserved",
          7: "Reserved",
          8: "Reserved",
          9: "Reserved",
          10: "Reserved",
          11: "Reserved",
          12: "Reserved",
          13: "Reserved",
          14: "Reserved",
          15: "Reserved",
          16: "Reserved",
          17: "Reserved",
          18: "Reserved",
          19: "Reserved",
          20: "Wing in ground (WIG)",
          21: "Wing in ground (WIG)",
          22: "Wing in ground (WIG)",
          23: "Wing in ground (WIG)",
          24: "Wing in ground (WIG)",
          25: "Wing in ground (WIG)",
          26: "Wing in ground (WIG)",
          27: "Wing in ground (WIG)",
          28: "Wing in ground (WIG)",
          29: "Wing in ground (WIG)",
          30: "Fishing",
          31: "Towing",
          32: "Towing: length>200m, breadth>25m",
          33: "Dredging or underwater ops",
          34: "Diving ops",
          35: "Military ops",
          36: "Sailing",
          37: "Pleasure Craft",
          38: "Reserved",
          39: "Reserved",
          40: "High speed craft (HSC)",
          41: "High speed craft (HSC)",
          42: "High speed craft (HSC)",
          43: "High speed craft (HSC)",
          44: "High speed craft (HSC)",
          45: "High speed craft (HSC)",
          46: "High speed craft (HSC)",
          47: "High speed craft (HSC)",
          48: "High speed craft (HSC)",
          49: "High speed craft (HSC)",
          50: "Pilot Vessel",
          51: "Search and Rescue",
          52: "Tug",
          53: "Port Tender",
          54: "Anti-pollution equipment",
          55: "Law Enforcement",
          56: "Spare - Local Vessel",
          57: "Spare - Local Vessel",
          58: "Medical Transport",
          59: "Noncombatant ship",
          60: "Passenger",
          61: "Passenger",
          62: "Passenger",
          63: "Passenger",
          64: "Passenger",
          65: "Passenger",
          66: "Passenger",
          67: "Passenger",
          68: "Passenger",
          69: "Passenger",
          70: "Cargo",
          71: "Cargo",
          72: "Cargo",
          73: "Cargo",
          74: "Cargo",
          75: "Cargo",
          76: "Cargo",
          77: "Cargo",
          78: "Cargo",
          79: "Cargo",
          80: "Tanker",
          81: "Tanker",
          82: "Tanker",
          83: "Tanker",
          84: "Tanker",
          85: "Tanker",
          86: "Tanker",
          87: "Tanker",
          88: "Tanker",
          89: "Tanker",
          90: "Other Type",
          91: "Other Type",
          92: "Other Type",
          93: "Other Type",
          94: "Other Type",
          95: "Other Type",
          96: "Other Type",
          97: "Other Type",
          98: "Other Type",
          99: "Other Type"
        };

const vesselColorPalette = [
  "#FF4500", // Orange Red
  "#00CED1", // Dark Turquoise
  "#F58231", // Vibrant Orange
  "#FF00FF", // Fuchsia
  "#FF69B4", // Hot Pink
  "#FF8C00", // Dark Orange
  "#8A2BE2", // Blue Violet
  "#0082C8", // Vibrant Blue
  "#FF1493", // Deep Pink
  "#E6194B", // Vibrant Red
  "#46F0F0", // Vibrant Cyan
  "#00BFFF", // Deep Sky Blue
  "#00FF00", // Lime
  "#F032E6", // Vibrant Magenta
  "#FFD700", // Gold
  "#FF6347", // Tomato
  "#DC143C", // Crimson
  "#FFE119", // Vibrant Yellow
  "#40E0D0", // Turquoise
  "#DA70D6", // Orchid
  "#911EB4", // Vibrant Purple
  "#FF7F50", // Coral
  "#3CB44B"  // Vibrant Green
];

const friendlyMessageTypes = {
  "PositionReport": "Position (A)",
  "ShipStaticData": "Static (A)",
  "StaticDataReport": "Static (B)",
  "StandardClassBPositionReport": "Position (B std)",
  "ExtendedClassBPositionReport": "Position (B ext)",
  "AidsToNavigationReport": "AtoN",
  "BaseStationReport": "Base Station",
  "BinaryBroadcastMessage": "Binary Broadcast",
  "StandardSearchAndRescueAircraftReport": "SAR"
};

function djb2Hash(str) {
  let hash = 8393;
  for (let i = 0; i < str.length; i++) {
    hash = ((hash << 5) + hash) + str.charCodeAt(i); // hash * 33 + c
  }
  return hash >>> 0; // Ensure a positive integer
}

function hashStringToIndex(description, modulo) {
  return djb2Hash(description) % modulo;
}

// Change receiverMarkers from an array to an object.
let receiverMarkers = {};

function refreshReceivers() {
  fetch('/receivers')
    .then(response => {
      if (!response.ok) {
        throw new Error(`Network error: ${response.status}`);
      }
      return response.json();
    })
    .then(receivers => {
      const currentReceiverIDs = new Set();

      if (Array.isArray(receivers) && receivers.length > 0) {
        receivers.forEach(receiver => {
          const id = String(receiver.id);
          currentReceiverIDs.add(id);

          const lat = parseFloat(receiver.latitude);
          const lng = parseFloat(receiver.longitude);

          if (isNaN(lat) || isNaN(lng)) {
            console.warn("Invalid coordinates for receiver id", id);
            return;
          }

          // Create or update the receiver marker.
          if (receiverMarkers[id]) {
		  // Update marker position.
		  receiverMarkers[id].setLatLng([lat, lng]);
		  const updatedLocalTime = new Date(receiver.LastUpdated).toLocaleString();
	    	  let linksHTML = "";
	    	  if (receiver.url && receiver.url.trim() !== "") {
	    	    linksHTML += `<a href="${receiver.url}" target="_blank">Website</a>`;
	    	  }
	    	  if (receiver.metrics) {
	    	    if (linksHTML !== "") {
	    	      linksHTML += " | ";
	    	    }
	    	    linksHTML += `<a href="/metrics.html?id=${id}" target="_blank">Metrics</a>`;
	    	  }
	    	  if (receiver.state) {
	    	    if (linksHTML !== "") {
	    	      linksHTML += " | ";
	    	    }
	    	    linksHTML += `<a href="/coverage.html?id=${id}" target="_blank">Coverage</a>`;
	    	  }
		  const popupContent = `
		    <strong>${receiver.name}</strong><br>
		    ${receiver.description}<br>
		    Updated: ${updatedLocalTime}<br>
		    ${linksHTML}
		  `;
		  // Update the popup content.
		  receiverMarkers[id].setPopupContent(popupContent);
          } else {
            const marker = L.marker([lat, lng], { icon: createReceiverIcon() }).addTo(map);
            const updatedLocalTime = new Date(receiver.LastUpdated).toLocaleString();
            let linksHTML = "";
	    if (receiver.url && receiver.url.trim() !== "") {
	      linksHTML += `<a href="${receiver.url}" target="_blank">Website</a>`;
	    }
	    if (receiver.metrics) {
	      // Add separator if needed.
	      if (linksHTML !== "") {
	        linksHTML += " | ";
	      }
	      linksHTML += `<a href="/metrics.html?id=${id}" target="_blank">Metrics</a>`;
	    }
	    if (receiver.state) {
	      if (linksHTML !== "") {
	        linksHTML += " | ";
	      }
	      linksHTML += `<a href="/coverage.html?id=${id}" target="_blank">Coverage</a>`;
	    }
            const popupContent = `
              <strong>${receiver.name}</strong><br>
              ${receiver.description}<br>
              Updated: ${updatedLocalTime}<br>
              ${linksHTML}
            `;
            marker.bindPopup(popupContent, { autoPan: true });

            // Bind tooltip showing a label for a receiver.
            marker.bindTooltip(`Receiver: ${receiver.name}`, {
              permanent: true,
              interactive: true,
              direction: 'top',
              className: 'receiver-tooltip'
            }).openTooltip();

            receiverMarkers[id] = marker;
          }

          // Store receiver info with an extra flag.
          receiverData[id] = {
            Name: receiver.name,
            LastUpdated: receiver.LastUpdated,
            UserID: id,
            isReceiver: true,
            // You can store other properties (url, description, etc.) if needed.
            url: receiver.url,
            description: receiver.description
          };
        });
      } else {
        console.warn("No receivers found.");
      }

      // Remove stale markers/data.
      for (const id in receiverMarkers) {
        if (!currentReceiverIDs.has(id)) {
          map.removeLayer(receiverMarkers[id]);
          delete receiverMarkers[id];
          delete receiverData[id];
        }
      }
    })
    .catch(error => {
      console.error('Error fetching receivers:', error);
    });
}

function getColorForVesselTypeConsistent(type) {
  if (!type) return "blue";
  const description = staticTypeMapping[type] || type;
  const index = hashStringToIndex(description, vesselColorPalette.length);
  return vesselColorPalette[index];
}

// Create a custom boat icon using your existing SVG, but with the stroke and fill set to the vessel type's color.
function createBoatIcon(type, heading = 0) {
  const color = getColorForVesselTypeConsistent(type);
  const svgHtml = `<svg width="20" height="50" viewBox="0 0 20 50" style="transform: rotate(${heading}deg); transform-origin: center;">
    <path d="M5 45 L15 45 L15 30 Q10 5,5 30 Z" stroke="${color}" fill="${color}" stroke-width="2" />
  </svg>`;
  return L.divIcon({
    html: svgHtml,
    className: 'boat-icon',
    iconSize: [20, 50],
    iconAnchor: [10, 25],
    popupAnchor: [0, -25]
  });
}

function getCustomIcon(vesselState, iconUrl) {
  // Determine the heading as before
  const heading = (typeof vesselState.TrueHeading === 'number' && vesselState.TrueHeading < 360)
      ? vesselState.TrueHeading
      : (typeof vesselState.Cog === 'number' && vesselState.Cog >= 0 && vesselState.Cog < 360)
        ? vesselState.Cog
        : 0;
  
  return L.divIcon({
    html: `<div class="non-vessel-icon-image" style="
              width: 30px;
              height: 30px;
              background-image: url('${iconUrl}');
              background-size: contain;
              background-repeat: no-repeat;
              transform: rotate(${heading}deg);
            "></div>`,
    className: 'non-vessel-icon', // still used for container styling if needed
    iconSize: [30, 30],
    iconAnchor: [15, 15], // center of the 30x30 div
    popupAnchor: [0, -15]
  });
}


function getVesselIcon(vesselState) {
  // For lower zoom levels, show a simple circle marker.
  if (map.getZoom() < 10) {
    return createCircleIcon(vesselState);
  }
  
  // Check the AISClass value for special cases.
  if (vesselState.AISClass) {
    const aisClass = vesselState.AISClass.trim();
    if (aisClass === "AtoN") {
      return getCustomIcon(vesselState, 'images/aids-to-navigation.png');
    } else if (aisClass === "Base Station") {
      return getCustomIcon(vesselState, 'images/base-station.png');
    } else if (aisClass === "SAR") {
      return getCustomIcon(vesselState, 'images/sar-aircraft.png');
    }
  }
  
  // Default: compute the vessel's heading and create a boat icon.
  const heading = (typeof vesselState.TrueHeading === 'number' && vesselState.TrueHeading < 360)
                    ? vesselState.TrueHeading
                    : (typeof vesselState.Cog === 'number' && vesselState.Cog >= 0 && vesselState.Cog < 360)
                      ? vesselState.Cog
                      : 0;
  return createBoatIcon(vesselState.Type, heading);
}

function attachImageClick(imgElem) {
  imgElem.addEventListener('click', function(e) {
    e.stopPropagation(); // Prevent the click from bubbling up if needed.
    openImageModal(this.src);
  });
}

// Preload the vessel image before inserting it into the container.
function loadVesselImage(url, container) {
  url = url.trim();
  // Create the image element.
  const img = document.createElement('img');
  img.id = 'vessel-image';
  img.style.maxWidth = '100%';
  img.style.margin = '5px 0';
  img.style.height = 'auto';
  img.style.cursor = 'pointer';
  img.alt = 'Vessel Image';

  // Attach the click event immediately.
  img.addEventListener('click', function(e) {
    e.stopPropagation();
    // Use the current src of the image when clicked.
    openImageModal(img.src);
  });

  // When the image loads, append it to the container.
  img.onload = function() {
    // Remove any previously appended image with the same id.
    const existingImg = container.querySelector('#vessel-image');
    if (existingImg) {
      existingImg.remove();
    }
    container.appendChild(img);
  };

  // Handle loading errors.
  img.onerror = function() {
    console.error("Image failed to load:", url);
    // Optionally, retry loading after a delay or show a fallback image.
  };

  // Set the image source (this starts the asynchronous load).
  img.src = url;
}

function updateVesselDetailHeader(userID) {
  // Grab our dedicated containers.
  const textContainer = document.getElementById('vessel-header-text');
  const imageContainer = document.getElementById('vessel-header-image');
  
  // Update the text container with the vessel name, lookup, and copy link.
  textContainer.innerHTML = `<h4><font size="3">${vesselData[userID].Name}</font><br>
    <a href="https://www.vesselfinder.com/vessels/details/${vesselData[userID].UserID}" target="_blank">Lookup</a> |
    <span id="copy-link" style="cursor:pointer; color:blue;">Link</span></h4>`;
  
  // Check if there is an image URL.
  if (vesselData[userID].ImageURL) {
    // Only update the image if the URL has changed.
    if (currentLoadedImageUrl !== vesselData[userID].ImageURL) {
      // Clear any existing content in the image container.
      imageContainer.innerHTML = '';
      // Load and inject the image into the image container.
      loadVesselImage(vesselData[userID].ImageURL, imageContainer);
      currentLoadedImageUrl = vesselData[userID].ImageURL;
      document.getElementById('vessel-detail').style.maxHeight = '400px';
    }
  } else {
    // No image URL: clear any previous image.
    imageContainer.innerHTML = '';
    currentLoadedImageUrl = '';
    document.getElementById('vessel-detail').style.maxHeight = '300px';
  }
}

function updateLatLongDisplay() {
  const latlongDisplay = document.getElementById('latlong-display');
  if (focusedVessel && vesselData[focusedVessel]) {
    const lat = vesselData[focusedVessel].Latitude;
    const lon = vesselData[focusedVessel].Longitude;
    if (typeof lat === 'number' && typeof lon === 'number') {
      latlongDisplay.innerHTML = `<strong>${lat.toFixed(5)}, ${lon.toFixed(5)}</strong>`;
    }
  }
}

function debounce(func, wait) {
  let timeout;
  return function(...args) {
    const context = this;
    clearTimeout(timeout);
    timeout = setTimeout(() => {
      func.apply(context, args);
    }, wait);
  };
}

const debouncedAdjustMapBounds = debounce(adjustMapBounds, 500);


// Function to open the modal with the clicked image
function openImageModal(imageSrc) {
  const modalOverlay = document.getElementById('image-modal-overlay');
  const modalImage = document.getElementById('modal-image');
  modalImage.src = imageSrc;
  modalOverlay.style.display = 'flex';
}

// Function to close the modal
function closeImageModal() {
  const modalOverlay = document.getElementById('image-modal-overlay');
  modalOverlay.style.display = 'none';
}

// Attach click listener to the vessel image when vessel details are shown.
function attachImageClick() {
  const vesselImage = document.getElementById('vessel-image');
  if (vesselImage) {
    vesselImage.addEventListener('click', function(e) {
      e.stopPropagation();
      openImageModal(this.src);
    });
  }
}

function clearHistory() {
  localStorage.removeItem('vesselData');
  Object.keys(vesselMarkers).forEach(userID => {
    map.removeLayer(vesselMarkers[userID]);
  });
  Object.keys(vesselTracks).forEach(userID => {
    map.removeLayer(vesselTracks[userID]);
  });
  Object.keys(vesselData).forEach(key => delete vesselData[key]);
  Object.keys(vesselMarkers).forEach(key => delete vesselMarkers[key]);
  Object.keys(vesselTracks).forEach(key => delete vesselTracks[key]);
  updateOverlay();
  location.reload();
}

function attachPolylineEvents(layerGroup, userID) {
  // Iterate over each polyline in the layer group.
  layerGroup.eachLayer(function(polylineSegment) {
    polylineSegment.on('mousemove', function(e) {
      const nearest = getNearestTrackPoint(e, vesselData[userID].track);
      if (nearest) {
        const [timestamp, lat, lon, sog, cog, trueHeading] = nearest.info;
        const localTime = new Date(timestamp).toLocaleString();
        const vessel = vesselData[userID];
        const name = vessel.Name || "Unknown Vessel";
        const callsign = vessel.CallSign || "N/A";
        
        let popupContent = `<strong>${name} (${callsign})</strong><br>
                            ${localTime}<br>
                            ${lat.toFixed(5)}, ${lon.toFixed(5)}<br>`;
        if (sog !== null) {
          popupContent += `Speed: ${sog} kn<br>`;
        }
        if (cog !== null) {
          popupContent += `Course: ${cog}°<br>`;
        }
        if (trueHeading !== null) {
          popupContent += `Heading: ${trueHeading}°<br>`;
        }
        
        L.popup({ closeButton: false, autoPan: false })
          .setLatLng(nearest.ptLatLng)
          .setContent(popupContent)
          .openOn(map);
      }
    });
    polylineSegment.on('mouseout', function() {
      map.closePopup();
    });
  });
}

function updateLegend() {

  const legend = document.getElementById('vessel-legend');
  const currentDisplay = window.getComputedStyle(legend).display;
  
  if (currentDisplay === 'none') {
    return; // If the legend is hidden, don't update it
  }

  // Get the top 5 vessel types
  const vesselTypes = {};

  // Loop through the vessel data to gather vessel types
  for (const userID in vesselData) {
    const vessel = vesselData[userID];
    if (vessel.Type) {
      const typeDescription = staticTypeMapping[vessel.Type] || vessel.Type;
      const typeColor = getColorForVesselTypeConsistent(vessel.Type);

      if (!vesselTypes[typeDescription]) {
        vesselTypes[typeDescription] = {
          count: 0,
          color: typeColor,
        };
      }
      vesselTypes[typeDescription].count += 1;
    }
  }

  // Get the top 5 types based on count
  const topTypes = Object.keys(vesselTypes)
    .sort((a, b) => vesselTypes[b].count - vesselTypes[a].count);

  let legendContent = '';
  topTypes.forEach(type => {
    const count = vesselTypes[type].count;
    const color = vesselTypes[type].color;

    legendContent += `
      <div class="legend-item">
        <svg width="20" height="50" viewBox="0 0 20 50" style="transform: rotate(0deg); transform-origin: center;">
          <path d="M5 45 L15 45 L15 30 Q10 5,5 30 Z" stroke="${color}" fill="${color}" stroke-width="2" />
        </svg>
        <span>${type} (${count})</span>
      </div>
    `;
  });

  // Update the legend content
  document.getElementById('legend-content').innerHTML = legendContent;

  // Display the legend
  document.getElementById('vessel-legend').style.display = 'block';
}

function getColorForSpeed(speed) {
  const maxSpeed = 20;  // maximum expected speed in knots
  // Clamp the speed value between 0 and maxSpeed
  const clampedSpeed = Math.max(0, Math.min(maxSpeed, speed));
  // Compute a ratio (0 = 0 knots, 1 = maxSpeed)
  const ratio = clampedSpeed / maxSpeed;
  // Calculate hue: 120 (green) at 0 knots to 0 (red) at 20 knots.
  // Here, a higher ratio gives a lower hue value.
  const hue = (1 - ratio) * 120;
  // Return a string with full saturation and 50% lightness.
  return `hsl(${hue}, 100%, 50%)`;
}


function createColoredTrack(track) {
  const segments = [];
  // Loop through the track segments
  for (let i = 0; i < track.length - 1; i++) {
    const pt1 = track[i];
    const pt2 = track[i + 1];
    // Use the speed of the first point (or average of pt1 and pt2) for the color
    const speed = (pt1[3] != null ? pt1[3] : 0);
    const color = getColorForSpeed(speed);
    // Create a polyline segment with this color
    const segment = L.polyline([[pt1[1], pt1[2]], [pt2[1], pt2[2]]], {
      color: color,
      weight: 3,
      opacity: 0.8
    });
    segments.push(segment);
  }
  // Group the segments so you can treat them as one layer
  return L.layerGroup(segments);
}

function updateFocusedVesselTrack(userID) {
  if (focusedVessel === userID && vesselData[userID] && vesselData[userID].track) {
    if (vesselColoredTracks[userID]) {
      map.removeLayer(vesselColoredTracks[userID]);
    }
    const newColoredTrack = createColoredTrack(vesselData[userID].track);
    vesselColoredTracks[userID] = newColoredTrack;
    map.addLayer(newColoredTrack);
  }
}

function createReceiverIcon() {
  const svgHtml = `
    <svg style="pointer-events: none;" width="20" height="20" viewBox="0 0 20 20">
      <circle cx="10" cy="10" r="10" fill="red" />
    </svg>
  `;
  return L.divIcon({
    html: svgHtml,
    className: '',
    iconSize: [20, 20],
    iconAnchor: [10, 10]
  });
}

function hydrateTrackHistory(userID) {
  const historySlider = document.getElementById('history-slider');
  const maxHistory = historySlider.value;
  fetch(`/history/${userID}/${maxHistory}`)
    .then(response => {
      if (!response.ok) {
        throw new Error(`History fetch failed with status: ${response.status}`);
      }
      return response.text();
    })
    .then(csvData => {
      // Parse the CSV formatted history into an array of points.
      // Each point is an array: [timestamp, latitude, longitude, sog, cog, trueHeading]
      const newPoints = csvData.trim().split('\n').map(line => {
        const parts = line.split(',');
        const lat = parseFloat(parts[1]);
        const lon = parseFloat(parts[2]);
        // Only return the point if both lat and lon are valid numbers.
        if (isNaN(lat) || isNaN(lon)) {
          return null;
        }
        // Parse extra fields; if empty, use null.
        const sog = parts[3] && parts[3].trim() !== "" ? parseFloat(parts[3]) : null;
        const cog = parts[4] && parts[4].trim() !== "" ? parseFloat(parts[4]) : null;
        const trueHeading = parts[5] && parts[5].trim() !== "" ? parseFloat(parts[5]) : null;
        return [parts[0], lat, lon, sog, cog, trueHeading];
      }).filter(point => point !== null);

      // Retrieve the current track history (or start with an empty array).
      const currentTrack = vesselData[userID].track || [];
      
      // Merge the current track with the new points.
      const mergedTrack = currentTrack.concat(newPoints);
      
      // Sort the merged track by time (assuming the timestamp is ISO formatted).
      mergedTrack.sort((a, b) => new Date(a[0]) - new Date(b[0]));

      // Remove duplicate entries.
      // Two points are considered duplicates if they have identical timestamp, latitude, and longitude.
      const dedupedTrack = [];
      mergedTrack.forEach(point => {
        if (
          dedupedTrack.length === 0 ||
          dedupedTrack[dedupedTrack.length - 1][0] !== point[0] ||
          dedupedTrack[dedupedTrack.length - 1][1] !== point[1] ||
          dedupedTrack[dedupedTrack.length - 1][2] !== point[2]
        ) {
          dedupedTrack.push(point);
        }
      });

      // Update the vessel's track history in your data store.
      vesselData[userID].track = dedupedTrack;
      
      // Immediately apply the history filter based on the current slider value.
      const now = Date.now();
      const historyHours = parseInt(document.getElementById("history-slider").value, 10);
      const filteredTrack = dedupedTrack.filter(pt => {
        const pointTime = new Date(pt[0]).getTime();
        return (now - pointTime) <= historyHours * 3600000;
      });
      
      // --- Update the polyline on the map using speed-based colors ---
      // Remove any existing track for this vessel.
      if (vesselTracks[userID]) {
        map.removeLayer(vesselTracks[userID]);
      }
      // Use createColoredTrack() to generate the new colored track layer.
      vesselTracks[userID] = createColoredTrack(filteredTrack);
      map.addLayer(vesselTracks[userID]);
      // Reattach events (e.g., mousemove and mouseout) to the new polyline segments.
      attachPolylineEvents(vesselTracks[userID], userID);
      
      // Force re-addition of the polyline in case update functions have removed it.
      if (!map.hasLayer(vesselTracks[userID])) {
        map.addLayer(vesselTracks[userID]);
      }
      
      // Save the updated vessel data back into localStorage.
      localStorage.setItem('vesselData', JSON.stringify(vesselData));
      
      // Now update the UI after CSV processing is complete.
      updateOverlay();
    })
    .catch(error => {
      console.error('Error hydrating track history:', error);
      // Optionally, you can call your update functions on error
      updateOverlay();
    });
}

        // Global objects to store markers, vessel data, and track histories.
        const vesselMarkers = {};
        const vesselData = {};   // keyed by MMSI/UserID
        const vesselTracks = {}; // keyed by MMSI/UserID

        /**
         * Decode the AIS communication state.
         */
        function decodeCommunicationState(state) {
          const intState = Number(state);
          const syncState = intState >> 17;
          const slotTimeout = (intState >> 14) & 0x07;
          const slotOffset = intState & 0x3FFF;
          return { syncState, slotTimeout, slotOffset };
        }

// Global variable to store current port data
let currentPorts = [];

// Create a layer group for port markers
const portLayerGroup = L.layerGroup().addTo(map);

// Create a custom invisible icon
const invisibleIcon = L.divIcon({
  className: 'invisible-icon',
  html: '', // Empty HTML content for an invisible icon
  iconSize: [0, 0]  // No size for the marker
});

// Create and add port markers with tooltips to the portLayerGroup
function addPortMarkers(ports) {
  // Compare new ports with the current ones (using JSON stringify for a basic deep comparison)
  // Depending on your data structure, you may want a more robust comparison.
  if (JSON.stringify(ports) === JSON.stringify(currentPorts)) {
    // If the data is the same, do nothing.
    return;
  }
  
  // Update the current ports cache
  currentPorts = ports;

  // Clear existing port markers
  portLayerGroup.clearLayers();

  ports.forEach(port => {
    const { CITY, LATITUDE, LONGITUDE } = port;

    // Create the marker with the invisible icon
    const portMarker = L.marker([LATITUDE, LONGITUDE], { icon: invisibleIcon });

    const tooltipContent = `<img src="/images/port.png" style="width: 16px; height: 16px; vertical-align: middle; margin-right: 4px;" />${CITY}`;
    portMarker.bindTooltip(tooltipContent, { permanent: true, direction: 'top', className: 'port-marker-tooltip' });

    // Add the marker to the portLayerGroup
    portMarker.addTo(portLayerGroup);
  });
}

let debounceTimeout;

function fetchPorts() {
  const center = map.getCenter();
  const zoom = map.getZoom();

  if (zoom < 8) {
    portLayerGroup.clearLayers();
    currentPorts = [];
    return; 
  }

  if (zoom >= 8) {
    // Adjust the radius based on zoom level (higher zoom = smaller radius)
    let radius;

    if (zoom >= 8) {
      radius = 100000;  // 100 km
    } else {
      radius = 200000; // 200 km 
    }

    // Prepare the POST request payload
    const requestPayload = {
      action: "within_radius",
      latitude: center.lat,
      longitude: center.lng,
      radius: radius
    };

    // Call the /ports endpoint
    fetch('/ports', {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json'
      },
      body: JSON.stringify(requestPayload)
    })
    .then(response => response.json())
    .then(ports => {
      if (Array.isArray(ports) && ports.length > 0) {
        // Add port markers to the map only if there are valid ports data
        addPortMarkers(ports);
      } else {
        console.log('No ports data to display');
      }
    })
    .catch(error => {
      console.error('Error fetching ports:', error);
    });
  }
}

function removePortMarkers() {
  portLayerGroup.clearLayers();
  currentPorts = [];
}

function selectVesselById(userID) {
  // Check if a marker already exists for the vessel.
  if (!vesselMarkers[userID]) {
    // If the marker does not exist, fetch the vessel state.
    fetch(`/state/${userID}`)
      .then(response => {
        if (!response.ok) {
          throw new Error(`Request failed with status ${response.status}`);
        }
        return response.json();
      })
      .then(stateData => {
        // Ensure that the state has valid position data.
        if (typeof stateData.Latitude === "number" && typeof stateData.Longitude === "number") {
          // Update or add the vessel to your global state.
          vesselData[userID] = stateData;
	  if (!vesselData[userID].track) {
  		vesselData[userID].track = [];
	  }
	  if (!vesselData[userID].color) {
            vesselData[userID].color = randomColor();
          }
          // Create a marker using your existing function (e.g., getVesselIcon).
          let marker = L.marker(
            [stateData.Latitude, stateData.Longitude],
            { icon: getVesselIcon(stateData) }
          ).addTo(map);
          vesselMarkers[userID] = marker;

          // Optionally, bind popups or tooltips.
          marker.bindPopup(createPopupContent(stateData), { autoPan: false });

          // Focus on the vessel (recenter, highlight, etc.)
          focusOnVessel(userID);

        } else {
          console.error("Invalid location data received for vessel:", userID);
        }
      })
      .catch(error => {
        console.error("Error fetching vessel state:", error);
      });
  } else {
    // If the marker already exists, update its position.
    fetch(`/state/${userID}`)
      .then(response => response.json())
      .then(stateData => {
        // Update global state and marker position.
        vesselData[userID] = stateData;
	if (!vesselData[userID].track) {
  	   vesselData[userID].track = [];
	}
        if (!vesselData[userID].color) {
          vesselData[userID].color = randomColor();
       }
        vesselMarkers[userID].setLatLng([stateData.Latitude, stateData.Longitude]);
        vesselMarkers[userID].getPopup().setContent(createPopupContent(stateData));

        focusOnVessel(userID);
        hydrateTrackHistory(userID);
      })
      .catch(error => {
        console.error("Error updating vessel state for marker:", error);
      });
  }
}

function renderSearchResults(data) {
  // Convert the response object to an array.
  if (!Array.isArray(data)) {
    data = Object.values(data);
  }
  
  let content = "";
  data.forEach(entry => {
    const name = entry.Name;
    const lastSeen = timeAgo(new Date(entry.LastUpdated || Date.now()).getTime());
    const numMessages = entry.NumMessages || 0;
  
    // Use extra info if the entry represents a receiver.
    const extraInfo = entry.isReceiver
      ? `<div class="vessel-callsign">Receiver</div>`
      : `<div class="vessel-callsign">Call Sign: ${entry.CallSign ? entry.CallSign : "N/A"}</div>`;
  
    content += `<div class="vessel-entry" data-userid="${entry.UserID}">
                  <div class="vessel-name">${name}</div>
                  ${extraInfo}
                  <div class="vessel-timestamp">${lastSeen} | ${numMessages} msgs</div>
                </div>`;
  });
  
  document.getElementById('overlay-content').innerHTML = content;
  
  // Update the count to reflect search results.
  document.getElementById('vessel-count').innerHTML =
    `${data.length} of ${data.length} entries`; // or customize based on your needs
  
  // Attach click event listeners for each overlay entry.
  document.querySelectorAll('.vessel-entry').forEach(entry => {
    entry.addEventListener('click', event => {
      event.stopPropagation();
      const userID = entry.getAttribute('data-userid');
      if (receiverData.hasOwnProperty(userID)) {
        const marker = receiverMarkers[userID];
        map.setView(marker.getLatLng(), 10);
        marker.openPopup();
      } else {
        selectVesselById(userID);
      }
    });
  });
}



        /**
         * Build popup content from vessel data.
         */
function createPopupContent(data) {
  const lines = [];
  // Top line: Always show name, callsign, and class.
  let name = data.Name ? data.Name : "Unknown Vessel";
  if (data.CallSign) {
    name += ` (${data.CallSign})`;
  }
  if (data.AISClass) {
    name += ` | ${data.AISClass}`;
  }
  lines.push(`<strong>${name}</strong>`);

  // Add subsequent lines only if they have valid (non-null/non-empty) values.
  addLine(lines, "Last Update", data.lastUpdate ? timeAgo(data.lastUpdate) : null);
  addLine(lines, "MMSI", data.UserID);

  if (data.MID) {
    const midData = lookupMID(data.MID);
    addLine(lines, "Country", midData.country);
  }

  addLine(lines, "Destination", data.Destination && data.Destination.trim() !== "" ? data.Destination : null);
  addLine(lines, "Speed", (data.Sog != null ? `${data.Sog} kn` : null));

  if (data.Type !== undefined) {
    const typeDescription = staticTypeMapping[data.Type] || data.Type;
    addLine(lines, "Type", typeDescription);
  }

  addLine(lines, "Maximum Draught", (data.MaximumStaticDraught != null ? `${data.MaximumStaticDraught} m` : null));

  if (data.NavigationalStatus !== undefined) {
    const navStatusDescription = navigationalStatusMapping[data.NavigationalStatus] || data.NavigationalStatus;
    addLine(lines, "Nav Status", navStatusDescription);
  }

  return `<div class="popup-content">${lines.join('<br>')}</div>`;
}



function lookupMID(mid) {
  if (mids.hasOwnProperty(mid)) {
    return {
      shortcode: mids[mid][0] || "Unknown",   // Country short code
      country: mids[mid][3] || "Unknown" // Country name
    };
  }
  return {
    shortcode: "ZZ",
    country: "Unknown"
  };
}


function buildTooltipLine(...values) {
  return values
    .filter(val => val !== null && val !== undefined && (typeof val === "string" ? val.trim() !== "" : true))
    .join(" | ");
}

// Helper to add a line if the value is valid
function addLine(lines, label, value, formatFn) {
  if (value !== null && value !== undefined && value !== "") {
    lines.push(`${label}: ${formatFn ? formatFn(value) : value}`);
  }
}

function getLatLngs(track) {
  return track.map(pt => [pt[1], pt[2]]);
}

function filterTrackPoints(track) {
  const historyHours = parseInt(document.getElementById("history-slider").value, 10);
  const now = Date.now();
  return track.filter(pt => {
    // Convert the point's timestamp to milliseconds.
    const pointTime = new Date(pt[0]).getTime();
    return (now - pointTime) <= historyHours * 3600000;
  });
}

function createCircleIcon(vesselState) {
  // Get a color that is consistent for the vessel type
  const color = getColorForVesselTypeConsistent(vesselState.Type);
  // Return a divIcon with circular styling
  return L.divIcon({
    html: `<div style="
              width: 12px;
              height: 12px;
              background: ${color};
              border: 0px;
              border-radius: 50%;
           "></div>`,
    className: '', // Optionally leave className empty to prevent extra styling
    iconSize: [12, 12],
    iconAnchor: [6, 6]
  });
}

function createDetailContent(data) {
  const lines = [];
  const lastSeen = data.lastUpdate ? timeAgo(data.lastUpdate) : null;
  addLine(lines, "Last Update", lastSeen);
  addLine(lines, "Messages", data.NumMessages);
  addLine(lines, "MMSI", data.UserID);
  addLine(lines, "AIS Class", data.AISClass);

if (data.MID) {
  const midData = lookupMID(data.MID);
  const countryFlag = `
    <div style="display: inline-flex; align-items: center; margin: 0;">
      <span style="line-height: 20px; margin-right: 8px;">Flag:</span>
      <img src="/flags/${midData.shortcode.toLowerCase()}.svg" 
           alt="${midData.country} Flag" 
           style="width: 30px; height: 20px; border: 1px solid black; object-fit: cover;"
           title="${midData.country}">
    </div>
  `;
  lines.push(countryFlag); // Add the flag with text directly to lines
}

  addLine(lines, "Call Sign", data.CallSign);
  addLine(lines, "IMO Number", data.ImoNumber);

  // Destination: show a default text if it's empty
  if (data.Destination && data.Destination.trim() !== "") {
    addLine(lines, "Destination", data.Destination);
  } else {
    lines.push("Destination: NO DEST");
  }

  addLine(lines, "Speed", (data.Sog != null ? `${data.Sog} kn` : null));
  addLine(lines, "Course", (data.Cog != null ? `${data.Cog}°` : null));

  if (data.TrueHeading != null && data.TrueHeading < 360) {
    addLine(lines, "Heading", `${data.TrueHeading}°`);
  }

  if (data.Type != null) {
    const typeDescription = staticTypeMapping[data.Type] || data.Type;
    addLine(lines, "Type", typeDescription);
  }

  if (data.Dimension) {
    const d = data.Dimension;
    // Calculate overall length and width, but only add if non-zero.
    const totalLength = (Number(d.A) || 0) + (Number(d.B) || 0);
    const totalWidth = (Number(d.C) || 0) + (Number(d.D) || 0);
    if (totalLength > 0 && totalWidth > 0) {
      lines.push(`Dimensions: ${totalLength}m x ${totalWidth}m`);
    }
  }

  if (data.Eta) {
    const e = data.Eta;
    const now = new Date();
    const etaDate = new Date(now.getFullYear(), e.Month - 1, e.Day, e.Hour, e.Minute);
    const etaFormatted = etaDate.toLocaleString('ja-JP', {
      year: 'numeric',
      month: '2-digit',
      day: '2-digit',
      hour: '2-digit',
      minute: '2-digit',
      hour12: false
    });
    lines.push(`ETA: ${etaFormatted}`);
  }

  if (data.FixType != null) {
    const fixDescription = fixTypeMapping[data.FixType] || data.FixType;
    addLine(lines, "Fix Type", fixDescription);
  }

  addLine(lines, "Maximum Draught", (data.MaximumStaticDraught != null ? `${data.MaximumStaticDraught} m` : null));
  addLine(lines, "Position Msg ID", data.MessageID);

  if (data.Latitude != null && data.Longitude != null) {
    addLine(lines, "Latitude", data.Latitude.toFixed(5));
    addLine(lines, "Longitude", data.Longitude.toFixed(5));
  }

  if (data.NavigationalStatus != null) {
    const navStatusDescription = navigationalStatusMapping[data.NavigationalStatus] || data.NavigationalStatus;
    addLine(lines, "Nav Status", navStatusDescription);
  }

  addLine(lines, "Rate Of Turn", (data.RateOfTurn != null ? `${data.RateOfTurn}°/min` : null));
  addLine(lines, "Timestamp", data.Timestamp);
  addLine(lines, "Position Accuracy", data.PositionAccuracy);

  if (data.CommunicationState != null) {
    const comm = decodeCommunicationState(data.CommunicationState);
    lines.push("Communication State:");
    lines.push(`- Sync State: ${comm.syncState}`);
    lines.push(`- Slot Timeout: ${comm.slotTimeout}`);
    lines.push(`- Slot Offset: ${comm.slotOffset}`);
  }

  if (data.MessageTypes && Array.isArray(data.MessageTypes)) {
    lines.push("Message Types:");
    data.MessageTypes.forEach(type => {
      const friendlyName = friendlyMessageTypes[type] || type;
      lines.push(`- ${friendlyName}`);
    });
  }

  return `<div class="popup-content">${lines.join('<br>')}</div>`;
}

function adjustMapBounds() {
  if (focusedVessel) {
    // When a vessel is focused, center solely on that vessel.
    map.setView(vesselMarkers[focusedVessel].getLatLng(), 13);
    return;
  }

  if (userLatLng) {
    // When no vessel is focused, find the vessel marker nearest to the user.
    let closestMarker = null;
    let closestDistance = Infinity;
    for (const key in vesselMarkers) {
      if (vesselMarkers.hasOwnProperty(key) && map.hasLayer(vesselMarkers[key])) {
        let markerLatLng = vesselMarkers[key].getLatLng();
        let distance = L.latLng(userLatLng).distanceTo(markerLatLng);
        if (distance < closestDistance) {
          closestDistance = distance;
          closestMarker = vesselMarkers[key];
        }
      }
    }
    if (closestMarker) {
      // Define a threshold distance in meters (adjust this value as needed)
      const threshold = 5000; // e.g. 5 km
      if (closestDistance < threshold) {
        // If the closest vessel is really close, use the default zoom (like on page load).
        map.setView(userLatLng, 10);
      } else {
        // Otherwise, fit bounds to include both the user and the closest vessel.
        let bounds = L.latLngBounds([userLatLng, closestMarker.getLatLng()]);
        map.fitBounds(bounds, { padding: [50, 50], maxZoom: 10 });
      }
    } else {
      // If no vessel markers exist, center on the user.
      map.setView(userLatLng, 10);
    }
  } else {
    // Fallback: if the user's location is unknown, use all vessel markers.
    let bounds = L.latLngBounds([]);
    for (const key in vesselMarkers) {
      if (vesselMarkers.hasOwnProperty(key) && map.hasLayer(vesselMarkers[key])) {
        bounds.extend(vesselMarkers[key].getLatLng());
      }
    }
    if (bounds.isValid()) {
      map.fitBounds(bounds, { padding: [50, 50] });
    }
  }
}

        // Utility: Compute a time elapsed string.
        function timeAgo(timestamp) {
          const seconds = Math.floor((Date.now() - timestamp) / 1000);
          if (seconds < 60) return seconds + " sec ago";
          const minutes = Math.floor(seconds / 60);
          if (minutes < 60) return minutes + " min ago";
          const hours = Math.floor(minutes / 60);
          if (hours < 24) return hours + " hrs ago";
          const days = Math.floor(hours / 24);
          return days + " days ago";
        }

function updateStationaryMarkers() {
  const showStationary = document.getElementById('stationary').checked;
  const onlyFocussed = document.getElementById('only-focussed').checked;
  const showPaths = document.getElementById('show-paths').checked;

  for (const mmsi in vesselData) {
    // Always ensure the marker is visible.
    if (vesselMarkers[mmsi] && !map.hasLayer(vesselMarkers[mmsi])) {
      map.addLayer(vesselMarkers[mmsi]);
    }
    // Now handle track visibility based on only-focussed status.
    if (vesselTracks[mmsi]) {
      // If onlyFocussed is active and a vessel is focused,
      // then only display the track if this vessel is the focused one.
      if (onlyFocussed && focusedVessel) {
        if (mmsi === focusedVessel) {
          if (showPaths && !map.hasLayer(vesselTracks[mmsi])) {
            map.addLayer(vesselTracks[mmsi]);
          } else if (!showPaths && map.hasLayer(vesselTracks[mmsi])) {
            map.removeLayer(vesselTracks[mmsi]);
          }
        } else {
          // Ensure non-focused vessel tracks are not shown.
          if (map.hasLayer(vesselTracks[mmsi])) {
            map.removeLayer(vesselTracks[mmsi]);
          }
        }
      } else {
        // If not filtering by focus, add/remove tracks for every vessel normally.
        if (showPaths && !map.hasLayer(vesselTracks[mmsi])) {
          map.addLayer(vesselTracks[mmsi]);
        } else if (!showPaths && map.hasLayer(vesselTracks[mmsi])) {
          map.removeLayer(vesselTracks[mmsi]);
        }
      }
    }
  }
  updateOverlay();
}



        // Update the known vessels overlay.
function updateOverlay() {
  const filterText = document.getElementById('vessel-filter').value.trim().toLowerCase();
  // When a search is in progress (i.e. 3+ characters are entered), do not update the overlay.
  if (filterText.length >= 3) {
    return;
  }

  const maxAgeHours = parseInt(document.getElementById('age-slider').value, 10);
  const now = Date.now();

  // Get arrays of vessels and receivers.
  const vesselArray = Object.values(vesselData);
  const receiverArray = Object.values(receiverData);

  // Merge the two arrays.
  const combinedEntries = vesselArray.concat(receiverArray);

  // Filter entries that have a name and valid update time.
  const validEntries = combinedEntries.filter(entry => entry.Name && entry.LastUpdated);

  // Filter the entries by the filter text (if any) and age.
  const filteredEntries = validEntries.filter(entry => {
    const textMatch =
      entry.Name.toLowerCase().includes(filterText) ||
      (entry.CallSign && entry.CallSign.toLowerCase().includes(filterText)) ||
      entry.UserID.toString().includes(filterText);
    const entryTime = new Date(entry.LastUpdated).getTime();
    const withinAge = (now - entryTime) <= maxAgeHours * 3600000;
    return textMatch && withinAge;
  });

  // Sort by update time (newest first).
  filteredEntries.sort((a, b) => new Date(b.LastUpdated) - new Date(a.LastUpdated));
  const topEntries = filteredEntries.slice(0, 100);

  const bounds = map.getBounds();
  let visibleCount = 0;
  for (const id in vesselMarkers) {
    if (map.hasLayer(vesselMarkers[id])) visibleCount++;
  }
  for (const id in receiverMarkers) {
    if (bounds.contains(receiverMarkers[id].getLatLng())) {
	visibleCount++;
    }
  }

  // Update the overlay count text.
  document.getElementById('vessel-count').innerHTML =
    `${topEntries.length} of ${filteredEntries.length} entries<br>${visibleCount} visible on map`;

  // Build the HTML content for the overlay.
  let content = "";
  topEntries.forEach(entry => {
    const name = entry.Name;
    const lastSeen = timeAgo(new Date(entry.LastUpdated).getTime());
    const numMessages = entry.NumMessages || 0;
    const extraInfo = entry.isReceiver
      ? `<div class="vessel-callsign">Receiver</div>`
      : `<div class="vessel-callsign">Call Sign: ${entry.CallSign ? entry.CallSign : "N/A"}</div>`;
    content += `<div class="vessel-entry" data-userid="${entry.UserID}">
                  <div class="vessel-name">${name}</div>
                  ${extraInfo}
                  <div class="vessel-timestamp">${lastSeen} | ${numMessages} msgs</div>
                </div>`;
  });

  document.getElementById('overlay-content').innerHTML = content;

  // Attach click events for the overlay entries.
  document.querySelectorAll('.vessel-entry').forEach(entry => {
    entry.addEventListener('click', event => {
      event.stopPropagation();
      const userID = entry.getAttribute('data-userid');
      if (receiverData.hasOwnProperty(userID)) {
        const marker = receiverMarkers[userID];
        map.setView(marker.getLatLng(), 10);
        marker.openPopup();
      } else {
        document.getElementById('stationary').checked = true;
        updateStationaryMarkers();
        focusOnVessel(userID);
      }
    });
  });
}

// Helper function to check if the vessel is visible by the current age filter
function isVesselVisibleByAge(vessel, maxAgeHours, now) {
    const ageMilliseconds = now - vessel.lastUpdate;
    return ageMilliseconds <= maxAgeHours * 3600000; // Convert to milliseconds
}

// Helper function to check if the vessel is visible by the current age filter
function isVesselVisibleByAge(vessel) {
  const maxAgeHours = parseInt(document.getElementById("age-slider").value, 10);
  const now = Date.now();
  const ageMilliseconds = now - vessel.lastUpdate;
  return ageMilliseconds <= maxAgeHours * 3600000; // Convert to milliseconds
}



        // Periodically update the vessel detail overlay.
        function updateVesselDetailOverlay() {
          if (!detailsOverlayHidden && focusedVessel && vesselData[focusedVessel]) {
            const detailContent = createDetailContent(vesselData[focusedVessel]);
            document.getElementById('detail-content').innerHTML = detailContent;
          }
        }
        setInterval(updateVesselDetailOverlay, 1000);
        setInterval(updateOverlay, 1000);

        // Update marker and track visibility based on the "Only Tracked" checkbox.
function updateFocussedVisibility() {
  if (focusedVessel) {
    if (!map.hasLayer(vesselMarkers[focusedVessel])) {
      map.addLayer(vesselMarkers[focusedVessel]);
    }
    const showPaths = document.getElementById('show-paths').checked;
    if (vesselTracks[focusedVessel]) {
      if (showPaths && !map.hasLayer(vesselTracks[focusedVessel])) {
        map.addLayer(vesselTracks[focusedVessel]);
      } else if (!showPaths && map.hasLayer(vesselTracks[focusedVessel])) {
        map.removeLayer(vesselTracks[focusedVessel]);
      }
    }
  }
  updateOverlay();
}


        // --- Live Logs functionality ---
        const maxLogMessages = 250;
        const liveLogsContent = document.getElementById('live-logs-content');

        // Helper function to recursively format nested objects with indentation.
        function formatLogField(key, value, indentLevel = 0) {
          const indentStyle = `style="padding-left: ${indentLevel * 15}px"`;
          let html = `<div ${indentStyle}><span class="log-field">${key}:</span> `;
          if (value !== null && typeof value === 'object') {
            html += `<br>`;
            for (const subKey in value) {
              html += formatLogField(subKey, value[subKey], indentLevel + 1);
            }
          } else {
            html += `${value}`;
          }
          html += `</div>`;
          return html;
        }

        // Updated renderLogMessage function that uses the recursive formatter.
    function renderLogMessage(msg) {
      const logTimestamp = msg.timestamp
        ? new Date(msg.timestamp).toLocaleTimeString()
        : new Date().toLocaleTimeString();

      // Wrap the log entry in a container with a data-type attribute.
      let html = `<div class="log-entry" data-type="${msg.type}">`;
      html += `<div class="log-timestamp" style="font-size:10px;color:#888;margin-bottom:2px;">${logTimestamp}</div>`;
      html += formatLogField("Type", msg.type);

      for (const field in msg.data) {
        html += formatLogField(field, msg.data[field]);
      }

      html += '</div>';
      return html;
    }

function subscribeInstantUpdates(userID) {
  // Build the channel name and subscribe.
  instantChannel = "ais_data/" + userID;
  socket.emit("subscribe", instantChannel);

  // Define the generic handler that updates the vessel's data
  // and its marker position on the map.
  instantHandler = function(message) {
    // Parse string messages if needed.
    if (typeof message === "string") {
      try {
        message = JSON.parse(message);
      } catch (e) {
        console.error("Error parsing message:", e);
        return;
      }
    }

    // Filter out message types not allowed.
    if (!allowedMessageTypes[message.type]) {
      return;
    }

    // Update each field present in the incoming message.
    if (message.data && message.data.UserID) {
      Object.keys(message.data).forEach(function(field) {
        vesselData[userID][field] = message.data[field];
      });
    }

    if (message.timestamp) {
      vesselData[userID].lastUpdate = new Date(message.timestamp).getTime();
    }

    // If the message includes valid position data, update marker and track.
    if (typeof message.data.Latitude === "number" &&
        typeof message.data.Longitude === "number") {

      // Update the marker position and popup content.
      if (vesselMarkers[userID]) {
        vesselMarkers[userID].setLatLng([message.data.Latitude, message.data.Longitude]);
        const popupContent = createPopupContent(vesselData[userID]);
        vesselMarkers[userID].getPopup().setContent(popupContent);
        
        // Update the SVG icon rotation if applicable.
        const heading = (typeof message.data.TrueHeading === "number" && message.data.TrueHeading < 360)
          ? message.data.TrueHeading
          : (message.data.Cog != null ? message.data.Cog : 0);
        const markerElem = vesselMarkers[userID].getElement() || vesselMarkers[userID]._icon;
        if (markerElem) {
          const svg = markerElem.querySelector('svg');
          if (svg) {
            svg.style.transform = `rotate(${heading}deg)`;
          }
        }
      }

  if (focusedVessel && userID !== focusedVessel) {
    if (vesselTracks[userID] && map.hasLayer(vesselTracks[userID])) {
      map.removeLayer(vesselTracks[userID]);
    }
    // Skip updating history for this vessel.
    return;
  }
      
      // Append the new position to the vessel's track.
      vesselData[userID].track = vesselData[userID].track || [];
      vesselData[userID].track.push([
        message.timestamp,
        message.data.Latitude,
        message.data.Longitude,
        (message.data.Sog != null ? message.data.Sog : null),
        (message.data.Cog != null ? message.data.Cog : null),
        (message.data.TrueHeading != null ? message.data.TrueHeading : null)
      ]);
      
      // Filter the track based on history slider settings.
      const filteredTrack = filterTrackPoints(vesselData[userID].track);
      
      // --- Update the vessel track using the speed-based colored polyline ---
      // Remove any existing track for this vessel.
      if (vesselTracks[userID]) {
        map.removeLayer(vesselTracks[userID]);
      }
      // Create a new colored track using createColoredTrack.
      vesselTracks[userID] = createColoredTrack(filteredTrack);
      map.addLayer(vesselTracks[userID]);
      // Reattach event handlers (e.g., for mousemove popups) to the new colored track.
      attachPolylineEvents(vesselTracks[userID], userID);
    }

    // Update the vessel detail overlay.
    updateVesselDetailOverlay();

    // Also, add the message to the live logs modal.
    addLiveLogEntry(message);
  };

  // Attach the handler to the socket.
  socket.on("ais_data", instantHandler);
}



    function unsubscribeInstantUpdates() {
      if (instantChannel && instantHandler) {
        socket.emit("unsubscribe", instantChannel);
        socket.off("ais_data", instantHandler);
      }
      instantChannel = null;
      instantHandler = null;
    }

    function addLiveLogEntry(message) {
      // Remove the placeholder if it exists.
      const placeholder = liveLogsContent.querySelector('.placeholder');
      if (placeholder) {
        placeholder.remove();
      }

      // Render the log entry.
      const logHTML = renderLogMessage(message);
      liveLogsContent.insertAdjacentHTML('afterbegin', logHTML);

      // Get the newly added entry (assumed to be the first child).
      const newEntry = liveLogsContent.firstElementChild;
      // Save the original message object on the entry.
      newEntry.originalMessage = message;
      // Also save the full HTML so we can revert if no search is active.
      newEntry.dataset.fullHtml = newEntry.innerHTML;

      // Apply filters immediately.
      applyLogFilters();

      // Limit the total number of log entries.
      while (liveLogsContent.childElementCount > maxLogMessages) {
        liveLogsContent.removeChild(liveLogsContent.lastChild);
      }
    }


function applyLogFilters() {
  const logEntries = liveLogsContent.querySelectorAll('.log-entry');
  const searchQuery = document.getElementById('live-log-search').value.toLowerCase();
  const showAll = document.getElementById('log-filter-all')?.checked;

  logEntries.forEach(entry => {
    // If "All" is checked, ignore type filtering
    if (showAll) {
      if (!searchQuery) {
        entry.innerHTML = entry.dataset.fullHtml;
        entry.style.display = '';
      } else {
        // Rebuild content based on search query if one exists
        const msg = entry.originalMessage;
        const logTimestamp = msg.timestamp
          ? new Date(msg.timestamp).toLocaleTimeString()
          : new Date().toLocaleTimeString();
        let newHtml = `<div class="log-timestamp" style="font-size:10px;color:#888;margin-bottom:2px;">${logTimestamp}</div>`;
        let fieldMatched = false;
        for (const field in msg.data) {
          const value = msg.data[field];
          if (
            field.toLowerCase().includes(searchQuery) ||
            String(value).toLowerCase().includes(searchQuery)
          ) {
            newHtml += formatLogField(field, value);
            fieldMatched = true;
          }
        }
        if (fieldMatched) {
          entry.innerHTML = newHtml;
          entry.style.display = '';
        } else {
          entry.style.display = 'none';
        }
      }
      return; // Skip further type filtering.
    }

    // Otherwise, filter by type as before.
    const type = entry.getAttribute('data-type');
    const matchesType = liveLogFilters[type];

    if (!matchesType) {
      entry.style.display = 'none';
      return;
    }

    if (!searchQuery) {
      entry.innerHTML = entry.dataset.fullHtml;
      entry.style.display = '';
      return;
    }

    // Apply search filtering if a query exists.
    const msg = entry.originalMessage;
    const logTimestamp = msg.timestamp
      ? new Date(msg.timestamp).toLocaleTimeString()
      : new Date().toLocaleTimeString();
    let newHtml = `<div class="log-timestamp" style="font-size:10px;color:#888;margin-bottom:2px;">${logTimestamp}</div>`;
    let fieldMatched = false;
    for (const field in msg.data) {
      const value = msg.data[field];
      if (
        field.toLowerCase().includes(searchQuery) ||
        String(value).toLowerCase().includes(searchQuery)
      ) {
        newHtml += formatLogField(field, value);
        fieldMatched = true;
      }
    }
    if (fieldMatched) {
      entry.innerHTML = newHtml;
      entry.style.display = '';
    } else {
      entry.style.display = 'none';
    }
  });
}

	document.getElementById('log-filter-all').addEventListener('change', applyLogFilters);

        // When the Live Logs button is clicked.
        document.getElementById('live-logs').addEventListener('click', () => {
          const overlay = document.getElementById('live-logs-overlay');
          overlay.style.display = 'block';
          clearLiveLogs();
        });

        // When the close button on the Live Logs overlay is clicked.
        document.getElementById('close-live-logs').addEventListener('click', () => {
          const overlay = document.getElementById('live-logs-overlay');
          overlay.style.display = 'none';
          clearLiveLogs();
        });

        // Make the Live Logs overlay draggable.
        (function makeDraggable() {
          const overlay = document.getElementById('live-logs-overlay');
          const header = document.getElementById('live-logs-header');
          let offsetX = 0, offsetY = 0, isDragging = false;

          header.addEventListener('mousedown', (e) => {
            isDragging = true;
            offsetX = e.clientX - overlay.offsetLeft;
            offsetY = e.clientY - overlay.offsetTop;
          });

          document.addEventListener('mousemove', (e) => {
            if (isDragging) {
              overlay.style.left = (e.clientX - offsetX) + 'px';
              overlay.style.top = (e.clientY - offsetY) + 'px';
            }
          });

          document.addEventListener('mouseup', () => {
            isDragging = false;
          });
        })();

        // Load saved vessel data from localStorage if available.
        const storedData = localStorage.getItem('vesselData');
        if (storedData) {
          try {
            const parsedData = JSON.parse(storedData);
            Object.keys(parsedData).forEach(userID => {
              vesselData[userID] = parsedData[userID];
              if (
                vesselData[userID].Latitude !== undefined &&
                vesselData[userID].Longitude !== undefined
              ) {
                const lat = vesselData[userID].Latitude;
                const lon = vesselData[userID].Longitude;
                const popupContent = createPopupContent(vesselData[userID]);
		const marker = L.marker(
		  [vesselData[userID].Latitude, vesselData[userID].Longitude],
		  { icon: getVesselIcon(vesselData[userID]) }
		).addTo(map);

		marker.on('add', function() {
		  const markerElem = marker.getElement();
		  if (markerElem) {
		    const svg = markerElem.querySelector('svg');
		    if (svg) {
		      const heading = 
 			 (typeof vesselData[userID].TrueHeading === 'number' && vesselData[userID].TrueHeading < 360)
			    ? vesselData[userID].TrueHeading
			    : (typeof vesselData[userID].Cog === 'number' && vesselData[userID].Cog >= 0 && vesselData[userID].Cog < 360)
			      ? vesselData[userID].Cog
			      : 0;  // Default to 0° if neither TrueHeading nor Cog is valid
		      if (heading !== undefined) {
		        svg.style.transform = `rotate(${heading}deg)`;
		      }
		    }
		  }
    	      if (markerElem) {
    	       const svg = markerElem.querySelector('svg');
    		 if (svg) {
    		    svg.addEventListener('click', (e) => {
    		      if (e && typeof e.stopPropagation === 'function') {
    		        e.stopPropagation();
    		      }
    		      focusOnVessel(userID);
    		    });
    		  }
    	       }
    	    });
                marker.bindPopup(popupContent, { autoPan: false });
                if (vesselData[userID].Name) {
                  marker.bindTooltip(vesselData[userID].Name, {
                    permanent: true,
                    direction: 'top',
                    className: 'vessel-tooltip',
                    interactive: true
                  }).openTooltip();
                  attachTooltipClick(marker, userID);
                }
                marker.on('click', function(e) {
      	      if (e && typeof e.stopPropagation === 'function') {
    	        e.stopPropagation();
    	      }
    	      if (e && typeof e.preventDefault === 'function') {
    	        e.preventDefault();
    	      }
    	      focusOnVessel(userID);
    	    });
    	    const markerElem = marker.getElement() || marker._icon;
    	    if (markerElem) {
    	      markerElem.addEventListener('click', (e) => {
    	        if (e && typeof e.stopPropagation === 'function') {
    	          e.stopPropagation();
    	        }
       	    focusOnVessel(userID);
    	      });
    	    }
                if (!isMobile) {
                  marker.on('mouseover', function() { this.openPopup(); });
                  marker.on('mouseout', function() { this.closePopup(); });
                }
                vesselMarkers[userID] = marker;
              }
		if (vesselData[userID].track && vesselData[userID].track.length > 0) {
		  vesselTracks[userID] = L.polyline(getLatLngs(vesselData[userID].track), {
		    color: vesselData[userID].color,
		    weight: 3,
		    opacity: 0.8,
		    interactive: true
		  }).addTo(map);
		  attachPolylineEvents(vesselTracks[userID], userID);
		}
            });
            debouncedAdjustMapBounds();
            updateOverlay();
	    updateStationaryMarkers();
          } catch (e) {
            console.error("Error loading stored vessel data", e);
          }
        }

        // Listen for changes to the "Only Tracked" and "OpenSeaMap Overlay" checkboxes.
        document.getElementById('only-focussed').addEventListener('change', () => {
  	    updateFocussedVisibility();
	    updateStationaryMarkers();
	    sendSummaryRequest();
            updateOverlay();
	});
	document.getElementById('openseamap-overlay').addEventListener('change', () => {
	  const overlayEnabled = document.getElementById('openseamap-overlay').checked;
	  if (overlayEnabled) {
	    if (!map.hasLayer(openSeaMapLayer)) {
	      map.addLayer(openSeaMapLayer);
	    }
	    // Bring it to the front after it’s added.
	    openSeaMapLayer.bringToFront();
	  } else {
	    if (map.hasLayer(openSeaMapLayer)) {
	      map.removeLayer(openSeaMapLayer);
	    }
	  }
	});

        // Connect to the Socket.IO server.
        const socket = io();
        let instantChannel = null;
        let instantHandler = null;

        // Listen for the socket connection event.
        socket.on('connect', () => {
          document.getElementById('status-dot').style.background = 'green';
          document.getElementById('status-text').textContent = 'Connected';
	  socket.emit("subscribe", "latest_vessel_summary");
	  // If a vessel is focused, resubscribe to its channel.
	  if (focusedVessel) {
	    subscribeInstantUpdates(focusedVessel);
  	}
        });

        // Listen for the socket disconnection event.
        socket.on('disconnect', () => {
          document.getElementById('status-dot').style.background = 'red';
          document.getElementById('status-text').textContent = 'Disconnected';
        });

socket.on("latest_vessel_summary", (data) => {
  const ageSlider = document.getElementById('age-slider');
  const maxAgeHours = parseInt(ageSlider.value, 10); // Get max-age from the slider
  const now = Date.now();
  const maxAgeMilliseconds = maxAgeHours * 3600000;  // Convert hours to milliseconds

  if (typeof data === "string") {
    try {
      data = JSON.parse(data);
    } catch (e) {
      console.error("Failed to parse JSON:", e);
      return;
    }
  }
  if (typeof data !== "object" || Array.isArray(data)) {
    console.error("Received invalid data format:", data);
    return;
  }

  // Remove vessels that no longer appear in the summary data.
  const newIDs = new Set(Object.keys(data));
  for (const mmsi in vesselData) {
    // Only remove if the vessel is not in the latest summary AND is not manually focused
    if (!newIDs.has(mmsi) && mmsi !== focusedVessel) {
      if (vesselMarkers[mmsi]) map.removeLayer(vesselMarkers[mmsi]);
      if (vesselTracks[mmsi]) map.removeLayer(vesselTracks[mmsi]);
      delete vesselData[mmsi];
      delete vesselMarkers[mmsi];
      delete vesselTracks[mmsi];
    }
  }

  for (const mmsi in data) {
    const vesselState = data[mmsi];
    const vesselTimestamp = new Date(vesselState.LastUpdated).getTime();

    // Create new vessel data if not already present.
    if (!vesselData[mmsi]) {
      vesselData[mmsi] = Object.assign({}, vesselState);
      vesselData[mmsi].track = [];
      vesselData[mmsi].color = randomColor();
    } else {
      // For a focused vessel, update only non-location/movement fields.
      if (mmsi === focusedVessel) {
        // Destructure to remove the location/movement fields.
        const { Latitude, Longitude, Sog, Cog, TrueHeading, ...nonLocationData } = vesselState;
        Object.assign(vesselData[mmsi], nonLocationData);
      } else {
        // Not in focus, so merge all fields.
        Object.assign(vesselData[mmsi], vesselState);
      }
    }
    // Always update these timestamp fields.
    vesselData[mmsi].LastUpdated = vesselState.LastUpdated;
    vesselData[mmsi].lastUpdate = vesselTimestamp;

    const popupContent = createPopupContent(vesselData[mmsi]);

    // Update marker/track if location data exists…
    if (typeof vesselState.Latitude === "number" && typeof vesselState.Longitude === "number") {
      if (mmsi !== focusedVessel) {
        // For vessels not in focus, update location and movement fields.
        const lat = vesselState.Latitude;
        const lon = vesselState.Longitude;
        if (vesselMarkers[mmsi]) {
          vesselMarkers[mmsi].setLatLng([lat, lon]);
          vesselMarkers[mmsi].getPopup().setContent(popupContent);
          const markerElem = vesselMarkers[mmsi].getElement() || vesselMarkers[mmsi]._icon;
          if (markerElem) {
            const svg = markerElem.querySelector('svg');
            if (svg) {
              const heading =
                (typeof vesselState.TrueHeading === 'number' && vesselState.TrueHeading < 360)
                  ? vesselState.TrueHeading
                  : (typeof vesselState.Cog === 'number' && vesselState.Cog >= 0 && vesselState.Cog < 360)
                    ? vesselState.Cog
                    : 0;
              svg.style.transform = `rotate(${heading}deg)`;
            }
          }
          if (vesselState.Name && mmsi !== focusedVessel) {
            vesselMarkers[mmsi].unbindTooltip();
            if (map.getZoom() >= TOOLTIP_ZOOM_THRESHOLD) {
              vesselMarkers[mmsi].bindTooltip(vesselState.Name, {
                permanent: true,
                direction: 'top',
                className: 'vessel-tooltip',
                interactive: true
              }).openTooltip();
              attachTooltipClick(vesselMarkers[mmsi], mmsi);
            }
          }
          vesselMarkers[mmsi].off('click');
          vesselMarkers[mmsi].on('click', function(e) {
            if (e && typeof e.stopPropagation === 'function') { e.stopPropagation(); }
            if (e && typeof e.preventDefault === 'function') { e.preventDefault(); }
            focusOnVessel(mmsi);
          });
          const markerElem2 = vesselMarkers[mmsi].getElement() || vesselMarkers[mmsi]._icon;
          if (markerElem2) {
            markerElem2.classList.add('enlarge');
            setTimeout(() => markerElem2.classList.remove('enlarge'), 500);
          }
        } else {
          const marker = L.marker(
            [vesselState.Latitude, vesselState.Longitude],
            { icon: getVesselIcon(vesselData[mmsi]) }
          ).addTo(map);
          marker.bindPopup(popupContent, { autoPan: false });
          const currentZoom = map.getZoom();
          if (currentZoom >= TOOLTIP_ZOOM_THRESHOLD && vesselState.Name) {
            marker.bindTooltip(vesselState.Name, {
              permanent: true,
              direction: 'top',
              className: 'vessel-tooltip',
              interactive: true
            }).openTooltip();
            attachTooltipClick(marker, mmsi);
          }
          marker.on('click', function(e) {
            if (e && typeof e.stopPropagation === 'function') { e.stopPropagation(); }
            if (e && typeof e.preventDefault === 'function') { e.preventDefault(); }
            focusOnVessel(mmsi);
          });
          if (!isMobile) {
            marker.on('mouseover', function() { this.openPopup(); });
            marker.on('mouseout', function() { this.closePopup(); });
          }
          vesselMarkers[mmsi] = marker;
        }
        const filteredTrack = filterTrackPoints(vesselData[mmsi].track);
        if (vesselTracks[mmsi]) {
	  map.removeLayer(vesselTracks[mmsi]);
	}
	vesselTracks[mmsi] = createColoredTrack(filteredTrack);
	map.addLayer(vesselTracks[mmsi]);
	attachPolylineEvents(vesselTracks[mmsi], mmsi);
      } else {
        // For a focused vessel, skip location updates—only update its popup.
        if (vesselMarkers[mmsi]) {
          vesselMarkers[mmsi].getPopup().setContent(popupContent);
        }
      }
    } else {
      if (vesselMarkers[mmsi]) {
        vesselMarkers[mmsi].getPopup().setContent(popupContent);
        vesselMarkers[mmsi].unbindTooltip();
        vesselMarkers[mmsi].bindTooltip(popupContent, {
          direction: 'top',
          className: 'vessel-tooltip'
        });
      }
    }

    if (focusedVessel && focusedVessel == mmsi && !detailsOverlayHidden) {
      if (isMobile) {
        map.panTo(vesselMarkers[mmsi].getLatLng());
      } else {
        focusOnVessel(mmsi, false);
      }
    }
  }
  updateOverlay();
  updateFocussedVisibility();
  updateStationaryMarkers();
  localStorage.setItem('vesselData', JSON.stringify(vesselData));
});

// Use a debounced function to limit the frequency of requests:
// Global variables to store the current search query and the interval timer.
let currentSearchQuery = '';
let searchInterval = null;

document.getElementById('vessel-filter').addEventListener('input', function(event) {
  // Update current search query with trimmed value.
  currentSearchQuery = event.target.value.trim();

  // Check if the query meets the length threshold.
  if (currentSearchQuery.length < 3) {
    // If below threshold, clear any active search interval.
    if (searchInterval) {
      clearInterval(searchInterval);
      searchInterval = null;
    }
    // Update the overlay normally.
    updateOverlay();
    return;
  }

  // If the query length is 3 or more:
  // Call the search function immediately.
  performSearch(currentSearchQuery);

  // If no interval is already running, set one up for every 5 seconds.
  if (!searchInterval) {
    searchInterval = setInterval(() => {
      // Use the latest query value in case the user modifies it.
      performSearch(currentSearchQuery);
    }, 10000);
  }
});

// Function that performs the search fetch.
function performSearch(query) {
  // Get the current max-age value from the age slider (in hours)
  const ageSlider = document.getElementById("age-slider");
  const maxAge = parseInt(ageSlider.value, 10); // Convert the value to an integer

  // Include both the query and the max-age (with field name "MaxAge") in the request body.
  fetch('/search', {
    method: 'POST',
    headers: { 'Content-Type': 'application/json' },
    body: JSON.stringify({ query: query, MaxAge: maxAge })
  })
  .then(response => {
    if (!response.ok) {
      throw new Error(`Server error: ${response.status}`);
    }
    return response.json();
  })
  .then(searchResults => {
    const receiverResults = Object.values(receiverData).filter(receiver => {
      const q = query.toLowerCase();
      return (
        receiver.Name.toLowerCase().includes(q) ||
        (receiver.CallSign && receiver.CallSign.toLowerCase().includes(q)) ||
        receiver.UserID.toString().includes(q)
      );
    });

    // Merge the two arrays and render the results.
    const combinedResults = searchResults.concat(receiverResults);
    renderSearchResults(combinedResults);
  })
  .catch(err => {
    console.error('Search request failed:', err);
    updateOverlay();
  });
}


        document.getElementById('clear-history').addEventListener('click', clearHistory);

	document.getElementById('stationary').addEventListener('change', () => {
  	  sendSummaryRequest();
    	  updateStationaryMarkers();
	});

        // Attach tooltip click listener.
        function attachTooltipClick(marker, userID) {
          setTimeout(() => {
            const tooltip = marker.getTooltip();
            if (tooltip) {
              const ttEl = tooltip.getElement();
              if (ttEl) {
                ttEl.addEventListener('click', (e) => {
                  if (e && typeof e.stopPropagation === 'function') {
 		     e.stopPropagation();
		   }
                  focusOnVessel(userID);
                });
              }
            }
          }, 0);
        }

	let lastFetchedUserID = null;

	function fetchMissingData(userID) {
	  // Only fetch if this vessel hasn't already had its missing data fetched this selection.
	  if (lastFetchedUserID === userID) return;

	  fetch(`/state/${userID}`)
	    .then(response => {
	      if (!response.ok) {
	        throw new Error(`Network response was not ok (${response.status})`);
	      }
	      return response.json();
	    })
	    .then(data => {
	      Object.assign(vesselData[userID], data);
	      updateVesselDetailOverlay();
	      lastFetchedUserID = userID;
	    })
	    .catch(err => {
	      console.error("Error fetching missing vessel data:", err);
	    });
	}

// Function to find the nearest point on the polyline track to the mouse event latlng.
function getNearestTrackPoint(e, track) {
  const mouseLatLng = e.latlng;
  let minDistance = Infinity;
  let nearestPoint = null;
  
  // Iterate over each point in the track (each point is [timestamp, lat, lon])
  track.forEach(pt => {
    // Create a Leaflet LatLng object for comparison.
    const ptLatLng = L.latLng(pt[1], pt[2]);
    const distance = mouseLatLng.distanceTo(ptLatLng);
    if (distance < minDistance) {
      minDistance = distance;
      nearestPoint = { ptLatLng, info: pt };
    }
  });
  return nearestPoint;
}




// Focus on a particular vessel.
function focusOnVessel(userID, initialFocus = true) {
  // Unfocus previously focused vessel
  document.getElementById('show-paths').checked = true;
  if (focusedVessel && focusedVessel !== userID) {
    const prevMarker = vesselMarkers[focusedVessel];
    if (prevMarker) {
      // If a tooltip exists, update its content; otherwise, bind a default one.
      let prevTooltip = prevMarker.getTooltip();
      if (!prevTooltip) {
        prevMarker.bindTooltip(vesselData[focusedVessel].Name, {
          permanent: true,
          direction: 'top',
          className: 'vessel-tooltip'
        });
        prevTooltip = prevMarker.getTooltip();
      }
      if (prevTooltip) {
        prevTooltip.setContent(vesselData[focusedVessel].Name);
      }
      prevMarker.closeTooltip();
      prevMarker.setZIndexOffset(0);
      const prevElem = prevMarker.getElement();
      if (prevElem) {
        prevElem.classList.remove('enlarge');
      }
    }
  }
  
  // Update subscriptions if focusing on a new vessel
  if (focusedVessel !== userID) {
    clearLiveLogs();
    if (instantChannel) {
      unsubscribeInstantUpdates();
    }
    subscribeInstantUpdates(userID);
    hydrateTrackHistory(userID);
  }
  
  // (Optional) Reset tooltip for the previously focused vessel if needed
  if (focusedVessel && focusedVessel !== userID) {
    const prevMarker = vesselMarkers[focusedVessel];
    if (prevMarker) {
      let prevTooltip = prevMarker.getTooltip();
      if (!prevTooltip) {
        prevMarker.bindTooltip(vesselData[focusedVessel].Name, {
          permanent: true,
          direction: 'top',
          className: 'vessel-tooltip'
        });
        prevTooltip = prevMarker.getTooltip();
      }
      if (prevTooltip) {
        prevTooltip.setContent(vesselData[focusedVessel].Name);
      }
      prevMarker.closeTooltip();
      prevMarker.setZIndexOffset(0);
      const prevElem = prevMarker.getElement();
      if (prevElem) {
        prevElem.classList.remove('enlarge');
      }
    }
  }
  
  // Set the new focused vessel.
  focusedVessel = userID;

  for (const mmsi in vesselTracks) {
    if (mmsi !== focusedVessel && map.hasLayer(vesselTracks[mmsi])) {
      map.removeLayer(vesselTracks[mmsi]);
    }
  }

  // Now add the focused vessel’s polyline (if it exists) based on the "show-paths" checkbox.
  if (document.getElementById('show-paths').checked && vesselTracks[focusedVessel] && !map.hasLayer(vesselTracks[focusedVessel])) {
    map.addLayer(vesselTracks[focusedVessel]);
  }


  const marker = vesselMarkers[userID];
  if (!marker) return; // Ensure marker exists
  marker.setZIndexOffset(1000);
  const vessel = vesselData[userID];
  
  updateLatLongDisplay();
  
  // Build new tooltip content.
  const line1 = buildTooltipLine(
    vessel.Destination,
    (navigationalStatusMapping[vessel.NavigationalStatus] || vessel.NavigationalStatus) !== 'Unknown'
      ? (navigationalStatusMapping[vessel.NavigationalStatus] || vessel.NavigationalStatus)
      : null
  );
  const line2 = buildTooltipLine(
    staticTypeMapping[vessel.Type] || vessel.Type,
    (vessel.MaximumStaticDraught != null ? `${vessel.MaximumStaticDraught} m` : null),
    (vessel.Sog != null ? `${vessel.Sog} kn` : null),
    (vessel.TrueHeading != null ? `${vessel.TrueHeading}°` : null)
  );
  const tooltipLines = [`${vessel.Name} (${vessel.CallSign})`];
  if (line1.trim()) tooltipLines.push(line1);
  if (line2.trim()) tooltipLines.push(line2);
  tooltipLines.push(timeAgo(vessel.lastUpdate));
  const newTooltipContent = tooltipLines.join('<br>');
  
  // Make sure the marker has a tooltip before updating.
  let tooltip = marker.getTooltip();
  if (!tooltip) {
    marker.bindTooltip(newTooltipContent, {
      permanent: true,
      direction: 'top',
      className: 'vessel-tooltip',
      interactive: true
    }).openTooltip();
    tooltip = marker.getTooltip();
  } else {
    tooltip.setContent(newTooltipContent);
  }
  
  // Set tooltip element's z-index.
  const tooltipEl = tooltip.getElement();
  if (tooltipEl) {
    tooltipEl.style.zIndex = '1200';
  }
  
  // Show detail overlay and related buttons.
  document.getElementById('toggle-detail-overlay').style.display = 'block';
  document.getElementById('live-logs').style.display = 'block';
  document.getElementById('stats-button').style.display = 'block';
  
  const detailOverlay = document.getElementById('vessel-detail');
  if (!detailsOverlayHidden) {
    detailOverlay.style.display = 'block';
    document.getElementById('toggle-detail-overlay').textContent = 'Hide Details';
  } else {
    detailOverlay.style.display = 'none';
    document.getElementById('toggle-detail-overlay').textContent = 'Show Details';
  }
  
  if (isMobile) {
    setTimeout(() => {
      updateVesselDetailHeader(userID);
    }, 300);  // 300 ms delay; adjust as needed
  } else {
    updateVesselDetailHeader(userID);
  }
  
  // Attach copy link event.
  const copyLinkEl = document.getElementById('copy-link');
  if (copyLinkEl) {
    copyLinkEl.addEventListener('click', (e) => {
      if (e && typeof e.stopPropagation === 'function') {
        e.stopPropagation();
      }
      const currentUrl = window.location.href.split('?')[0];
      const copyUrl = `${currentUrl}?UserID=${vesselData[userID].UserID}`;
      function updateLinkText(newText) {
        copyLinkEl.textContent = newText;
        setTimeout(() => {
          copyLinkEl.textContent = "Link";
        }, 2000);
      }
      if (navigator.clipboard && navigator.clipboard.writeText) {
        navigator.clipboard.writeText(copyUrl).then(() => {
          updateLinkText("Link Copied");
        }).catch(err => {
          console.error("Failed to copy: ", err);
        });
      } else {
        const textArea = document.createElement("textarea");
        textArea.value = copyUrl;
        document.body.appendChild(textArea);
        textArea.select();
        try {
          document.execCommand('copy');
          updateLinkText("Link Copied");
        } catch (err) {
          console.error("Fallback: Unable to copy", err);
        }
        document.body.removeChild(textArea);
      }
    });
  }
  




// Helper function to show flash message
function showFlashMessage(message, parentEl) {
  const flashMsg = document.createElement('span');
  flashMsg.textContent = ` ${message}`;
  flashMsg.style.color = 'green';
  parentEl.appendChild(flashMsg);
  setTimeout(() => {
    flashMsg.remove();
  }, 1000);
}


         // Update the Live Logs modal title with the vessel name.
         const liveLogsTitle = document.getElementById('live-logs-title');
         if (vesselData[userID].Name) {
           liveLogsTitle.textContent = `${vesselData[userID].Name}`;
         } else {
           liveLogsTitle.textContent = 'Live Messages';
         }
          const detailContent = createDetailContent(vesselData[userID]);
          document.getElementById('detail-content').innerHTML = detailContent;

	  // Fetch missing data from /state/<UserID> and update overlay.
	  fetchMissingData(userID);

	if (initialFocus) {
	  const markerLatLng = vesselMarkers[userID].getLatLng();
	  const currentZoom = map.getZoom();
	  const desiredZoom = 13;
  
	  if (currentZoom >= desiredZoom) {
	    // If already zoomed in enough, just pan to the vessel's location.
	    map.panTo(markerLatLng);
	  } else {
	    // Otherwise, fit bounds and set the zoom to desiredZoom at most.
	    let bounds = L.latLngBounds([]);
	    bounds.extend(markerLatLng);
	    map.fitBounds(bounds, { padding: [50, 50], maxZoom: desiredZoom });
	  }
	}

          updateFocussedVisibility();
        }

        document.getElementById('toggle-known-overlay').addEventListener('click', function() {
          const overlay = document.getElementById('vessel-overlay');
          const currentDisplay = window.getComputedStyle(overlay).display;
          if (currentDisplay === 'none') {
            overlay.style.display = 'block';
            this.textContent = 'Hide Vessels';
	    const filterInput = document.getElementById('vessel-filter');
	    if (filterInput.value.trim().length >= 3) {
	      filterInput.dispatchEvent(new Event('input'));
	    }
          } else {
            overlay.style.display = 'none';
            this.textContent = 'Show Vessels';
          }
        });

        document.getElementById('toggle-detail-overlay').addEventListener('click', function() {
          const detailOverlay = document.getElementById('vessel-detail');
          if (detailOverlay.style.display === 'none' || detailOverlay.style.display === '') {
            detailOverlay.style.display = 'block';
            this.textContent = 'Hide Details';
            detailsOverlayHidden = false;
          } else {
            detailOverlay.style.display = 'none';
            this.textContent = 'Show Details';
            detailsOverlayHidden = true;
          }
       });

    const liveLogFilters = {
      "PositionReport": true,
      "ShipStaticData": true,
      "StaticDataReport": true,
      "StandardClassBPositionReport": true,
      "ExtendedClassBPositionReport": true,
      "AidsToNavigationReport": true,
      "BaseStationReport": true,
      "BinaryBroadcastMessage": true,
      "StandardSearchAndRescueAircraftReport": true
    };

    document.querySelectorAll('.log-filter').forEach(checkbox => {
      checkbox.addEventListener('change', function() {
        liveLogFilters[this.value] = this.checked;
        applyLogFilters();  // Use the new filter state in your live logs
      });
    });

       document.getElementById('stats-button').addEventListener('click', () => {
         if (focusedVessel) {
           // Open popup window with the current vessel's UserID.
           window.open('/stats.html?UserID=' + focusedVessel, '_blank', 'width=400,height=600');
         }
       });

window.addEventListener('load', () => {
  // Get URL parameters and check for the UserID parameter.
  const params = new URLSearchParams(window.location.search);
  const userIDParam = params.get('UserID');
  const skipUserZoom = Boolean(userIDParam);

  const filterInput = document.getElementById('vessel-filter');
  if (filterInput.value.trim().length >= 3) {
    filterInput.dispatchEvent(new Event('input'));
  }

  // If UserID is provided, fetch the summary and center the map accordingly.
  if (userIDParam) {
    fetch(`/summary?userID=${userIDParam}`)
      .then(response => {
        if (!response.ok) {
          throw new Error(`Network error: ${response.status}`);
        }
        return response.json();
      })
      .then(data => {
        const userSummary = data[userIDParam];

        // Validate that the summary contains valid Latitude and Longitude fields.
        if (userSummary && typeof userSummary.Latitude === 'number' && typeof userSummary.Longitude === 'number') {
          // Center the map on these coordinates; adjust the zoom level as needed.
          map.setView([userSummary.Latitude, userSummary.Longitude], 10);
        } else {
          console.warn('Summary data is missing valid latitude and longitude fields.');
        }
      })
      .catch(error => {
        console.error('Error fetching summary:', error);
      });
  }

  updateStationaryMarkers();
  if (navigator.geolocation) {
    navigator.geolocation.getCurrentPosition(
      (position) => {
        userLatLng = [position.coords.latitude, position.coords.longitude];
        const userMarker = L.marker(userLatLng, { draggable: true })
          .addTo(map)

      userMarker.on('dragend', function(e) {
        const newPos = e.target.getLatLng();
        userLatLng = [newPos.lat, newPos.lng];
        document.getElementById('latlong-display').textContent =
          `${newPos.lat.toFixed(5)}, ${newPos.lng.toFixed(5)}`;
      });        

        if (!skipUserZoom) {
          map.setView(userLatLng, 10);
        }

        // Allow some time for vessel markers to load or update
        setTimeout(() => {
          const bounds = map.getBounds();
          let vesselFound = false;
          let firstVesselLatLng = null;

          // Assume vesselMarkers is a global object containing your vessel markers
          for (const key in vesselMarkers) {
            if (vesselMarkers.hasOwnProperty(key)) {
              const marker = vesselMarkers[key];
              const markerLatLng = marker.getLatLng();
              if (!firstVesselLatLng) {
                firstVesselLatLng = markerLatLng; // store the first vessel position found
              }
              if (bounds.contains(markerLatLng)) {
                vesselFound = true;
                break;
              }
            }
          }

          // If no vessel marker is found in the current viewport and we have at least one vessel marker...
          if (!vesselFound && firstVesselLatLng) {
            // Create a bounds that includes both the user's location and the vessel marker
            const newBounds = L.latLngBounds([userLatLng, firstVesselLatLng]);
            // Fit the map to the new bounds with some padding
            map.fitBounds(newBounds, { padding: [50, 50] });
          }
        }, 1000); // 1 second delay; adjust if necessary
      },
      (error) => {
        debouncedAdjustMapBounds();
        map.fire('moveend');
      }
    );
  } else {
    debouncedAdjustMapBounds();
    map.fire('moveend');
  }

 refreshReceivers();
 setInterval(refreshReceivers, 60000);

  if (userIDParam) {
    // Delay the focus call to allow vessel markers to load
    setTimeout(() => {
      if (vesselMarkers[userIDParam]) {
        focusOnVessel(userIDParam);
      } else {
        console.warn(`Vessel with UserID ${userIDParam} not found.`);
      }
    }, 1500);
  }
});

document.getElementById('show-paths').addEventListener('change', function() {
  const showPaths = this.checked;
  const onlyFocussed = document.getElementById('only-focussed').checked;
  if (onlyFocussed && focusedVessel) {
    // Only toggle the focused vessel's track.
    if (vesselTracks[focusedVessel]) {
      if (showPaths && !map.hasLayer(vesselTracks[focusedVessel])) {
        map.addLayer(vesselTracks[focusedVessel]);
      } else if (!showPaths && map.hasLayer(vesselTracks[focusedVessel])) {
        map.removeLayer(vesselTracks[focusedVessel]);
      }
    }
  } else {
    // Toggle tracks for all vessels.
    for (const mmsi in vesselTracks) {
      if (showPaths && !map.hasLayer(vesselTracks[mmsi])) {
        map.addLayer(vesselTracks[mmsi]);
      } else if (!showPaths && map.hasLayer(vesselTracks[mmsi])) {
        map.removeLayer(vesselTracks[mmsi]);
      }
    }
  }
  updateFocussedVisibility();
});



// Conversion: 1 nautical mile = 1852 meters.
function updateNauticalScale() {
  const scaleLabel = document.getElementById('scale-label');
  const scalePx = 100;
  const center = map.getCenter();
  const point = map.latLngToContainerPoint(center);
  const pointX = L.point(point.x + scalePx, point.y);
  const latLngX = map.containerPointToLatLng(pointX);
  const distanceMeters = center.distanceTo(latLngX);
  const distanceNM = distanceMeters / 1852;
  scaleLabel.textContent = `${distanceNM.toFixed(1)} NM`;
}

// Update the scale whenever the map is zoomed or moved.
map.on('zoomend moveend', updateNauticalScale);
// Call once to set the initial scale.
updateNauticalScale();

function updateFocussedTooltip() {
  if (focusedVessel && vesselData[focusedVessel]) {
    const vessel = vesselData[focusedVessel];
    const line1 = buildTooltipLine(
      vessel.Destination,
      (navigationalStatusMapping[vessel.NavigationalStatus] || vessel.NavigationalStatus) !== 'Unknown'
        ? (navigationalStatusMapping[vessel.NavigationalStatus] || vessel.NavigationalStatus)
        : null
    );
    const line2 = buildTooltipLine(
      staticTypeMapping[vessel.Type] || vessel.Type,
      (vessel.MaximumStaticDraught != null ? `${vessel.MaximumStaticDraught} m` : null),
      (vessel.Sog != null ? `${vessel.Sog} kn` : null),
      (vessel.TrueHeading != null ? `${vessel.TrueHeading}°` : null)
    );

    const tooltipLines = [`${vessel.Name} (${vessel.CallSign})`];
    if (line1.trim()) tooltipLines.push(line1);
    if (line2.trim()) tooltipLines.push(line2);
    tooltipLines.push(timeAgo(vessel.lastUpdate));
    const newTooltipContent = tooltipLines.join('<br>');
    vesselMarkers[focusedVessel].getTooltip().setContent(newTooltipContent);
  }
}
setInterval(updateFocussedTooltip, 1000);


// Call updateLegend periodically to keep the legend up to date
setInterval(updateLegend, 5000); // Update every 5 seconds

document.getElementById('toggle-legend').addEventListener('click', function() {
  const legend = document.getElementById('vessel-legend');
  if (window.getComputedStyle(legend).display === 'none') {
    legend.style.display = 'block';  // Make it visible first
    updateLegend();                  // Then update the content immediately
    this.textContent = 'Hide Legend';
  } else {
    legend.style.display = 'none';
    this.textContent = 'Show Legend';
  }
});



    document.getElementById('live-log-search').addEventListener('input', applyLogFilters);

const ageSlider = document.getElementById('age-slider');
const ageValueDisplay = document.getElementById('age-value');
let ageDebounceTimer = null;

const historySlider = document.getElementById('history-slider');
const historyValueDisplay = document.getElementById('history-value');
historySlider.addEventListener('input', () => {
  historyValueDisplay.textContent = historySlider.value;
});

document.addEventListener("DOMContentLoaded", function() {

  const savedBasemap = localStorage.getItem('selectedBasemap');

  if (savedBasemap) {
    // Remove any default layer if needed.
    // (Here googleSat is added as default; you might want to remove it if the saved layer is different.)
    if (savedBasemap === "OSM") {
      // Remove the default Google layer (if it's on the map)
      if (map.hasLayer(googleSat)) {
        map.removeLayer(googleSat);
      }
      // Add the OSM layer.
      osm.addTo(map);
    } else if (savedBasemap === "Google") {
      if (map.hasLayer(osm)) {
        map.removeLayer(osm);
      }
      googleSat.addTo(map);
    }
    if (map.hasLayer(openSeaMapLayer)) {
      openSeaMapLayer.bringToFront();
    }
  }

  // History slider elements
  const historySlider = document.getElementById("history-slider");
  const historyValueDisplay = document.getElementById("history-value");
  
  // Age slider elements
  const ageSlider = document.getElementById("age-slider");
  const ageValueDisplay = document.getElementById("age-value");
  
  // Load saved history slider value if available
  const savedHistory = localStorage.getItem("historySliderValue");
  if (savedHistory !== null) {
    historySlider.value = savedHistory;
    historyValueDisplay.textContent = savedHistory;
  }
  
  // Load saved age slider value if available
  const savedAge = localStorage.getItem("ageSliderValue");
  if (savedAge !== null) {
    ageSlider.value = savedAge;
    ageValueDisplay.textContent = savedAge;
  }
  
  // Save new history slider value on input
  historySlider.addEventListener("input", () => {
    const currentValue = historySlider.value;
    historyValueDisplay.textContent = currentValue;
    localStorage.setItem("historySliderValue", currentValue);
  });
  
  // Save new age slider value on input
  ageSlider.addEventListener("input", () => {
    const currentValue = ageSlider.value;
    ageValueDisplay.textContent = currentValue;
    localStorage.setItem("ageSliderValue", currentValue);
  });
});

let historyDebounceTimer = null;
document.getElementById("history-slider").addEventListener("input", () => {
  const historyHours = parseInt(document.getElementById("history-slider").value, 10);
  historyValueDisplay.textContent = historyHours;
  
  const now = Date.now();
  // Immediately update the polyline tracks for all vessels using the new slider value.
for (let userID in vesselData) {
  if (vesselData[userID].track) {
    const filteredTrack = vesselData[userID].track.filter(pt => {
      const pointTime = new Date(pt[0]).getTime();
      return (now - pointTime) <= historyHours * 3600000;
    });
    // Remove the old track layer (if it exists)
    if (vesselTracks[userID]) {
      map.removeLayer(vesselTracks[userID]);
    }
    // Create a new colored track layer using createColoredTrack
    vesselTracks[userID] = createColoredTrack(filteredTrack);
    map.addLayer(vesselTracks[userID]);
    // Attach any necessary event handlers to the new layer.
    attachPolylineEvents(vesselTracks[userID], userID);
  }
}

  
  // Debounce the fetch for additional history data for the focused vessel.
  clearTimeout(historyDebounceTimer);
  historyDebounceTimer = setTimeout(() => {
    if (focusedVessel) {
      hydrateTrackHistory(focusedVessel);
    }
  }, 500); // Adjust debounce delay as needed.
});

document.getElementById('modal-close').addEventListener('click', closeImageModal);
document.getElementById('image-modal-overlay').addEventListener('click', function(e) {
  // If the click is on the overlay (not the content), close the modal.
  if (e.target === this) {
    closeImageModal();
  }
});

document.getElementById("age-slider").addEventListener("input", () => {
  const ageHours = parseInt(ageSlider.value, 10);  // Get the value of the age slider in hours.
  ageValueDisplay.textContent = ageHours;  // Display the selected value.

  // Debounce the filtering process to avoid excessive function calls.
  clearTimeout(ageDebounceTimer);
  ageDebounceTimer = setTimeout(() => {
    sendSummaryRequest();
    updateOverlay();  // Update the vessel overlay count
  }, 500);  // Adjust the debounce delay as needed.
});

map.on('moveend', function() {
  if (document.getElementById('show-ports').checked) {
	  clearTimeout(debounceTimeout);
	  debounceTimeout = setTimeout(() => {
	    fetchPorts();
	  }, 500);  // Wait for 500ms after the map view has stopped changing
  }
});
if (document.getElementById('show-ports').checked) {
  fetchPorts();
}

document.getElementById('show-ports').addEventListener('change', function() {
  if (this.checked) {
    fetchPorts(); // Load and display the ports
  } else {
    removePortMarkers(); // Hide all port markers
  }
});

map.on('zoomend', function() {
  const currentZoom = map.getZoom();
  for (const mmsi in vesselMarkers) {
    let marker = vesselMarkers[mmsi];
    // Focused vessel: update icon and tooltip based on the current zoom.
    if (mmsi === focusedVessel?.toString()) {
      if (currentZoom >= TOOLTIP_ZOOM_THRESHOLD) {
        marker.bindTooltip(vesselData[mmsi].Name, {
          permanent: true,
          direction: 'top',
          className: 'vessel-tooltip'
        }).openTooltip();
      } else {
        marker.unbindTooltip();
      }
      // Always use the detailed icon logic (which itself checks zoom level)
      marker.setIcon(getVesselIcon(vesselData[mmsi]));
    } else {
      // For non-focused vessels:
      if (currentZoom < 10) {
        // When zoom level is below 10, show simple circle markers and no tooltips.
        marker.unbindTooltip();
        marker.setIcon(createCircleIcon(vesselData[mmsi]));
      } else if (currentZoom < TOOLTIP_ZOOM_THRESHOLD) {
        // At zoom levels between 10 and 11.99, show the detailed icon but no tooltip.
        marker.unbindTooltip();
        marker.setIcon(getVesselIcon(vesselData[mmsi]));
      } else {
        // At zoom levels 12 and above, add tooltips and detailed icons.
        marker.bindTooltip(vesselData[mmsi].Name, {
          permanent: true,
          direction: 'top',
          className: 'vessel-tooltip'
        }).openTooltip();
        marker.setIcon(getVesselIcon(vesselData[mmsi]));
      }
    }
  }
});


const debouncedSendSummaryRequest = debounce(sendSummaryRequest, 250);
map.on("moveend", debouncedSendSummaryRequest);

        // Utility: Generate a random hex color.
        function randomColor() {
          return '#' + Math.floor(Math.random() * 16777215).toString(16).padStart(6, '0');
        }
    </script>
</body>

</html>
