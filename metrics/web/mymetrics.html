<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>Metrics Dashboard</title>
  <!-- Chart.js -->
  <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
  <style>
    body { font-family: Arial, sans-serif; margin: 20px; }
    .controls { margin-bottom: 20px; }
    .cards { display: flex; flex-wrap: wrap; gap: 20px; margin-bottom: 20px; }
    .card { background: #f9f9f9; border: 1px solid #ddd; border-radius: 8px; padding: 16px; min-width: 150px; text-align: center; }
    .card h3 { margin: 0 0 8px; font-size: 1em; color: #333; }
    .card p { margin: 0; font-size: 1.5em; font-weight: bold; }
    .charts { display: grid; grid-template-columns: repeat(auto-fill, minmax(400px, 1fr)); gap: 20px; margin-bottom: 20px; }
    .chart-container { width: 100%; height: 300px; }
    .doughnut-container { display: flex; justify-content: center; margin-bottom: 20px; }
    .doughnut-container canvas { max-width: 300px; max-height: 300px; }
    table { width: 100%; border-collapse: collapse; margin-top: 20px; }
    th, td { border: 1px solid #ccc; padding: 8px; text-align: left; }
    th { background: #f0f0f0; cursor: pointer; user-select: none; }
    th .arrow { margin-left: 4px; font-size: 0.8em; }
    td a { color: #0066cc; text-decoration: none; }
    td a:hover { text-decoration: underline; }
  </style>
</head>
<body>
  <div class="controls">
    <label for="ipInput">Override IP Address:</label>
    <input type="text" id="ipInput" placeholder="e.g. 44.31.231.4">
    <button id="applyBtn">Apply</button>
  </div>

  <h2>IP Address: <span id="ip-address">127.0.0.1</span></h2>

  <div class="cards" id="cards"></div>
  <div class="charts" id="charts"></div>

  <!-- Doughnut chart for Type distribution -->
  <div class="doughnut-container">
    <canvas id="typeDoughnut"></canvas>
  </div>

  <table id="summaryTable">
    <thead>
      <tr>
        <th data-field="id">MMSI<span class="arrow"></span></th>
        <th data-field="name">Name<span class="arrow"></span></th>
        <th data-field="typeName">Type<span class="arrow"></span></th>
        <th data-field="lastSeen">Last Seen<span class="arrow"></span></th>
        <th data-field="count">Count<span class="arrow"></span></th>
      </tr>
    </thead>
    <tbody id="summaryBody"></tbody>
  </table>

  <script>
    // register plugin for center text
    Chart.register({
      id: 'centerText',
      beforeDraw(chart) {
        const centerText = chart.config.options.plugins.centerText;
        if (!centerText) return;
        const { width, height, ctx } = chart;
        ctx.save();
        const fontSize = (height / 114).toFixed(2);
        ctx.font = `${fontSize}em sans-serif`;
        ctx.textBaseline = 'middle';
        const text = centerText.text || '';
        const textX = Math.round((width - ctx.measureText(text).width) / 2);
        const textY = height / 2;
        ctx.fillText(text, textX, textY);
        ctx.restore();
      }
    });

    const allMetrics = ['bytes_received','messages','failures','deduplicated','window_bytes','window_messages','window_unique_uids'];
    const cardMetrics = allMetrics.filter(m=>!m.startsWith('window_'));
    const chartMetrics = allMetrics.filter(m=>m.startsWith('window_'));
    const maxPoints = 60;
    let overrideIp = '';
    const charts = {}, baselines = {};
    const cardsContainer = document.getElementById('cards');
    const chartsContainer = document.getElementById('charts');

    const seenUserIds = new Set(), summaryCache = {}, lastSeenTs = {}, seenCount = {};
    let sortField = 'lastSeen', sortAsc = false;

    let typesConfig = null, typeDoughnut = null;

    function formatNumber(v){
      if(v>=1e6) return +(v/1e6).toFixed(v%1e6===0?0:2)+'M';
      if(v>=1e3) return +(v/1e3).toFixed(v%1e3===0?0:2)+'K';
      return v;
    }

    function formatAgo(ts){
      const sec = Math.floor((Date.now()-ts.getTime())/1000);
      const h=Math.floor(sec/3600), m=Math.floor((sec%3600)/60), s=sec%60;
      return (h? h+'h ':'') + (m? m+'m ':'') + s+'s ago';
    }

    const colors = ['rgba(255,99,132,1)','rgba(54,162,235,1)','rgba(255,206,86,1)','rgba(75,192,192,1)','rgba(153,102,255,1)','rgba(255,159,64,1)','rgba(199,199,199,1)','rgba(83,102,255,1)'];

    // Build cards
    cardMetrics.forEach(m=>{
      const c=document.createElement('div'); c.className='card'; c.id=`card-${m}`;
      c.innerHTML=`<h3>${m.replace(/_/g,' ')}</h3><p>0</p>`;
      cardsContainer.appendChild(c);
    });

    // Build charts
    chartMetrics.forEach((m,i)=>{
      const lbl=m.replace(/^window_/,'').replace(/_/g,' ');
      const cont=document.createElement('div'); cont.className='chart-container';
      const canvas=document.createElement('canvas'); canvas.id=`chart-${m}`;
      cont.appendChild(canvas); chartsContainer.appendChild(cont);
      const ctx=canvas.getContext('2d');
      charts[m]=new Chart(ctx,{
        type:'line',
        data:{labels:[],datasets:[{label:lbl,data:[],borderColor:colors[i%colors.length],fill:false}]},
        options:{animation:false,responsive:true,scales:{x:{title:{display:true,text:'Time'}},y:{}}}
      });
    });

    function applyOverride(ip){
      overrideIp=ip;
      document.getElementById('ipInput').value=ip;
      Object.keys(baselines).forEach(k=>delete baselines[k]);
      cardMetrics.forEach(m=>document.querySelector(`#card-${m} p`).textContent='0');
      chartMetrics.forEach(m=>{const c=charts[m];c.data.labels=[];c.data.datasets[0].data=[];c.update();});
      const url=new URL(location);
      ip?url.searchParams.set('ipaddress',ip):url.searchParams.delete('ipaddress');
      history.replaceState(null,'',url);
    }

    window.addEventListener('DOMContentLoaded',()=>{
      // fetch types.json
      fetch('/types.json')
        .then(r=>r.ok?r.json():Promise.reject(r.status))
        .then(json=>{ typesConfig=json; initDoughnut(); })
        .catch(e=>console.error('Failed to load types.json',e));

      const p=new URLSearchParams(location.search);
      if(p.has('ipaddress')) applyOverride(p.get('ipaddress'));
      fetchMetrics(); setInterval(fetchMetrics,1000);
    });

    document.getElementById('applyBtn').onclick=()=>applyOverride(document.getElementById('ipInput').value.trim());
    document.getElementById('ipInput').onkeydown=e=>{if(e.key==='Enter')applyOverride(e.target.value.trim());};

    // header sort
    document.querySelectorAll('#summaryTable th').forEach(th=>{
      th.onclick=()=>{
        const f=th.dataset.field;
        if(sortField===f) sortAsc=!sortAsc; else {sortField=f;sortAsc=true;}
        document.querySelectorAll('#summaryTable th .arrow').forEach(a=>a.textContent='');
        th.querySelector('.arrow').textContent=sortAsc?'▲':'▼';
        updateSummaryTable();
      };
    });

    async function fetchMetrics(){
      try {
        let url='/metrics/bysource';
        if(overrideIp) url+=`?ipaddress=${encodeURIComponent(overrideIp)}`;
        const r=await fetch(url); if(!r.ok) throw r.status;
        const data=await r.json();
        document.getElementById('ip-address').textContent=data.ip_address;
        const lbl=new Date().toLocaleTimeString();

        // update cards
        cardMetrics.forEach(m=>{
          if(baselines[m]===undefined) baselines[m]=data[m];
          document.querySelector(`#card-${m} p`).textContent=formatNumber(data[m]-baselines[m]);
        });

        // update charts
        chartMetrics.forEach(m=>{
          const c=charts[m];
          c.data.labels.push(lbl);
          c.data.datasets[0].data.push(data[m]);
          if(c.data.labels.length>maxPoints){c.data.labels.shift();c.data.datasets[0].data.shift();}
          c.update();
        });

        // process user IDs
        if(Array.isArray(data.window_user_ids)){
          data.window_user_ids.forEach(uid=>{
            lastSeenTs[uid]=new Date();
            seenCount[uid]=(seenCount[uid]||0)+1;
            if(!seenUserIds.has(uid)){
              seenUserIds.add(uid);
              fetch(`/summary?UserID=${encodeURIComponent(uid)}`)
                .then(r=>r.ok?r.json():Promise.reject(r.status))
                .then(json=>{ summaryCache[uid]=json[uid]||{}; updateSummaryTable(); })
                .catch(e=>console.error(`Summary ${uid} error`,e));
            }
          });
          updateSummaryTable();
        }
      } catch(e){ console.error('Fetch error', e); }
    }

    function typeNameFor(val){
      if(!typesConfig) return val;
      const catId=typesConfig.valueLookup[val];
      const cat=typesConfig.categories.find(c=>c.id===catId);
      return cat?cat.name:val;
    }

    function initDoughnut(){
      const ctx = document.getElementById('typeDoughnut').getContext('2d');
      typeDoughnut = new Chart(ctx, {
        type: 'doughnut',
        data: { labels: [], datasets: [{ data: [], backgroundColor: colors }] },
        options: {
          responsive: true,
          plugins: {
            legend: { position: 'right', labels: { boxWidth: 12 } },
            centerText: { display: true, text: '' }
          }
        }
      });
    }

    function updateDoughnut(){
      if(!typeDoughnut) return;
      const counts = {};
      Array.from(seenUserIds).filter(uid=>uid.length===9).forEach(uid=>{
        const t = summaryCache[uid]?.Type;
        const name = typeNameFor(t);
        counts[name] = (counts[name]||0) + 1;
      });
      const labels = Object.entries(counts).map(([name,c])=>`${name} (${c})`);
      const data = Object.values(counts);
      const total = data.reduce((a,b)=>a+b,0);

      typeDoughnut.data.labels = labels;
      typeDoughnut.data.datasets[0].data = data;
      typeDoughnut.options.plugins.centerText.text = total;
      typeDoughnut.update();
    }

    function updateSummaryTable(){
      const tbody=document.getElementById('summaryBody');
      const arr=Array.from(seenUserIds)
        .filter(uid=>uid.length===9)
        .map(uid=>({
          id:uid,
          info:summaryCache[uid]||{},
          lastTs:lastSeenTs[uid]||new Date(0),
          count:seenCount[uid]||0
        }));
      arr.sort((a,b)=>{
        let cmp;
        if(sortField==='lastSeen') cmp=a.lastTs-b.lastTs;
        else if(sortField==='name') cmp=(a.info.Name||'').localeCompare(b.info.Name||'');
        else if(sortField==='typeName') cmp=typeNameFor(a.info.Type).localeCompare(typeNameFor(b.info.Type));
        else if(sortField==='count') cmp=a.count-b.count;
        else cmp=a.id.localeCompare(b.id);
        return sortAsc?cmp:-cmp;
      });
      tbody.innerHTML='';
      arr.forEach(item=>{
        const ago=formatAgo(item.lastTs);
        const name=item.info.Name||'';
        const typeDisp=typeNameFor(item.info.Type);
        const tr=document.createElement('tr');
        tr.innerHTML=`
          <td><a href="/?UserID=${item.id}" target="_blank">${item.id}</a></td>
          <td>${name}</td>
          <td>${typeDisp}</td>
          <td>${ago}</td>
          <td>${item.count}</td>
        `;
        tbody.appendChild(tr);
      });
      updateDoughnut();
    }
  </script>
</body>
</html>
