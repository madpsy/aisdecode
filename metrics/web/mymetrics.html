<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Metrics Dashboard</title>

  <!-- Chart.js -->
  <script src="/aton_types.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
  <!-- Leaflet CSS/JS -->
  <link rel="stylesheet" href="https://unpkg.com/leaflet/dist/leaflet.css"/>
  <script src="https://unpkg.com/leaflet/dist/leaflet.js"></script>

  <style>
    body { font-family: Arial, sans-serif; margin: 20px; }
    .controls { margin-bottom: 20px; }
    .cards { display: flex; flex-wrap: wrap; gap: 20px; margin-bottom: 20px; }
    .card { background: #f9f9f9; border: 1px solid #ddd; border-radius: 8px; padding: 16px; min-width: 150px; text-align: center; }
    .card h3 { margin: 0 0 8px; font-size: 1em; color: #333; }
    .card p { margin: 0; font-size: 1.5em; font-weight: bold; }
    .charts { display: grid; grid-template-columns: repeat(auto-fill, minmax(400px, 1fr)); gap: 20px; margin-bottom: 20px; }
    .chart-container { width: 100%; height: 300px; }
    .doughnut-wrapper {
      display: flex;
      align-items: flex-start;
      justify-content: center;
      gap: 20px;
      margin-bottom: 20px;
    }
    canvas.doughnut-chart { width: 400px !important; height: 400px !important; }
    #map { width: 600px !important; height: 400px !important; position: relative; }
    table { width: 100%; border-collapse: collapse; margin-top: 20px; }
    th, td { border: 1px solid #ccc; padding: 8px; text-align: left; }
    th { background: #f0f0f0; cursor: pointer; user-select: none; }
    th .arrow { margin-left: 4px; font-size: 0.8em; }
    td a { color: #0066cc; text-decoration: none; }
    td a:hover { text-decoration: underline; }
    td img { display: block; }
    #pagination { margin: 10px 0; text-align: center; }
    #pagination button {
      margin: 0 2px;
      padding: 4px 8px;
      border: 1px solid #ccc;
      background: #fff;
      cursor: pointer;
      border-radius: 4px;
    }
    #pagination button.active {
      background: #0066cc;
      color: #fff;
      border-color: #0066cc;
    }
    #pagination button:disabled {
      opacity: 0.5;
      cursor: default;
    }

    .leaflet-popup-content-wrapper {
      border: none !important;
      box-shadow: none !important;
      padding: 5px !important;
    }
    .leaflet-popup-content-wrapper img {
      width: 120px;
      height: auto;
      flex-shrink: 0;
    }
    .leaflet-popup-content {
      margin: 0 !important;
      padding: 0 !important;
    }

    .flag-img {
      width: 30px;        /* your existing width */
      height: auto;
      box-sizing: border-box;      /* include border in that 24px */
      border: 1px solid #ccc;      /* a nice thin grey line */
      border-radius: 2px;          /* slightly rounded corners */
      display: block;              /* remove inline-img quirks */
    }

    /* Receiver tooltip styling */
    .receiver-tooltip {
      background: white;
      border: 1px solid #ccc;
      padding: 2px 6px;
      border-radius: 4px;
      box-shadow: 0 1px 2px rgba(0,0,0,0.2);
      font-size: 0.9em;
    }

    /* Lat/Lng overlay centered at top of map */
    .latlng-overlay {
      position: absolute;
      top: 10px;
      left: 50%;
      transform: translateX(-50%);
      background: rgba(255,255,255,0.8);
      padding: 4px 8px;
      font-weight: bold;
      border-radius: 4px;
      pointer-events: none;
      user-select: none;
      white-space: nowrap;
      display: none;
      z-index: 1000;
    }

    /* Distance label */
    .distance-tooltip {
      background-color: rgba(255,255,255,0.9);
      border: 1px solid #333;
      padding: 2px 4px;
      border-radius: 4px;
      font-weight: bold;
    }

    /* Hide distance column until a receiver is selected */
    .distance-col {
      display: none;
    }

    /* Top-centered RX selection flash message */
    .rx-overlay {
      position: fixed;
      top: 20px;
      left: 50%;
      transform: translateX(-50%);
      background: rgba(0,123,255,0.9);
      color: white;
      padding: 8px 16px;
      border-radius: 4px;
      font-weight: bold;
      font-size: 1em;
      z-index: 2000;
      pointer-events: none;
      opacity: 0;
      transition: opacity 0.3s ease;
    }
    .rx-overlay.show {
      opacity: 1;
    }

    /* highlight selected table row */
    #summaryBody tr.selected {
      background-color: #d0e8ff;
    }
  </style>
</head>
<body>
  <div class="controls">
    <label for="ipInput">Override IP Address:</label>
    <input type="text" id="ipInput" placeholder="e.g. 44.31.231.4" />
    <button id="applyBtn">Apply</button>
  </div>

  <h2>IP Address: <span id="ip-address">127.0.0.1</span></h2>

  <div class="cards" id="cards"></div>
  <div class="charts" id="charts"></div>

  <div class="doughnut-wrapper">
    <canvas id="typeDoughnut" class="doughnut-chart"></canvas>
    <div id="map"></div>
  </div>

  <!-- **Filter box** -->
  <div style="margin: 12px 0;">
    <input
      type="text"
      id="filterInput"
      placeholder="Filter by MMSI or Name"
      style="padding:6px; width:250px;"
    />
  </div>

  <table id="summaryTable">
    <thead>
      <tr>
        <th data-field="id">MMSI<span class="arrow"></span></th>
        <th data-field="name">Name<span class="arrow"></span></th>
        <th data-field="typeName">Type<span class="arrow"></span></th>
        <th data-field="status">Status<span class="arrow"></span></th>
        <th data-field="className">Class<span class="arrow"></span></th>
        <th data-field="flag">Flag<span class="arrow"></span></th>
        <th data-field="distance" class="distance-col">Distance<span class="arrow"></span></th>
        <th data-field="lastSeen">Last Seen<span class="arrow"></span></th>
        <th data-field="count">Packets<span class="arrow"></span></th>
      </tr>
    </thead>
    <tbody id="summaryBody"></tbody>
  </table>
  <div id="pagination"></div>

  <script>
    // Chart.js center-text plugin
    Chart.register({
      id: 'centerText',
      beforeDraw(chart) {
        const c = chart.config.options.plugins.centerText;
        if (!c?.display) return;
        const { ctx, chartArea: { left, right, top, bottom } } = chart;
        ctx.save();
        ctx.textAlign = 'center';
        ctx.textBaseline = 'middle';
        ctx.font = `${(bottom - top) / 10}px sans-serif`;
        ctx.fillText(c.text, (left + right)/2, (top + bottom)/2);
        ctx.restore();
      }
    });

    // Metrics definitions
    const allMetrics   = ['bytes_received','messages','failures','deduplicated','window_bytes','window_messages','window_unique_uids'];
    const cardMetrics  = allMetrics.filter(m => !m.startsWith('window_'));
    const chartMetrics = allMetrics.filter(m => m.startsWith('window_'));
    const maxPoints    = 60;
    let radiusCircles = [];
    let focusedUid = null;
    let overrideIp = '';
    let overlayDisplayed = false;
    let polylineAdded = false;
    let tooltipAdded = false;
    const charts = {}, baselines = {};
    const cardsContainer = document.getElementById('cards');
    const chartsContainer = document.getElementById('charts');

    const seenUserIds = new Set(), summaryCache = {}, lastSeenTs = {}, seenCount = {};
    let sortField = 'lastSeen', sortAsc = false;
    let typesConfig = null, typeDoughnut = null;

    // Pagination
    let currentPage = 1;
    const rowsPerPage = 10;

    // MIDs → country map
    let midMap = {};

    // Map & overlay state
    let map, overlayDiv, autoFit = true, programmaticFit = false, vesselMarkers = {}, typeColorsMap = {};
    const colors = ['rgba(255,99,132,1)','rgba(54,162,235,1)','rgba(255,206,86,1)','rgba(75,192,192,1)','rgba(153,102,255,1)','rgba(255,159,64,1)','rgba(199,199,199,1)','rgba(83,102,255,1)'];

    const navigationalStatusMapping = {
      0:"Using Engine",1:"At Anchor",2:"Not Under Command",
      3:"Restricted Manoeuvrability",4:"Constrained by Draft",
      5:"Moored",6:"Aground",7:"Engaged in Fishing",
      8:"Under Way Sailing",15:"Unknown"
    };

    // ——— NEW GLOBALS ———
    let selectedReceiverLatLng = null,
        distancePolyline = null,
        distanceLabel = null,
        overrideReceiverId = '',
        receiversList = [];

function kmToNM(km) {
  return km / 1.852;
}

// Function to draw rings based on receiver's location
function drawRadiusRings(latlng) {
  clearRadiusRings();  // Clear existing rings

  if (!latlng) return;  // No receiver selected

  const zoomLevel = map.getZoom();
  const distance = 5 * zoomLevel;  // Calculate distance (for example, the distance grows with zoom level)

  // Define the radii for the 3 rings (in nautical miles)
  const rings = [1, 3, 5];  // Example: 1 NM, 3 NM, 5 NM

  // Draw each circle and label it in nautical miles
  rings.forEach((nm, index) => {
    const radiusInMeters = nm * 1852;  // Convert NM to meters
    const circle = L.circle(latlng, {
      radius: radiusInMeters,
      color: 'blue',
      weight: 1,
      opacity: 0.6,
      fillOpacity: 0.1,
    }).addTo(map);

    // Label the circle with the distance in NM
    const label = L.tooltip({ permanent: true, direction: 'center', className: 'distance-tooltip' })
      .setLatLng(latlng)
      .setContent(`${nm} NM`)
      .addTo(map);

    radiusCircles.push({ circle, label });
  });
}

// Clear existing radius rings
function clearRadiusRings() {
  radiusCircles.forEach(item => {
    map.removeLayer(item.circle);
    map.removeLayer(item.label);
  });
  radiusCircles = [];
}

// Call this function when a receiver is selected
function updateReceiverRings(latlng) {
  drawRadiusRings(latlng);
}

    // **Filter term & row‐highlight helpers**
    let filterTerm = '';
    function clearSelectedRow() {
      const prev = document.querySelector('#summaryBody tr.selected');
      if (prev) prev.classList.remove('selected');
    }
    function highlightRow(uid) {
      const row = document.getElementById('row-' + uid);
      if (row) row.classList.add('selected');
    }

    // Haversine distance in km
    function haversineDistance(lat1, lon1, lat2, lon2) {
      function toRad(x){return x*Math.PI/180;}
      const R = 6371; // km
      const dLat = toRad(lat2 - lat1), dLon = toRad(lon2 - lon1);
      const a = Math.sin(dLat/2)**2 +
                Math.cos(toRad(lat1))*Math.cos(toRad(lat2))*
                Math.sin(dLon/2)**2;
      return R * 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));
    }

    // Remove existing line + label
function clearDistanceLine() {
  if (distancePolyline) { 
    map.removeLayer(distancePolyline); 
    distancePolyline = null; 
  }
  if (distanceLabel) { 
    map.removeLayer(distanceLabel); 
    distanceLabel = null; 
  }
  clearRadiusRings();  // Also clear the radius rings
}


    // Helpers
    function formatNumber(v){
      if(v>=1e6) return +(v/1e6).toFixed(v%1e6===0?0:2)+'M';
      if(v>=1e3) return +(v/1e3).toFixed(v%1e3===0?0:2)+'K';
      return v;
    }
    function formatAgo(ts){
      const sec = Math.floor((Date.now() - ts.getTime())/1000),
            h = Math.floor(sec/3600), m = Math.floor((sec%3600)/60), s = sec%60;
      return (h? h+'h ':'') + (m? m+'m ':'') + s+'s';
    }

    // Build cards
    cardMetrics.forEach(m => {
      const c = document.createElement('div');
      c.className = 'card'; c.id = `card-${m}`;
      c.innerHTML = `<h3>${m.replace(/_/g,' ')}</h3><p>0</p>`;
      cardsContainer.appendChild(c);
    });

    // Build line charts
    chartMetrics.forEach((m,i) => {
      const lbl = m.replace(/^window_/,'').replace(/_/g,' ');
      const cont = document.createElement('div');
      cont.className = 'chart-container';
      const canvas = document.createElement('canvas');
      canvas.id = `chart-${m}`;
      cont.appendChild(canvas);
      chartsContainer.appendChild(cont);
      const ctx = canvas.getContext('2d');
      charts[m] = new Chart(ctx, {
        type: 'line',
        data: { labels: [], datasets: [{ label: lbl, data: [], borderColor: colors[i%colors.length], fill: false }] },
        options: {
          animation: false,
          responsive: true,
          scales: {
            x: { title: { display: true, text: 'Time' } },
            y: {}
          }
        }
      });
    });

    // Apply override and reset everything
    function applyOverride(ip){
      overrideIp = ip;
      document.getElementById('ipInput').value = ip;

      // reset cards & charts
      Object.keys(baselines).forEach(k => delete baselines[k]);
      cardMetrics.forEach(m => document.querySelector(`#card-${m} p`).textContent = '0');
      chartMetrics.forEach(m => {
        const c = charts[m];
        c.data.labels = [];
        c.data.datasets[0].data = [];
        c.update();
      });

      // clear vessels & summary
      seenUserIds.clear();
      Object.values(vesselMarkers).forEach(m => map.removeLayer(m));
      vesselMarkers = {};
      Object.keys(summaryCache).forEach(k => delete summaryCache[k]);
      Object.keys(lastSeenTs).forEach(k => delete lastSeenTs[k]);
      Object.keys(seenCount).forEach(k => delete seenCount[k]);
      document.getElementById('summaryBody').innerHTML = '';
      currentPage = 1;

      // clear doughnut
      if(typeDoughnut){
        typeDoughnut.data.labels = [];
        typeDoughnut.data.datasets[0].data = [];
        typeDoughnut.options.plugins.centerText.text = '';
        typeDoughnut.update();
      }

      // reset sorting & pagination
      autoFit = true;
      sortField = 'lastSeen'; sortAsc = false;
      document.querySelectorAll('#summaryTable th .arrow').forEach(a=>a.textContent='');
      document.getElementById('pagination').innerHTML = '';

      // clear receiver selection & any line
      selectedReceiverLatLng = null;
      clearDistanceLine();

      // clear filter
      filterTerm = '';
      document.getElementById('filterInput').value = '';

      updateSummaryTable();

      // update URL
      const url = new URL(location);
      ip ? url.searchParams.set('ipaddress', ip) : url.searchParams.delete('ipaddress');
      history.replaceState(null, '', url);

      // hide overlay
      if (overlayDiv) updateOverlay(null);
    }

    window.addEventListener('DOMContentLoaded', ()=>{
      fetch('/types.json')
        .then(r => r.ok ? r.json() : Promise.reject(r.status))
        .then(json => { typesConfig = json; initDoughnut(); initMap(); })
        .catch(e => console.error('types.json error', e));

      fetch('/mids.json')
        .then(r => r.ok ? r.json() : Promise.reject(r.status))
        .then(json => { midMap = json; })
        .catch(e => console.error('mids.json error', e));

      const p = new URLSearchParams(location.search);
      if (p.has('ipaddress')) applyOverride(p.get('ipaddress'));
      if (p.has('receiver')) overrideReceiverId = p.get('receiver');
      fetchMetrics();
      setInterval(fetchMetrics, 1000);
    });

    document.getElementById('applyBtn').onclick = () =>
      applyOverride(document.getElementById('ipInput').value.trim());
    document.getElementById('ipInput').onkeydown = e => {
      if(e.key === 'Enter') applyOverride(document.getElementById('ipInput').value.trim());
    };

    // sorting
    document.querySelectorAll('#summaryTable th').forEach(th=>{
      th.onclick = ()=>{
        const f = th.dataset.field;
        if(!f) return;
        if(sortField === f) sortAsc = !sortAsc;
        else { sortField = f; sortAsc = true; }
        document.querySelectorAll('#summaryTable th .arrow').forEach(a=>a.textContent='');
        th.querySelector('.arrow').textContent = sortAsc ? '▲' : '▼';
        currentPage = 1;
        updateSummaryTable();
      };
    });

    // **filter handler**
    document.getElementById('filterInput').addEventListener('input', e=>{
      filterTerm = e.target.value.trim().toLowerCase();
      currentPage = 1;
      updateSummaryTable();
    });

    // Initialize map, overlay, and receivers
    function initMap(){
      map = L.map('map').setView([0,0],2);
      L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
        attribution: '&copy; OpenStreetMap contributors'
      }).addTo(map);

map.on('click', e => {
  const tgt = e.originalEvent.target;

  // if the click came from a marker icon, popup, or tooltip, ignore it
  if (
    tgt.classList.contains('leaflet-marker-icon') ||
    tgt.classList.contains('leaflet-interactive') ||  // SVG marker
    tgt.closest('.leaflet-popup') ||
    tgt.closest('.distance-tooltip')
  ) {
    return;
  }

  // otherwise clear
  updateOverlay(null);
  clearDistanceLine();
  clearSelectedRow();
  focusedUid = null;
});

      // create and append overlay
      overlayDiv = document.createElement('div');
      overlayDiv.className = 'latlng-overlay';
      map.getContainer().appendChild(overlayDiv);
      updateOverlay(null);

      loadReceivers();

      map.on('movestart zoomstart', ()=>{ if(!programmaticFit) autoFit = false; });
    }

function updateOverlay(latlng) {

  if (!overlayDiv) return;

  if (latlng) {
    // Display overlay if not already displayed
    if (!overlayDisplayed) {
      overlayDiv.textContent = `${latlng.lat.toFixed(4)}, ${latlng.lng.toFixed(4)}`;
      overlayDiv.style.display = 'block';
      overlayDisplayed = true;
    }
  } else {
    // Hide the overlay only if it was previously displayed
    if (overlayDisplayed) {
      overlayDiv.style.display = 'none';
      overlayDisplayed = false;
    }
  }
}


    // Fetch & draw receiver markers
function loadReceivers() {
  // clear any previous receivers
  receiversList = [];
  fetch('/receivers')
    .then(r => {
      if (!r.ok) throw new Error(`HTTP ${r.status}`);
      return r.json();
    })
    .then(receivers => {
      receivers.forEach(r => {
        // create the circle marker
        const dot = L.circleMarker([r.latitude, r.longitude], {
          radius: 8,
          color: 'red',
          fillColor: 'red',
          fillOpacity: 1,
          weight: 1
        }).addTo(map);

        // tooltip with the RX name
        dot.bindTooltip(`${r.name} (RX)`, {
          permanent: true,
          direction: 'top',
          className: 'receiver-tooltip'
        });

        // click handler: select this receiver
        dot.on('click', e => {
          L.DomEvent.stopPropagation(e);
          selectedReceiverLatLng = e.latlng;
          clearDistanceLine();
          updateOverlay(e.latlng);
          updateSummaryTable();

          // update the URL to include ?receiver=<id>
          const url = new URL(location);
          url.searchParams.set('receiver', r.id);
          history.replaceState(null, '', url);
        });

        // store for nearest/override lookup
        receiversList.push({
          id:   r.id,
          name: r.name,
          marker: dot,
          latlng: L.latLng(r.latitude, r.longitude)
        });
      });

      // if the user passed ?receiver= in the URL, force-select it now
     if (overrideReceiverId) {
       // coerce to the same type
       const idToMatch = typeof receiversList[0].id === 'number'
         ? Number(overrideReceiverId)
         : overrideReceiverId;

       const forced = receiversList.find(rx => rx.id === idToMatch);
       if (forced) {
         // manually set selection state
         selectedReceiverLatLng = forced.latlng;
         updateOverlay(forced.latlng);
         updateSummaryTable();

         // update URL cleanly
         const url = new URL(location);
         url.searchParams.set('receiver', forced.id);
         history.replaceState(null, '', url);

         // fire the click *with* a latlng payload
         forced.marker.fire('click', { latlng: forced.latlng });
       }
     }

    })
    .catch(err => console.error('Failed to load receivers', err));
 }

    // Vessel icon creation
    function makeIcon(info, color){
      if(info.Sog > 0.5){
        const angle = info.Cog || 0;
        return L.divIcon({
          html: `<div style="transform: rotate(${angle}deg) scaleY(1.5); font-size: 20px; color: ${color};">&#9650;</div>`,
          className: '', iconSize: [20,30]
        });
      } else {
        return L.divIcon({
          html: `<div style="width:12px; height:12px; background:${color}; border-radius:50%;"></div>`,
          className: '', iconSize: [12,12]
        });
      }
    }

    // Focus vessel from table
function focusVessel(uid){
  focusedUid = uid;
  Object.values(vesselMarkers).forEach(m => m.closePopup());
  clearSelectedRow();
  highlightRow(uid);

  const marker = vesselMarkers[uid];
  if(!marker) return;

  updateOverlay(marker.getLatLng());

  // if a receiver is selected: fit to both points
  if (selectedReceiverLatLng) {
    const vesselLatLng   = marker.getLatLng();
    const bounds         = L.latLngBounds([ selectedReceiverLatLng, vesselLatLng ]);
    autoFit               = false;
    programmaticFit        = true;
    map.once('moveend zoomend', () => programmaticFit = false);
    map.fitBounds(bounds, { padding: [30,30] });

    // draw the distance line as before
    clearDistanceLine();
    const dist = haversineDistance(
      selectedReceiverLatLng.lat, selectedReceiverLatLng.lng,
      vesselLatLng.lat,            vesselLatLng.lng
    ).toFixed(2);
    distancePolyline = L.polyline([ selectedReceiverLatLng, vesselLatLng ], { color:'blue' }).addTo(map);
    const mid = [(selectedReceiverLatLng.lat+vesselLatLng.lat)/2, (selectedReceiverLatLng.lng+vesselLatLng.lng)/2];
    distanceLabel = L.tooltip({ permanent:true, direction:'center', className:'distance-tooltip' })
                     .setLatLng(mid)
                     .setContent(`${dist} km`)
                     .addTo(map);

  } else {
    // fallback to just centering on vessel
    autoFit        = false;
    programmaticFit = true;
    map.once('moveend zoomend', () => programmaticFit = false);
    map.flyTo(marker.getLatLng(), 11);
  }

  marker.fire('mouseover');
  document.getElementById('map').scrollIntoView({ behavior:'smooth', block:'start' });
}

    // Update vessel markers & fit bounds
    function updateMap(){
      const oldVesselCount = Object.keys(vesselMarkers).length;
      const boundsArr = [], newMarkers = {};
      seenUserIds.forEach(uid=>{
        if(uid.length!==9) return;
        const info = summaryCache[uid];
        if(!info) return;
        const { Latitude: lat, Longitude: lon } = info;
        if(typeof lat!=='number' || typeof lon!=='number') return;
        boundsArr.push([lat,lon]);
        const typeDisp = typeNameFor(info);
        const color    = typeColorsMap[typeDisp] || '#000';
        const icon     = makeIcon(info, color);

        if(vesselMarkers[uid]){
          vesselMarkers[uid].setLatLng([lat,lon]).setIcon(icon);
          newMarkers[uid] = vesselMarkers[uid];
        } else {
          const m = L.marker([lat,lon], { icon });

m.on('click', function(e) {
  // reset line-drawing state
  polylineAdded = false;
  tooltipAdded  = false;

  L.DomEvent.stopPropagation(e);
  updateOverlay(e.latlng);

  // close other popups
  Object.values(vesselMarkers).forEach(m2 => m2.closePopup());

  // open this one and keep it open
  m.openPopup();

  focusedUid = uid;
  clearSelectedRow();
  highlightRow(uid);

  if (selectedReceiverLatLng) {
    clearDistanceLine();
    const vesselLatLng = m.getLatLng();
    const dist = haversineDistance(
      selectedReceiverLatLng.lat,
      selectedReceiverLatLng.lng,
      vesselLatLng.lat,
      vesselLatLng.lng
    ).toFixed(2);

    distancePolyline = L.polyline(
      [selectedReceiverLatLng, vesselLatLng],
      { color: 'blue', weight: 3, opacity: 0.7, zIndex: 1000 }
    ).addTo(map);

    const midLat = (selectedReceiverLatLng.lat + vesselLatLng.lat)/2;
    const midLng = (selectedReceiverLatLng.lng + vesselLatLng.lng)/2;
    distanceLabel = L.tooltip({
      permanent: true,
      direction: 'center',
      className: 'distance-tooltip',
      zIndex: 1001
    })
      .setLatLng([midLat, midLng])
      .setContent(`${dist} km`)
      .addTo(map);

    const bounds = L.latLngBounds([selectedReceiverLatLng, vesselLatLng]);
    map.fitBounds(bounds, { padding: [30, 30] });
  }
});


          m.on('mouseover', ()=>{
            const status = navigationalStatusMapping[info.NavigationalStatus] || 'Unknown';
            const detailsHtml = `
              <div style="line-height:1.2;">
                <b>MMSI:</b> ${uid}<br/>
                <b>Name:</b> ${info.Name || ''}<br/>
                <b>Speed:</b> ${info.Sog} kn<br/>
                <b>Type:</b> ${typeDisp}<br/>
                <b>Status:</b> ${status}<br/>
                <b>Class:</b> ${info.AISClass || ''}
              </div>
            `;
            m.bindPopup(detailsHtml, { closeButton: false, autoClose: false }).openPopup();
            fetch(`/state/${encodeURIComponent(uid)}`)
              .then(res => res.ok ? res.json() : Promise.reject(res.status))
              .then(state => {
                if(state.ImageURL){
                  const flexHtml = `
                    <div style="display:flex;align-items:center;gap:8px;">
                      <img src="${state.ImageURL}" style="max-width:120px;max-height:80px;flex-shrink:0;" alt="State image"/>
                      <div style="line-height:1.2;">
                        <b>MMSI:</b> ${uid}<br/>
                        <b>Name:</b> ${info.Name || ''}<br/>
                        <b>Speed:</b> ${info.Sog} kn<br/>
                        <b>Type:</b> ${typeDisp}<br/>
                        <b>Status:</b> ${status}<br/>
                        <b>Class:</b> ${info.AISClass || ''}
                      </div>
                    </div>
                  `;
                  m.getPopup().setContent(flexHtml).update();
                  m.openPopup();
                }
              })
              .catch(e => console.error(`Failed to load state for ${uid}`, e));
          });

          m.on('mouseout', () => m.closePopup());
          //m.on('popupclose', () => {
          //  updateOverlay(null);
          //  clearDistanceLine();
          //});

          m.addTo(map);
          vesselMarkers[uid] = m;
          newMarkers[uid] = m;
        }
      });

      Object.keys(vesselMarkers).forEach(uid => {
        if(!newMarkers[uid]) map.removeLayer(vesselMarkers[uid]);
      });
  vesselMarkers = newMarkers;

  // auto‐select nearest RX on first vessel arrival (unless overridden)
  const newVesselCount = Object.keys(vesselMarkers).length;
  if (
    oldVesselCount === 0 &&
    newVesselCount > 0 &&
    receiversList.length > 0 &&
    !overrideReceiverId
  ) {
    // pick the very first vessel
    const firstUid = Object.keys(vesselMarkers)[0];
    const vesselLatLng = vesselMarkers[firstUid].getLatLng();

    // find closest receiver
    let closest = null, minDist = Infinity;
    receiversList.forEach(rx => {
      const d = haversineDistance(
        vesselLatLng.lat, vesselLatLng.lng,
        rx.latlng.lat, rx.latlng.lng
      );
      if (d < minDist) { minDist = d; closest = rx; }
    });

    // trigger click + flash overlay
    if (closest) {
      // explicitly select this RX
      selectedReceiverLatLng = closest.latlng;
      // update overlay & table
      updateOverlay(closest.latlng);
      updateSummaryTable();

      // fire tooltip & URL update
      closest.marker.fire('click', { latlng: closest.latlng });
      const ov = document.createElement('div');
      ov.className = 'rx-overlay';
      ov.textContent = `Selected RX ${closest.name}`;
      document.body.appendChild(ov);
      requestAnimationFrame(() => ov.classList.add('show'));
      setTimeout(() => {
        ov.classList.remove('show');
        ov.addEventListener('transitionend', () => ov.remove(), { once: true });
      }, 2000);
    }
  }

      if(autoFit && boundsArr.length){
        programmaticFit = true;
        map.once('moveend zoomend', ()=> programmaticFit = false);
        map.fitBounds(L.latLngBounds(boundsArr), { padding: [30,30] });
      }
    }

    // Fetch metrics, update cards/charts/table
    async function fetchMetrics(){
      try {
        let url = '/metrics/bysource';
        if(overrideIp) url += `?ipaddress=${encodeURIComponent(overrideIp)}`;
        const res = await fetch(url);
        if(!res.ok) throw res.status;
        const data = await res.json();
        document.getElementById('ip-address').textContent = data.ip_address;
        const lbl = new Date().toLocaleTimeString();

        cardMetrics.forEach(m => {
          if(baselines[m]===undefined) baselines[m]=data[m];
          document.querySelector(`#card-${m} p`).textContent = formatNumber(data[m]-baselines[m]);
        });

        chartMetrics.forEach(m => {
          const c = charts[m];
          c.data.labels.push(lbl);
          c.data.datasets[0].data.push(data[m]);
          if(c.data.labels.length>maxPoints){
            c.data.labels.shift();
            c.data.datasets[0].data.shift();
          }
          c.update();
        });

        if(Array.isArray(data.window_user_ids)){
          data.window_user_ids.forEach(uid=>{
            lastSeenTs[uid] = new Date();
            seenCount[uid] = (seenCount[uid]||0)+1;
            if(!seenUserIds.has(uid)){
              seenUserIds.add(uid);
              fetch(`/summary?UserID=${encodeURIComponent(uid)}`)
                .then(r=>r.ok? r.json():Promise.reject(r.status))
                .then(json=>{ summaryCache[uid]=json[uid]||{}; updateSummaryTable(); })
                .catch(e=>console.error(`summary ${uid} error`,e));
            }
          });
          updateSummaryTable();
        }
      } catch(e) {
        console.error('Fetch error', e);
      }
    }

    function typeNameFor(info) {
      if (info.AISClass === 'AtoN') {
        return staticAtoNTypeMapping[info.Type]
          || `Unknown AtoN (${info.Type})`;
      }
      if (!typesConfig) return info.Type;
      const catId = typesConfig.valueLookup[info.Type];
      const cat   = typesConfig.categories.find(c=>c.id === catId);
      return cat ? cat.name : info.Type;
    }

    function initDoughnut(){
      const ctx = document.getElementById('typeDoughnut').getContext('2d');
      typeDoughnut = new Chart(ctx, {
        type: 'doughnut',
        data: { labels: [], datasets: [{ data: [], backgroundColor: [] }] },
        options: {
          responsive: true,
          plugins: {
            legend: { position: 'right', labels: { boxWidth:12 } },
            centerText: { display: true, text: '' }
          }
        }
      });
    }

    function updateDoughnut(){
      if(!typeDoughnut) return;
      const counts = {};
      Array.from(seenUserIds)
       .filter(uid=>uid.length===9)
       .forEach(uid=>{
         // ✅ pass the full info object
         const info = summaryCache[uid] || {};
         const name = typeNameFor(info);
         counts[name] = (counts[name]||0) + 1;
      });
      const entries = Object.entries(counts);
      typeColorsMap = {};
      const bg = entries.map((_,i)=>colors[i%colors.length]);
      entries.forEach(([name],i)=> typeColorsMap[name]=bg[i]);
      typeDoughnut.data.labels = entries.map(e=>`${e[0]} (${e[1]})`);
      typeDoughnut.data.datasets[0].data = entries.map(e=>e[1]);
      typeDoughnut.data.datasets[0].backgroundColor = bg;
      typeDoughnut.options.plugins.centerText.text = entries.reduce((sum,[,c])=>sum+c,0);
      typeDoughnut.update();
      updateMap();
    }

    function renderPagination(totalPages){
      const container = document.getElementById('pagination');
      container.innerHTML = '';
      const prev = document.createElement('button');
      prev.textContent = '« Prev';
      prev.disabled = currentPage===1;
      prev.onclick = ()=>{ currentPage--; updateSummaryTable(); };
      container.appendChild(prev);
      for(let p=1; p<=totalPages; p++){
        const btn = document.createElement('button');
        btn.textContent = p;
        if(p===currentPage) btn.classList.add('active');
        btn.onclick = ()=>{ currentPage=p; updateSummaryTable(); };
        container.appendChild(btn);
      }
      const next = document.createElement('button');
      next.textContent = 'Next »';
      next.disabled = currentPage===totalPages;
      next.onclick = ()=>{ currentPage++; updateSummaryTable(); };
      container.appendChild(next);
    }

    function updateSummaryTable(){
      // Show/hide distance column
      const showDist = !!selectedReceiverLatLng;
      document.querySelectorAll('.distance-col').forEach(el=>{
        el.style.display = showDist ? '' : 'none';
      });

      let allRows = Array.from(seenUserIds)
        .filter(uid=>uid.length===9)
        .map(uid=>({
          id: uid,
          info: summaryCache[uid]||{},
          lastTs: lastSeenTs[uid]||new Date(0),
          count: seenCount[uid]||0
        }));

      // **filter**
      if(filterTerm){
        allRows = allRows.filter(item=>
          item.id.includes(filterTerm) ||
          (item.info.Name||'').toLowerCase().includes(filterTerm)
        );
      }

      allRows.sort((a,b)=>{
        let cmp;
        if(sortField==='lastSeen') cmp = a.lastTs - b.lastTs;
        else if(sortField==='name') cmp = (a.info.Name||'').localeCompare(b.info.Name||'');
        else if(sortField==='typeName') cmp = typeNameFor(a.info).localeCompare(typeNameFor(b.info));
        else if(sortField==='status'){
          const sa = navigationalStatusMapping[a.info.NavigationalStatus]||'Unknown';
          const sb = navigationalStatusMapping[b.info.NavigationalStatus]||'Unknown';
          cmp = sa.localeCompare(sb);
        }
        else if (sortField==='className') {
          const ca = a.info.AISClass||'';
          const cb = b.info.AISClass||'';
          cmp = ca.localeCompare(cb);
        }
        else if(sortField==='count') cmp = a.count - b.count;
	else if (sortField === 'distance' && selectedReceiverLatLng) {
	  const getDist = item => {
	    const { Latitude: lat, Longitude: lon } = item.info;
	    return (typeof lat === 'number' && typeof lon === 'number')
	      ? haversineDistance(
	          selectedReceiverLatLng.lat,
	          selectedReceiverLatLng.lng,
	          lat, lon
	        )
	      : Infinity;
	  };
	  const dA = getDist(a);
	  const dB = getDist(b);
	  cmp = dA - dB;
	}
	else if (sortField === 'flag') {
	    const midA = a.id.slice(0,3), midB = b.id.slice(0,3);
	    const entryA = midMap[midA] || [], entryB = midMap[midB] || [];
	    const nameA = entryA[0] || '';
	    const nameB = entryB[0] || '';
	    cmp = nameA.localeCompare(nameB);
	}
        else cmp = a.id.localeCompare(b.id);
        return sortAsc ? cmp : -cmp;
      });

      const totalPages = Math.max(1, Math.ceil(allRows.length/rowsPerPage));
      if(currentPage>totalPages) currentPage = totalPages;
      const start = (currentPage-1)*rowsPerPage;
      const pageRows = allRows.slice(start, start+rowsPerPage);

      const tbody = document.getElementById('summaryBody');
      tbody.innerHTML = '';
      pageRows.forEach(item=>{
        const ago = formatAgo(item.lastTs);
        const mid = item.id.slice(0,3);
        const entry = midMap[mid]||[];
        const countryCode = entry[0]||'';
        const countryName = entry[3]||'';
        const flagCell = countryCode
          ? `<td><img class="flag-img" src="/flags/${countryCode.toLowerCase()}.svg" alt="${countryName}" title="${countryName}"/></td>`
          : '<td></td>';

        let distanceCell = '<td class="distance-col"></td>';
        if(selectedReceiverLatLng && typeof item.info.Latitude==='number' && typeof item.info.Longitude==='number'){
          const d = haversineDistance(
            selectedReceiverLatLng.lat,
            selectedReceiverLatLng.lng,
            item.info.Latitude,
            item.info.Longitude
          ).toFixed(2);
          distanceCell = `<td class="distance-col">${d} km</td>`;
        }

        const status = navigationalStatusMapping[item.info.NavigationalStatus]||'Unknown';
        const tr = document.createElement('tr');
        tr.id = 'row-' + item.id;              // give each row an id
        tr.innerHTML = `
          <td><a href="#" onclick="focusVessel('${item.id}'); return false;">${item.id}</a></td>
          <td>${item.info.Name||''}</td>
          <td title="Type: ${typeNameFor(item.info)}\nStatus: ${status}">${typeNameFor(item.info)}</td>
          <td>${status}</td>
          <td>${item.info.AISClass||''}</td>
          ${flagCell}
          ${distanceCell}
          <td>${ago}</td>
          <td>${item.count}</td>
        `;
        tbody.appendChild(tr);
      });

      // Toggle distance column now that rows are in the DOM
      document.querySelectorAll('.distance-col').forEach(el=>{
        el.style.display = showDist ? 'table-cell' : 'none';
      });
      if (focusedUid) {
        const stillThere = document.getElementById('row-' + focusedUid);
        if (stillThere) stillThere.classList.add('selected');
      }
      renderPagination(totalPages);
      updateDoughnut();
    }


  </script>
</body>
</html>
